{"componentChunkName":"component---src-templates-post-js","path":"/posts/利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器/","result":{"data":{"sitePage":{"id":"SitePage /posts/利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器/"}},"pageContext":{"url":"/posts/利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器/","relativePath":"posts/利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器.md","relativeDir":"posts","base":"利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器.md","name":"利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器","frontmatter":{"title":"利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器","stackbit_url_path":"posts/利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器","date":"2009-11-20 14:03:08","excerpt":"","comments_count":0,"positive_reactions_count":0,"tags":[null],"canonical_url":"https://be-net.azurewebsites.net/post/2009/11/20/利用Ajax技术读取RSS新闻源，并构建一个在线的阅读器","template":"post"},"html":"<pre><code>    &#x3C;div style=\"text-indent: 2em;\">\n</code></pre>\n<p>示例：<a href=\"http://www.myfootprints.cn/tools/8.asp\" target=\"_blank\" title=\"在线RSS阅读器\">点击查看示例</a></p>\n<p>本文将讲述如何利用Ajax技术来读取RSS新闻源，如果你对什么Ajax技术不了解，可以参考《<a href=\"http://www.myfootprints.cn/blog/post/WhatIsAjax.html\" title=\"什么是Ajax？\" target=\"_blank\">什么是Ajax？</a>》；如果你对什么RSS不了解，可以参考《<a href=\"http://www.myfootprints.cn/blog/post/WhatIsRSS.html\" title=\"什么是RSS？\" target=\"_blank\">什么是RSS？</a>》。</p>\n<p>如果你只想赶紧用起来，在自己的网站上加入想要的RSS内容，那么你可能会惊讶它会是如此的简单，即只需要在HTML文档中加入两行代码即可实现（前提是在按照下面的方法做好一些准备工作后）。为了能将自己感兴趣的RSS内容添加到自己的网站上，你需要这个RSS源的Url，如 http://www.myfootprints.cn/blog/rss.xml；而要此RSS内容添加到网页的哪个位置呢？这需要那个位置的ID，如idReader。有了这两个参数，只需写如下两行代码即可达到目的。</p>\n<pre class=\"brush: javascript\" style=\"text-indent: 0;\">var oRssReader = new mfRSSReader('idReader', 'http://www.myfootprints.cn/blog/rss.xml');\noRssReader.loadFeed();\n</pre>\n<p>需要做哪些准备工作呢？准备两个文件即可。</p>\n<ol style=\"text-indent: 0;\">\n<li>后台服务器代理查询文件。<p style=\"text-indent: 2em;\">为什么需要这个文件呢？因为Ajax的本质是使用JavaScript查询网站的少量数据，而基于安全原因，客户端的JavaScript不能够跨域请求数据，即www.a.com网站上的JavaScript不可以请求www.b.com网站上的数据。然而，服务端的脚本却不存在这个限制，于是，在自己网站上添加别人的RSS新闻内容的这个需求上，有必要也有可能在客户端与别的服务器之间设置一个代理，它接收客户端JavaScript的请求，转发给目的地服务器，收到回复后将回复再转发给客户端JavaScript。（假如不是由于这个安全原因，就不需要这个文件了。）</p>\n<p style=\"text-indent: 2em;\">好了，说了这么多，要记住的就是这个文件仅仅起个传话筒的作用，将目的服务器的回复响应原封不动地转发给客户端JavaScript。它的构建非常简单，也不是重点，但却是个基础。我们的重点在于构建第二个文件，而第二个文件需要通过这个文件来获取目的服务器的数据。如果你的服务器脚本采用ASP，那么建立下面这样一个文件就行了(假设命名为newsfeeder.asp，保存在网站根目录)。</p>\n<pre class=\"brush: vb\" style=\"text-indent: 0;\">&lt;%@LANGUAGE=\"VBSCRIPT\" CODEPAGE=\"65001\"%&gt;\n&lt;% Option Explicit %&gt;\n&lt;%Session.CodePage=65001%&gt;\n&lt;%\n    Response.ContentType = \"text/xml\"\n    Dim sRSSUrl, oHTTP\n    sRSSUrl = Request.QueryString(\"rssurl\")\n<pre><code>Set oHTTP = Server.CreateObject(\"Microsoft.XMLHTTP\")\noHTTP.Open \"GET\", sRSSURL, False\noHTTP.Send\n\nResponse.Write oHTTP.ResponseXML.XML\nSet oHTTP = Nothing\n</code></pre>\n<p>%>\n</pre></p>\n<p style=\"text-indent: 2em;\">如果你的服务器脚本是PHP，那么建立如下的文件就可以了（假设命名为newsfeeder.php，保存在网站根目录）。</p>\n<pre class=\"brush: php\" style=\"text-indent: 0;\">&lt;?php\nheader('Content-type: text/xml;');\n<p>// 返回RSS源数据\necho file_get_contents($_REQUEST['rssurl']);\n?>\n</pre></p>\n</li>\n<li>获取RSS的核心JavaScript文件。<p style=\"text-indent: 2em;\">此文件由一个mfRSSReader类以及一个辅助函数组成。正是这个mfRSSReader类隐藏了发送异步数据请求的细节，而辅助函数隐藏了如何处理响应数据的细节，使得最终使用它们是如此的简单。</p>\n<p style=\"text-indent: 2em;\">在详细展示它的代码前，我再做一些介绍。mfRSSReader类有如下几个属性，通过设置这些属性，你可以按照自己的偏好来使用它。</p>\n<ul style=\"text-indent: 0;\">\n<li><strong>Request</strong>。这个属性就是XMLHTTP请求对象，它保存着服务器的响应数据，即RSS源的内容。它不需要设置。</li>\n<li><strong>ReaderDivId</strong>。这个属性就是HTML文档中的一个层（Div）或者一块其他区域的ID值，通过自定义这个属性，你可以将RSS源内容显示到HTML文档中的指定的地方。</li>\n<li><strong>RssUrl</strong>。这个属性保存着RSS源的Url地址。通过自定义这个值，你可以获取指定的RSS源内容。</li>\n<li><strong>WaitDesc</strong>。这个属性可以用来设置查询RSS源时的说明文字。它不是必需要进行设置的。</li>\n<li><strong>WaitImageSrc</strong>。这个属性是一个Url（可以是相对Url，如images/wait.gif，也可以是绝对Url，如http://www.myfootprints.cn/images/logo.gif）。它可以用来设置查询RSS源时的等待图标。它也不是必需要进行设置的。</li>\n<li><strong>AjaxStateId</strong>。这个属性保存了显示Ajax查询状态信息的HTML文档中的层的ID值。它不是必需的，如果进行了设置，那么在HTML文档的指定区域，会显示Ajax的查询状态（如查询是否成功等）。</li>\n<li><strong>FeedCount</strong>。这个属性不是必需设置的。它用来指定显示几条新闻。默认是10。它是用来给辅助处理函数（后面会讲到辅助处理函数）用的。</li>\n<li><strong>Handler</strong>。它是处理函数的引用。通过设置它的值，你可以选择以何种方式显示RSS源。它不是必需设置的，默认为将RSS源的内容显示为一个标题列表。</li>\n<li><strong>ServerFeeder</strong>。它存储着后台服务器查询代理的Url。</li>\n<li><strong>TimeoutIds</strong>。它不需要进行设置。</li>\n</ul>\n<p style=\"text-indent: 2em;\">以上是mfRSSReader类的属性，它还有一些方法，然而你真正会用到的就是loadFeed()方法，在设置好相关属性后（如果你懒得设置，可以一个都不设置），直接调用它，就完成了所有工作。</p>\n<p style=\"text-indent: 2em;\">辅助处理函数是干什么的呢？它就是对mfRSSReader类里的Request对象的xml数据（如上所述，Request对象保存着目的服务器的响应数据）进行分析，并以恰当的格式将数据呈现出来。你可以自定义这个函数，以自己的偏好来显示RSS新闻源内容。如果你将这个函数命名为myHandler(oRssReader)，那么，将你的mfRSSReader类的实例的Handler属性指向它即可，如下所示。注意，这个处理函数有一个参数，就是你的mfRSSReader的实例，在处理函数内部对这个参数进行处理。</p>\n<pre class=\"brush: javascript\" style=\"text-indent: 0;\">// 定义一个mfRSSReader类的实例\nvar oRssReader = mfRSSReader();\n// 做一些设置，如RSS源是什么，显示在HTML文档的哪个地方等\n// 然后，设置自己的处理函数\noRssReader.Handler = myHandler;\n// 设置完成后，加载RSS源即可\noRssReader.loadFeed();\n</pre>\n<p>以下即将展示这个核心JavaScript文件的所有代码，有详细的注释方便阅读，如果你不想深究，那么将复制下来，保存为mfRSSReader.js，即可按照上述介绍使用它了！注意在网页的&lt;head&gt;部分加入对此文件的引用，即：</p>\n<pre class=\"brush: html\" style=\"text-indent: 0;\">&lt;script type=\"text/javascript\" src=\"mfRSSReader.js\"&gt;&lt;script/&gt;\n</pre>\n<p>mfRSSReader.js的代码：</p>\n<pre class=\"brush: javascript\" style=\"text-indent: 0;\">/**\n * mfRSSReader.js.\n * \n * Version 2.0\n * Copyright (C) 2009- admin@myfootprints.cn.\n * http://www.myfootprints.cn\n * \n *\n * 用途：将指定的RSS源的内容显示在指定的DIV框架中\n */\n<p>//\n// mfRSSReader 对象\n//\n// 用途：用来构建 mfRSSReader 对象\n// 参数：\n//  sReaderDivId, RSS内容将会在HTML文档中的ID为sReaderDivId的Div层中显示\n//  sRssUrl, 指定的RSS源\n//  sWaitDesc, 可选参数，加载描述文字，如\"正在加载\"\n//  sWaitImageSrc, 可选参数，加载提示图片的Url，可以是相对路径\n//  sAjaxStateDivId, 可选参数，用于显示提示Ajax状态的HTML文档中的Div层的Id，一般可以不在文档中放置这个层，这个参数可以省略\n//\nfunction mfRSSReader(sReaderDivId, sRssUrl, sWaitDesc, sWaitImageSrc, sAjaxStateDivId) {\nif (sReaderDivId) {\nthis.ReaderDivId = sReaderDivId;\n} else {\nthis.ReaderDivId = '';\n}\nif (sRssUrl) {\nthis.RssUrl = sRssUrl;\n} else {\nthis.RssUrl = '';\n}\nif (sWaitDesc) {\nthis.WaitDesc = sWaitDesc;\n} else {\nthis.WaitDesc = '加载中……';\n}\nif (sWaitImageSrc) {\nthis.WaitImageSrc = sWaitImageSrc;\n} else {\nthis.WaitImageSrc = '<a href=\"http://www.myfootprints.cn/jsLib/ajaxtoolkit/wait.gif\">http://www.myfootprints.cn/jsLib/ajaxtoolkit/wait.gif</a>';\n}\nif (sAjaxStateDivId) {\nthis.AjaxStateDivId = sAjaxStateDivId;\n} else {\nthis.AjaxStateDivId = null;\n}\n// 以下为默认属性\n// 10条新闻\nthis.FeedCount = 10;\n// 处理XML文档的函数\nthis.Handler = mfRRA.handleFeedRequest;\n// 由于javascript的HTTP查询不能够跨越不同的服务器，需要配置一个服务器端的HTTP查询代理，在这里写上代理的服务器查询脚本的URL\nthis.ServerFeeder = 'newsfeeder.asp?rssurl=';\n// Request 对象\nthis.Request = null;\n// 计时器ID\nthis.TimeoutIds = null;\n}</p>\n<p>//\n// loadFeed 方法\n//\n// 用途：用来加载RSS内容\n//\nmfRSSReader.prototype.loadFeed = function() {\n// 清除上一次的源内容，同时显示加载中的提示信息\nvar oReaderDiv = document.getElementById(this.ReaderDivId);\nif (oReaderDiv) {\nvar oChilds = oReaderDiv.childNodes;\nfor (var i = oChilds.length - 1; i >= 0; i--) {\noReaderDiv.removeChild(oChilds[i]);\n}\nif (this.WaitImageSrc) {\nvar oImg = new Image();\noImg.src = this.WaitImageSrc;\nif (this.WaitDesc) {\noImg.alt = this.WaitDesc;\n} else {\noImg.alt = '加载中……';\n}\noReaderDiv.appendChild(oImg);\n} else if (this.WaitDesc) {\nvar oText = document.createTextNode(this.WaitDesc);\noReaderDiv.appendChild(oText);\n}\n} else {\nreturn;\n}\n// 发送 Ajax 请求加载新闻源内容\nvar oRSSReader = this;\nthis.ajaxSendRequest('GET', this.ServerFeeder + encodeURIComponent(this.RssUrl), function() { oRSSReader.Handler(oRSSReader); });\n};</p>\n<p>//\n// ajaxSendRequest() 方法\n//\n// 用途：发送HTTP请求\n//\nmfRSSReader.prototype.ajaxSendRequest = function(sType, sUrl, fnHandler, sPostDataType, vPostData) {\nif (this.Request == null) {\n// 创建一个新的 Request 对象\nthis.Request = this.createXMLHTTPRequest();\n} else {\n// 杀掉之前的 Request 对象\nthis.Request.abort();\n}</p>\n<pre><code>if (this.Request == null) {\n    throw new Error('Ajax 在创建 XMLHTTPRequest 对象时遇到错误。');\n} else {\n    try {\n</code></pre>\n<p>//            var sReaderDivId = this.ReaderDivId;\n//            var lFeedCount = this.FeedCount;\n//            var sAjaxStateDivId = this.AjaxStateDivId;\n//            var oRequest = this.Request;</p>\n<p>//            if (!fnHandler) {\n//                fnHandler = function() { mfRRA.handleFeedRequest(oRequest, sReaderDivId, lFeedCount, sAjaxStateDivId); };\n//            }\nthis.Request.onreadystatechange = fnHandler;\n// 总是异步 第三个参数设置为true\nthis.Request.open(sType, sUrl, true);\nif (sType.toLowerCase() == 'get') {\n// 发送一个GET请求，不涉及到数据\nthis.Request.send(null);\n} else {\n// 发送一个POST请求，最后一个参数是数据\nthis.Request.setRequestHeader('Content-Type', sPostDataType);\nthis.Request.send(vPostData);\n}\n} catch (oError) {\nthrow new Error('Ajax 在与服务器的通信中遇到错误。\\n' + '详情：' + oError);\n}\n}\n};</p>\n<p>//\n// createXMLHTTPRequest()方法\n//\n// 用途：创建一个新的Request对象\n//\nmfRSSReader.prototype.createXMLHTTPRequest = function() {\nif (typeof XMLHttpRequest == 'undefined' &#x26;&#x26; window.ActiveObject) {\nvar arrSignatures = [\"MSXML2.XMLHTTP.5.0\", \"XSXML2.XMLHTTP.4.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\"];\nfor (var i = 0; i &#x3C; arrSignatures.length; i++) {\ntry {\nvar oRequest = new ActiveXObject(arrSignatures[i]);\nreturn oRequest;\n} catch (oError) {\n//忽略\nreturn null;\n}\n}\n//throw new Error(\"MSXML 没有安装到你的系统中。\");\n} else if (window.XMLHttpRequest) {\ntry {\nvar oRequest = new XMLHttpRequest();\nreturn oRequest;\n} catch (oError) {\nreturn null;\n}</p>\n<pre><code>} else {\n    return null;\n}\n</code></pre>\n<p>};</p>\n<p>//\n// 隐藏Ajax状态信息\n// 如果给定lDelay参数，则启动计时器，否则不启动\n//\nmfRSSReader.prototype.toggleAjaxStateInfo = function(bShow, lDelay) {\nvar oStateElem = document.getElementById(this.AjaxStateDivId);</p>\n<pre><code>function toggleAjaxStateInfoTo() {\n    if (bShow) {\n        oStateElem.style.display = 'block';\n    } else {\n        oStateElem.style.display = 'none';\n    }\n}\nif (oStateElem) {\n    if (lDelay) {\n        if (this.TimeoutIds) {\n            this.TimeoutIds[this.TimeoutIds.length] = window.setTimeout(toggleAjaxStateInfoTo, lDelay);\n        } else {\n            this.TimeoutIds = window.setTimeout(toggleAjaxStateInfoTo, lDelay);\n        }\n    } else {\n        toggleAjaxStateInfoTo();\n    }\n}\n</code></pre>\n<p>};</p>\n<p>//\n// 清除计时器\n//\nmfRSSReader.prototype.clearHideAjaxStateInfoTimeout = function() {\nif (this.TimeoutIds) {\nfor (var i = this.TimeoutIds.length - 1; i >= 0; i--) {\nwindow.clearTimeout(this.TimeoutIds[i]);\nthis.TimeoutIds.splice(i, 1);\n}\n}\n};</p>\n<p>//\n// 更新Ajax状态\n//\n// 参数：\n//  oRequest(<em>), 更新哪个XMLHttpRequest对象的状态\n//  sAjaxStateDivId(</em>), 更新状态信息到HTML文档中ID为sAjaxStateDivId中\n//\nmfRSSReader.prototype.ajaxUpdateState = function() {\nvar oStateElem = document.getElementById(this.AjaxStateDivId);\nvar oRequest = this.Request;\nif (oStateElem) {\n// 修饰一下状态元素\noStateElem.style.fontSize = 'small';\noStateElem.style.border = '1px solid';\noStateElem.style.textAlign = 'center';\ntry {\nthis.clearHideAjaxStateInfoTimeout();\n} catch (oError) {\n} finally {\nthis.toggleAjaxStateInfo(true);\n}\nswitch (oRequest.readyState) {\n// UNITIALIZED - Request has not yet been opened<br>\ncase 0:\noStateElem.style.backgroundColor = \"#FFFFFF\"; // white\n//oStateElem.innerHTML = \"Request uninitialized.\";\noStateElem.innerHTML = \"查询没有启动。\";\nthis.toggleAjaxStateInfo(false, 2000);\nbreak;\n// LOADING - Request has not yet been sent<br>\ncase 1:\noStateElem.style.backgroundColor = \"#999999\"; // gray\n//oStateElem.innerHTML = \"Request initialized.\";\noStateElem.innerHTML = \"查询启动了。\";\nthis.toggleAjaxStateInfo(false, 2000);\nbreak;\n// LOADED - Request has been sent<br>\ncase 2:\noStateElem.style.backgroundColor = \"#FF0000\"; // red\n//oStateElem.innerHTML = \"Waiting for response...\";\noStateElem.innerHTML = \"等待响应……\";\nthis.toggleAjaxStateInfo(false, 2000);\nbreak;\n// INTERACTIVE - Response data is being downloaded<br>\ncase 3:\noStateElem.style.backgroundColor = \"#FFFF00\"; // yellow\n//oStateElem.innerHTML = \"Downloading response...\";\noStateElem.innerHTML = \"正在加载……\";\nthis.toggleAjaxStateInfo(false, 2000);\nbreak;\n// COMPLETE - Request/response is complete<br>\ncase 4:\nif (oRequest.status == 200) {\n// Everything is OK\noStateElem.style.backgroundColor = \"#00FF00\"; // green\n//oStateElem.innerHTML = \"Request complete!\";\noStateElem.innerHTML = \"查询完成！\";\nthis.toggleAjaxStateInfo(false, 2000);\n} else {\n// There was a problem\noStateElem.style.backgroundColor = \"#FF8800\"; // orange\n//oStateElem.innerHTML = \"Request failed!\";\noStateElem.innerHTML = \"查询失败！\";\n// 失败的信息不要隐藏\ntry {\nthis.clearHideAjaxStateInfoTimeout();\n} catch (oError) {\n} finally {\nthis.toggleAjaxStateInfo(true, 2000);\n}\n}\nbreak;\n}\n}\n};</p>\n<p>mfRSSReader.prototype.getText = function(oElem) {\n// 获取一个元素的内部文本\nvar sText = '';\nif (oElem != null) {\nif (oElem.childNodes) {\nfor (var i = 0; i &#x3C; oElem.childNodes.length; i++) {\nif (oElem.childNodes[i].nodeValue != null) {\nsText += oElem.childNodes[i].nodeValue;\n}\n}\n}\n}\nreturn sText;\n};</p>\n<p>// mfRSSReader 的助手，用来处理获取到的XML文档，你可以添加自定义的处理函数，并在调用mfRSSReader.loadFeed()方法前将 mfRSSReader.Handler 设置成为你自定义的处理函数\n// 设置方法如下：\n// var oRssReader = new mfRSSReader('rssreader', '<a href=\"http://www.myfootprints.cn/blog/rss.xml\">http://www.myfootprints.cn/blog/rss.xml</a>', '正在加载……', '<a href=\"http://www.myfootprints.cn/jsLib/ajaxtoolkit/wait.gif\">http://www.myfootprints.cn/jsLib/ajaxtoolkit/wait.gif</a>');\n// oRssReader.Handler = mfRRA.myHandleFeedRequest;\n//\nvar mfRSSReaderAssistant = new Object();\nvar mfRRA = mfRSSReaderAssistant;\n//\n// handleFeedRequest() 方法 - 默认\n//\n// 用途：获取到XML对象后的处理过程\n//\nmfRRA.handleFeedRequest = function(oRSSReader) {\nvar oRequest = oRSSReader.Request;\nif (oRequest.readyState == 4 &#x26;&#x26; oRequest.status == 200) {\n// 保存XML响应数据\nvar oXMLData = oRequest.responseXML;\n// 从源标题开始生成源内容\nvar sFeedContent = '';\nvar oChannelElem = oXMLData.getElementsByTagName('channel')[0];\nsFeedContent += '<div class=\"feedtitle\"><a href=\"' + oRSSReader.getText(oChannelElem.getElementsByTagName('link')[0]) + '\" target=\"_blank\" title=\"点击查看\">' + oRSSReader.getText(oChannelElem.getElementsByTagName('title')[0]) + '</a></div>';</p>\n<pre><code>    // 生成源条目组成的列表\n    sFeedContent += '&#x3C;ul>';\n    var oFeedItems = oChannelElem.getElementsByTagName('item');\n    var lFeedCount = oRSSReader.FeedCount;\n    if (lFeedCount == -1) {\n        lFeedCount = oFeedItems.length;\n    }\n    for (var i = 0; i &#x26;lt; (oFeedItems.length &#x26;lt; lFeedCount ? oFeedItems.length : lFeedCount); i++) {\n        var sItemTitle = oRSSReader.getText(oFeedItems[i].getElementsByTagName('title')[0]);\n        var sItemLink = oRSSReader.getText(oFeedItems[i].getElementsByTagName('link')[0]);\n        var sItemPubDate = oRSSReader.getText(oFeedItems[i].getElementsByTagName('pubDate')[0]);\n        if (sItemPubDate == '') {\n            sItemPubDate = oRSSReader.getText(oFeedItems[i].getElementsByTagName('date')[0]);\n        }\n        if (sItemPubDate == '') {\n            sFeedContent += '&#x3C;li>&#x3C;a href=\"' + sItemLink + '\" target=\"_blank\" title=\"点击查看\">' + sItemTitle + '&#x3C;/a>&#x3C;/li>';\n        } else {\n            var sItemPubDateString = sItemPubDate;\n            try {\n                var oDate = new Date(Date.parse(sItemPubDate));\n                sItemPubDate = oDate.getFullYear() + '-' + (oDate.getMonth() + 1) + '-' + oDate.getDay();\n            } catch (e) {\n                sItemPubDate = sItemPubDateString;\n            } finally {\n            }\n            sFeedContent += '&#x3C;li>&#x3C;a href=\"' + sItemLink + '\" target=\"_blank\" title=\"点击查看\">' + sItemTitle + '&#x3C;span class=\"itemdate\">(' + sItemPubDate + ')&#x3C;/span>&#x3C;/a>&#x3C;/li>';\n        }\n    }\n    sFeedContent += '&#x3C;/ul>';\n\n    // 显示源内容\n    document.getElementById(oRSSReader.ReaderDivId).innerHTML = sFeedContent;\n}        \n// 更新 Ajax 状态\nif (oRSSReader.AjaxStateDivId) {\n    oRSSReader.ajaxUpdateState();\n}\n</code></pre>\n<p>};</p>\n<p>//\n// handleFeedRequest_FullText_LikeGoogle() 方法 - 与默认的标题列表不同，这里将每篇新闻的全文显示出来，模仿Google Reader的样式\n//\n// 用途：获取到XML对象后的处理过程\n//\nmfRRA.handleFeedRequest_FullText_LikeGoogle = function(oRSSReader) {\nvar oRequest = oRSSReader.Request;\nif (oRequest.readyState == 4 &#x26;&#x26; oRequest.status == 200) {\n// 保存XML响应数据\nvar oXMLData = oRequest.responseXML;\n// 从源标题开始生成源内容\nvar sFeedContent = '';\nvar oChannelElem = oXMLData.getElementsByTagName('channel')[0];\nsFeedContent += '<div class=\"feedtitle\">' + oRSSReader.getText(oChannelElem.getElementsByTagName('title')[0]) + '<a href=\"' + oRSSReader.getText(oChannelElem.getElementsByTagName('link')[0]) + '\" target=\"_blank\" title=\"点击查看\"> »</a></div>';</p>\n<pre><code>    // 生成源条目组成的列表\n    sFeedContent += '&#x3C;div class=\"feedItems\">&#x3C;ul style=\"margin: 0; padding: 0; list-style-type: none;\">';\n    var oFeedItems = oChannelElem.getElementsByTagName('item');\n    var lFeedCount = oRSSReader.FeedCount;\n    if (lFeedCount == -1) {\n        lFeedCount = oFeedItems.length;\n    }\n    for (var i = 0; i &#x26;lt; (oFeedItems.length &#x26;lt; lFeedCount ? oFeedItems.length : lFeedCount); i++) {\n        var sItemTitle = oRSSReader.getText(oFeedItems[i].getElementsByTagName('title')[0]);\n        var sItemLink = oRSSReader.getText(oFeedItems[i].getElementsByTagName('link')[0]);\n        var sItemPubDate = oRSSReader.getText(oFeedItems[i].getElementsByTagName('pubDate')[0]);\n        if (sItemPubDate == '') {\n            sItemPubDate = oRSSReader.getText(oFeedItems[i].getElementsByTagName('date')[0]);\n        }\n\n        if (sItemPubDate == '') {\n            sFeedContent += '&#x3C;li>&#x3C;div class=\"feedItem\">&#x3C;div class=\"itemTitle\">&#x3C;a href=\"' + sItemLink + '\" target=\"_blank\" title=\"点击查看\">' + sItemTitle + '&#x3C;span class=\"itemTitleGo\">&#x3C;/span>&#x3C;/a>&#x3C;/div>';\n        } else {\n            var sItemPubDateString = sItemPubDate;\n            try {\n                var oDate = new Date(Date.parse(sItemPubDate));\n                sItemPubDate = oDate.getFullYear() + '-' + (oDate.getMonth() + 1) + '-' + oDate.getDay();\n            } catch (e) {\n                sItemPubDate = sItemPubDateString;\n            } finally {\n            }\n            sFeedContent += '&#x3C;/div>&#x3C;/li>&#x3C;li>&#x3C;div class=\"feedItem\">&#x3C;div class=\"itemTitle\">&#x3C;a href=\"' + sItemLink + '\" target=\"_blank\" title=\"点击查看\">' + sItemTitle + '&#x3C;span class=\"itemTitleGo\">&#x3C;/span>&#x3C;/a>&#x3C;span class=\"itemdate\">' + sItemPubDate + '&#x3C;/span>&#x3C;/div>';\n            \n        }\n        var sAuthor = oRSSReader.getText(oFeedItems[i].getElementsByTagName('author')[0]);\n        sFeedContent += '&#x3C;div class=\"itemAuthor\">由 ' + sAuthor + ' 发表&#x3C;/div>';\n        var sItemContent = oRSSReader.getText(oFeedItems[i].getElementsByTagName('description')[0]);\n        sFeedContent += '&#x3C;div class=\"itemDesc\">' + sItemContent + '&#x3C;/div>&#x3C;/div>&#x3C;/li>'\n    }\n    sFeedContent += '&#x3C;/ul>&#x3C;/div>';\n\n    // 显示源内容\n    document.getElementById(oRSSReader.ReaderDivId).innerHTML = sFeedContent;\n} \n// 更新 Ajax 状态\nif (oRSSReader.AjaxStateDivId) {\n    oRSSReader.ajaxUpdateState();\n}\n</code></pre>\n<p>};\n</pre></p>\n</li>\n</ol>\n</div>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[],"slicesMap":{}}