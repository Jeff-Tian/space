{"componentChunkName":"component---src-templates-post-js","path":"/posts/nry4dw","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/nry4dw","relativePath":"posts/nry4dw","frontmatter":{"title":"循环 vs 递归（反转链表示例）","stackbit_url_path":"posts/nry4dw","date":"2021-03-09T12:04:49","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>在昨天的文章中提到，循环是一个正向线性思维，但是递归确实一种一种为始的反向思维。多数人习惯与正向思维，因为反向思维实际上有点儿反本能的，但是往往反向思维却能很好地解决一些看上去复杂正向思维难以解决的问题，比如汉诺塔问题。</p>\n<p>今天以一个常见的算法面试题，来对比循环和递归在代码上的差别，以及为什么更推荐递归的写法以简化代码。这个常见的算法面试题，就是反转链表（<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a>）。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1615287608904-e816e6d1-6171-4e95-b935-f3b4ba903f32.png#align=left&#x26;display=inline&#x26;height=782&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=782&#x26;originWidth=1190&#x26;size=100470&#x26;status=done&#x26;style=none&#x26;width=1190\" alt=\"image.png\">\n<a name=fzzvb></a></p>\n<h2>准备工作</h2>\n<p>为了方便起见，可以打开浏览器，F12 进入开发控制台，使用 JavaScript 来实现和验证。首先写一些帮助函数来方便自动化测试：\njavascript\nfunction test(expect, sut, message) {\nconsole.log(message)</p>\n<p>let sutString = linkToArray(sut).join(->);\nlet actual = reverseLink(sut);\nlet left = linkToArray(expect).join(->);\nlet right = linkToArray(actual).join(->);</p>\n<p>if(left === right){\nconsole.log(tt + left +  == revert( + sutString + ): PASS);\n} else {\nconsole.error(tt + left +  == revert( + sutString + ): FAIL);\n}\n}</p>\n<p>function linkToArray(head){\nconst res = [];\nlet set = new Set();</p>\n<p>while(head) {\nif(set.has(head)) {\nres.push(loop!);\nreturn res;\n}</p>\n<pre><code>res.push(head.val);    \nset.add(head);\nhead = head.next;\n</code></pre>\n<p>}</p>\n<p>return res;\n}</p>\n<p>然后，将设计好的测试用例列出来：\njavascript\n// 测试用例：\ntest(null, reverseLink(null), 测试 null)</p>\n<p>let headA = {val: 1, next: null}\ntest(headA, (headA), 测试一个节点)</p>\n<p>headA.next = {val: 2, next: null};\nlet reversed = {val: 2, next: {val: 1, next: null}}\ntest(reversed, (headA), 测试两个节点);</p>\n<p>headA = {val: 1, next: {val: 2, next: {val: 3, next: null }}}\nreversed = {val: 3, next: {val: 2, next: {val: 1, next: null }}}\ntest(reversed, (headA), 测试三个节点);</p>\n<p>let cycle = {val: 1, next: null}\ncycle.next = cycle;</p>\n<p>test(cycle, (cycle), 测试指向自己的一个节点的循环链表);\nconsole.assert(linkToArray(cycle).join(->) === 1->loop!, cycle);</p>\n<p>let next = {val: 2, next: null};\ncycle.next = next;\nnext.next = cycle;</p>\n<p>test(next, (cycle), 测试两个互相指向的节点组成的循环链表);\nconsole.assert(linkToArray(cycle).join(->) === 1->2->loop!, cycle);</p>\n<p>next = {val: 3, next:null};\ncycle = {val: 1, next: {val: 2, next: next}}\nnext.next = cycle;</p>\n<p>test(next, (cycle), 测试由三个节点组成的循环链表);</p>\n<p><a name=5XMQq></a></p>\n<h2>循环实现</h2>\n<p>比较容易想到的方案就是从头开始循环，每次对前后节点的指针进行倒转。在实现过程中，会发现指针的倒转，需要特别注意。\njavascript\n// 假设不存在重复节点\nfunction reverseLink(head) {\nif(head === null) {\nreturn head;\n}</p>\n<p>let prev = head;</p>\n<p>let next = prev.next;\nprev.next = null;</p>\n<p>while(prev &#x26;&#x26; next) {\nlet temp = next.next;\nnext.next = prev;\nprev = next;\nnext = temp;</p>\n<pre><code>if(next === head) {\n  head.next = prev;\n  return prev;\n}\n</code></pre>\n<p>}</p>\n<p>return prev;\n}</p>\n<p>注意以上 while 循环体中，开头 4 行的顺序特别重要！顺序错误就会导致程序 BUG。将以上实现和测试用例在开发者控制面板中运行，测试全部通过：</p>\n<p><a name=eYKss></a></p>\n<h2>递归实现</h2>\n<p>递归实现的关键在于思考方式，你要设想一个小一点的问题，已经被解决了。在这里，可以设想除了头节点，从下一个节点开始到末尾的子链表已经被反转了，这时候，只需要将关注点放在如何将头节点放置到子链表的末尾，这样就实现了整个链表的反转：</p>\n<p>javascript\n/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>function ListNode(val) {</li>\n<li>\n<pre><code>this.val = val;\n</code></pre>\n</li>\n<li>\n<pre><code>this.next = null;\n</code></pre>\n</li>\n<li>}</li>\n</ul>\n<p><em>/\n/</em>*</p>\n<ul>\n<li>@param {ListNode} head</li>\n<li>@return {ListNode}</li>\n</ul>\n<p>*/\nvar reverseList = function(head) {\nif(!head){\nreturn null;\n}</p>\n<pre><code>if(head.next === null){\n    return head;\n}\n\nconst rev = reverseList(head.next);\nhead.next.next = head;\nhead.next = null;\n\nreturn rev;\n</code></pre>\n<p>};</p>\n<p>可以看出，除了一些边界检查和循环类似之外，主要逻辑简单了很多！将头节点放置在已经被反转的子链表之后，这个逻辑很自然，因此代码上没有需要特别注意的地方。这个实现和测试结果可以参见：<a href=\"https://leetcode-cn.com/submissions/detail/43900191/\">https://leetcode-cn.com/submissions/detail/43900191/</a></p>\n<p>但是要注意的是，在循环实现中，支持了环链表（参见后面的测试用例）。如果要让递归实现也支持环链表，需要再做一些改进：<br />\njavascript\nvar reverseList = function(head) {\nreturn ((head, cycleStart) {\nif(!head){\nreturn null;\n}</p>\n<pre><code>if(head.next === null || head.next === head){\n    return head;\n}\n\nif (head.next === cycleStart) {\n  return head;\n}\n\nconst rev = reverseList(head.next, cycleStart);\nhead.next.next = head;\n\nif(!cycleStart) {\n\thead.next = null;\n} else {\n  head.next = rev;\n}\n\nreturn rev;\n</code></pre>\n<p>})(head, head);\n};</p>\n<p><a name=fjU7L></a></p>\n<h2>彩蛋</h2>\n<p>递归方式会导致一个问题，相同的操作会做很多次。有一个简单粗暴的改进方案，就是使用空间换时间，不需要改动实现代码，只要使用前面文章中介绍过的 memoized 将其包装起来即可。\njavascript\nconst reverseList = memoized(\n(head) => {\nreturn ((head, cycleStart) {\nif(!head){\nreturn null;\n}</p>\n<pre><code>  if(head.next === null || head.next === head){\n      return head;\n  }\n\n  if (head.next === cycleStart) {\n    return head;\n  }\n\n  const rev = reverseList(head.next, cycleStart);\n  head.next.next = head;\n\n  if(!cycleStart) {\n    head.next = null;\n  } else {\n    head.next = rev;\n  }\n\n  return rev;\n})(head, head);\n</code></pre>\n<p>}\n);</p>\n<p>完整的代码和测试见：<a href=\"https://github.com/Jeff-Tian/JobInterviewTests/blob/dev/ByteDance/src/reverseList.ts\">https://github.com/Jeff-Tian/JobInterviewTests/blob/dev/ByteDance/src/reverseList.ts</a>。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}