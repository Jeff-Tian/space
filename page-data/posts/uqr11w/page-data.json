{"componentChunkName":"component---src-templates-post-js","path":"/posts/uqr11w","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/uqr11w","relativePath":"posts/uqr11w","frontmatter":{"title":"闭包的妙用，再次以 memoize 举例","stackbit_url_path":"posts/uqr11w","date":"2021-11-29T12:27:25","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>在《<a href=\"https://zhuanlan.zhihu.com/p/353365352\">闭包的妙用 —— memoize</a>》一文中，以 memoize 为例，讲述了一个具体的闭包应用场景。最精彩的是，在文章最后，实现了 memoized 以完全避开心智负担。</p>\n<p>但是，在实际工作中，经常碰到  async 场景，以及实际工程是用的 TypeScript 语言。那么今天再谈一谈 TypeScript 工程中使用 async memoize 的实例。</p>\n<p><a name=gzy74></a></p>\n<h1>重复请求</h1>\n<p>这是一个很常见的前端问题，每换一个团队，总能遇到相同的问题，解决办法也一样，今天记录下来，希望给到没有经验的前端团队以参考，不要再重蹈覆辙。</p>\n<p>这个常见问题就是，前端在做登录流程控制时，一般逻辑是这样：</p>\n<ul>\n<li>先发出一个请求，比如请求个人信息</li>\n<li>由于未登录，或者登录已经过期，服务器端返回了 403</li>\n<li>前端有个响应的通用错误处理，看到 403，就发出登录请求</li>\n</ul>\n<p>这个逻辑很正确甚至优雅，但是没有考虑到并发。在并发场景下，多个请求收到 403，就会触发多次登录请求，造成不必要的流量和延时浪费。</p>\n<p>以下是一个微信小程序前端的重复请求截图，它从微信获取 code，然后发请求去换取 session（这个例子用了 GraphQL，请求名为 loginWechat）。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1638187712927-3d71d038-31d9-4c2f-915d-86331c7af10e.png#clientId=u74b205b1-4a03-4&#x26;crop=0.399&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=170&#x26;id=u55aba827&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=566&#x26;originWidth=1193&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=644023&#x26;status=done&#x26;style=none&#x26;taskId=ufc14ea53-b5de-4270-bb51-7dc2973b247&#x26;title=&#x26;width=359\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1638187753453-4ec79774-c03a-43ec-b8b1-707c6682f37a.png#clientId=u74b205b1-4a03-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=249&#x26;id=ub8efbcaf&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=497&#x26;originWidth=764&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=113261&#x26;status=done&#x26;style=none&#x26;taskId=u538e9f7e-4ccd-45ce-8218-9375ac4d738&#x26;title=&#x26;width=382\" alt=\"image.png\"></p>\n<p><a name=Haeho></a></p>\n<h1>先用测试重现这个问题</h1>\n<p>typescript\ndescribe(login, () => {\nbeforeEach(() => {\njest.clearAllMocks()\n})</p>\n<p>it(should login wechat once without duplicate requests, async () => {\nconst mockLoginResult = { jwt: 1234, sessionId: 5678 }</p>\n<pre><code>client.loginMutate.mockImplementation(async () => mockLoginResult)\n\n// 连接调用两次登录处理 （实际代码就是在 403 后调用 handleLogin ）\nawait Promise.all([auth.handleLogin(), auth.handleLogin()])\n\nexpect(storageSync.getStorageSync(StorageSyncKeys.TOKEN)).toStrictEqual(mockLoginResult.jwt)\n\n// 直接运行测试会导致失败，因为这个 loginMutate 会被调用两次（发出两个请求）\nexpect(client.loginMutate).toHaveBeenCalledTimes(1)\n</code></pre>\n<p>})\n})</p>\n<p>handleLogin 函数执行了一系列步骤，主要就是发出请求，拿到 token，保存到 storage。</p>\n<p>typescript</p>\n<p>export const handleLogin = () =>\nlogin()\n.then(() => {\ninitialUserStatus()\n})\n.catch(() => {\nresetAuthInfo()\nmessager.error(微信登录授权出错)\n})</p>\n<p>export const login = (): Promise<boolean> => {\nAuthorizeStore.setIsGetNewToken(false)\nreturn new Promise(async (resolve, reject) => {\ntry {\nconst { code } = await Taro.login()\nconst loginInfo = await loginWechat(code)\nAuthorizeStore.setIsGetNewToken(true)\nsetTokenSync(loginInfo?.jwt)\nresolve(true)\n} catch (err) {\nAuthorizeStore.setIsGetNewToken(false)\nreject(false)\n}\n})\n}</p>\n<p>以上是原来的代码，要修复，很简单，只需要把 login 使用 memoize 封装一下就好，但是这里使用了 async，不如把这个记忆函数叫做 memoizeAsync。</p>\n<p>diff</p>\n<ul>\n<li>export const login = (): Promise<boolean> => {</li>\n</ul>\n<ul>\n<li>export const loginWithNewCode = (): Promise<boolean> => {\nAuthorizeStore.setIsGetNewToken(false)\nreturn new Promise(async (resolve, reject) => {\ntry {\nconst { code } = await Taro.login()\nconst loginInfo = await loginWechat(code)\nAuthorizeStore.setIsGetNewToken(true)\nsetTokenSync(loginInfo?.jwt)\nresolve(true)\n} catch (err) {\nAuthorizeStore.setIsGetNewToken(false)\nreject(false)\n}\n})</li>\n</ul>\n<p>}</p>\n<ul>\n<li>export const login = memoizeAsync(loginWithNewCode)</li>\n</ul>\n<p>这里引入了 memoizeAsync，实现它之前，写个测试吧！</p>\n<p><a name=U9okx></a></p>\n<h1>再用测试文档化新引入的函数的功能</h1>\n<p>typescript</p>\n<p>describe(memoize, () => {\nit(executes only once, async () => {\nconst originalExecute = jest.fn().mockImplementation(async () => {\nconsole.log(executing...)\n})\n// Given an async function memoized\nconst memoizedExecute = memoizeAsync(originalExecute)</p>\n<pre><code>  const sut = {\n    execute: memoizedExecute,\n  }\n\n  // When call it multiple times\n  await Promise.all([sut.execute(), sut.execute(), sut.execute()])\n\n  // Then the underlying method will be run only once\n  expect(originalExecute).toHaveBeenCalledTimes(1)\n})\n</code></pre>\n<p>})</p>\n<p><a name=wkOfl></a></p>\n<h1>memoizeAsync 的实现</h1>\n<p>typescript</p>\n<p>export const memoizeAsync = <T>(func: (...args) => Promise<T>) => {\nconst cache = {}</p>\n<p>return async (...args) => {\nconst argStr = JSON.stringify(args)\nconst cacheKey = ${func.toString()}\n${argStr}</p>\n<pre><code>if (cache[cacheKey] !== undefined) {\n  cache[cacheKey] = cache[cacheKey]\n} else {\n  cache[cacheKey] = func(...args)\n}\n\nreturn cache[cacheKey]\n</code></pre>\n<p>}\n}</p>\n<p>非常平凡，在返回新的函数前，定义了一个 cache 变量，虽然它对外界不可见，但是每次调用返回的新函数，都会间接引用到它。</p>\n<p>再复习一遍：闭包就是一个特殊的高阶函数，在返回的新函数里引用了原函数里的局部变量。</p>\n<p>在这个函数实现后，不仅文档测试跑过了，原来重现的问题也修好了。</p>\n<p><a name=l7aah></a></p>\n<h1>总结</h1>\n<p>以 TypeScript 项目为例，再次复习了闭包以及 memoize，并且展示了 TDD 的开发和修 BUG 的大致姿势。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}