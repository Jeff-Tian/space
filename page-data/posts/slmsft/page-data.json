{"componentChunkName":"component---src-templates-post-js","path":"/posts/slmsft","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/slmsft","relativePath":"posts/slmsft","frontmatter":{"title":"打桩与模拟的区别（以 http client 为例）","stackbit_url_path":"posts/slmsft","date":"2021-06-04T05:32:12","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=JQdWI></a></p>\n<h1>缘起</h1>\n<p>最初是从专业的 TDD 群里得知在测试中还有打桩与模拟的区别，我之前只有一个笼统的概念，当需要控制被依赖方的某些操作的返回结果时（比如调用数据库的保存操作，我希望它在测试中返回一个固定的成功结果；或者调用 rpc 服务，得到某个固定的 json），就需要 mock 这个被依赖方。至于这个 mock，到底是 mock（模拟） 还是 stub（打桩），没有深究。</p>\n<p>后来一看 Martin Fowler 的文章，居然对这个我头脑中笼统的 mock，细分了 4 种不同的情况！当然，我并没有看懂，但是在实践中，的确明显感受到了 2 种 mock 的细微区别，这两种，就是 Martin Fowler 所说的打桩和模拟，也就是最早从 TDD 群里得知的这两种 mock。</p>\n<p>比如，当被测对象以来第三方服务，需要使用 http client 调用第三方服务时，在测试中希望固定第三方服务的返回结果，然后测试被测对象的行为。这个时候，就有两种策略，第一是把这个 http client 替换成一个假的 client，拥有和真实 http client 相同的方法，但是这个假对象的对应方法，会立即返回固定的结果。第二是不替换这个 http client，而是利用某些神奇的工具，对目标 url 进行监听，一看到 http client 发了请求到这个 url，立即给到 http client 一个固定返回结果。在我看来，第一个方法是打桩，第二个方法是模拟。</p>\n<p>举个例子，你的待测试对象，依赖第三方接口（比如需要调用微信的 api 以获取临时二维码的链接），你的服务需要从微信的接口返回的原始 json 里解析出这个图片地址，在测试中你需要一个固定的原始 json 返回值，通过打桩的方式就是替换发起 http 请求的 client，比如像这样\ntypescript\ntest(extract qrcode image url, async () => {\nclass MockHttpClient extends HttpClient {\nrequest: () => ({the: fixed json})\n...\n}</p>\n<pre><code>const mpService = new MpService(new MockHttpClient())\n</code></pre>\n<p>const res = await mpService.getQrCodeImage()\nexpect(res).toBe(<a href=\"https://qr.url\">https://qr.url</a>)\n})</p>\n<p>而通过模拟的方式，则可以引用 nock 这个库，代码如同这样：\ntypescript\nimport nock from nock</p>\n<p>test(extract qrcode image url, async () => {\nnock(<a href=\"https://api.weixin.qq.com).post(/qr-code).reply(200\">https://api.weixin.qq.com).post(/qr-code).reply(200</a>, {the: fixed json})</p>\n<pre><code>const mpService = new MpService(new RealHttpClient())\n</code></pre>\n<p>const res = await mpService.getQrCodeImage()\nexpect(res).toBe(<a href=\"https://qr.url\">https://qr.url</a>)\n})</p>\n<p>打桩似乎比较土，只要自己写个假的对象，并实现相应的方法即可。模拟比较高级是因为往往需要借助第三方工具，从而不需要自己写假对象，只需要写假的返回结果就行。从实际操作层面看，打桩要写很多代码，但是模拟代码量比较少（其实原因是引入了第三方工具，如果自己实现模拟，需要比打桩更多的代码量）。而打桩也并非只能自己写假对象，也可以引用第三方工具，比如 ts-mockery 就可以帮你完成写模拟对象的事情，你只需要写一下关注的方法的假的实现：\ntypescript\nimport { Mock } from ts-mockery</p>\n<p>test(extract qrcode image url, async () => {\nconst mockHttpClient = Mock.of<RealHttpClient>({request: () => ({the: fixed json})})</p>\n<pre><code>const mpService = new MpService(mockHttpClient())\n</code></pre>\n<p>const res = await mpService.getQrCodeImage()\nexpect(res).toBe(<a href=\"https://qr.url\">https://qr.url</a>)\n})</p>\n<p><strong>从这个库的使用来看，名字叫 mock，而实际做的是打桩，所以说，打桩和模拟的区别，很多人都没有注意到。</strong></p>\n<p>为什么模拟方式可以使用真正的依赖，而改变其行为？我并没有去看 nock 的实现代码，但是它一定也是替换了某些真正对象的，比如对于发送 http 请求来说，很可能在底层有一个全局的对象来做这件事情，我们通常使用的 http client 比如 axios 等，最终还是依赖了这个全局对象，而 nock 就是替换了这个全局对象，从而在测试中，真实 http client 的逻辑也会被走到。（纯属臆测，经不起考证）</p>\n<p><a name=tBfT0></a></p>\n<h1>太长不看</h1>\n<p>以我目前粗浅的理解，打桩和模拟有这些区别：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><strong>打桩</strong></th>\n<th><strong>模拟</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>调用深度</strong></td>\n<td>浅<br /><br />被依赖方的方法调用整个被替换了，因此原来的被依赖对象的方法逻辑完全没有被走到</td>\n<td>深<br /><br />被依赖的真正对象没有完全被替换，因此部分逻辑还是会走到，只有某些关键部位被替换。</td>\n</tr>\n<tr>\n<td><strong>介入的接触点</strong></td>\n<td>表面</td>\n<td>深层</td>\n</tr>\n<tr>\n<td><strong>以依赖 http client 的待测对象举例说明</strong></td>\n<td>替换 http client</td>\n<td>替换 http server</td>\n</tr>\n<tr>\n<td><strong>测试纯度</strong></td>\n<td>更纯<br /><br />因为只执行待测对象的代码，而替身代码往往很简单</td>\n<td>不纯<br /><br />还会走真正的依赖部分的逻辑</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>单元测试</td>\n<td>端到端测试</td>\n</tr>\n</tbody>\n</table>\n<p><a name=Y6eeq></a></p>\n<h1></h1>\n<p><a name=oSq4Y></a></p>\n<h1>且看 Martin Fowler 的说明</h1>\n<p>对于假对象来说，存在多个定义，一般的术语叫测试替身。这个术语包含了：dummy（木偶）、fake（伪造）、stub（打桩）、mock（模拟）。可见说了半天，我也才仅仅体会到了最后两种测试替身的区别，对于 dummy 和 fake，目前没有感知。据 Martin Fowler 说：</p>\n<blockquote>\n<ul>\n<li>木偶对象被传来传去但是根本不会被真正使用到。它们通常只是用来填塞参数列表</li>\n<li>伪造对象实际上是有能够工作的实现，但通常会走捷径从而并不适合生产环境（比如内存数据库就是个很好的例子）</li>\n<li>打桩提供了测试中调用时所对应的响应返回值，通常对于测试目的之外的逻辑根本不进行响应。打桩还可能被用来记录调用的信息，比如一个邮件网关打桩会记住它“发送”的信息，或者是它“发送”的信息的计数。这里的“发送”打了引号，因为对于打桩来说，根本不用真正发送。</li>\n<li>模拟是事先写好的期待的调用规格说明。</li>\n</ul>\n</blockquote>\n<p>也有人说，打桩是一个简单的伪造对象，只是为了让测试能够顺畅运行；而模拟则是一个更加智能的打桩，你可以验证测试代码通过了它的内部。</p>\n<p>我没有感知到前两种测试替身，可能与使用的语言有关系。在 NodeJs 世界，我可以随时给参数列表一些任意的原始值，或者自由对象，所以没有意识到他们是木偶。</p>\n<p><a name=XDt9s></a></p>\n<h1>再次拿 http client 举个例子</h1>\n<p>最近学习 Java，正在尝试用 Java 把自己以前用 NodeJs 实现过的东西再重新实现一遍。这里用 Java 把上面的 NodeJs 例子重新说明一遍，以消除自己对于 Java 的恐惧。</p>\n<p><a name=Xphum></a></p>\n<h2>任务</h2>\n<p>测试 MpService 类中的 getMpQrCode 方法。</p>\n<p>这个 MpService 类，就是利用 Http Client 发送请求给微信 API，然后封装一个 MpQR 对象返回。这个 MpQR 大致长这样：\njava\npublic class MpQR {\n@JsonProperty(expire_seconds)\nprivate Long expireSeconds;</p>\n<p>@JsonProperty(imageUrl)\nprivate String imageUrl;</p>\n<p>@JsonProperty(sceneId)\nprivate String sceneId;</p>\n<p>@JsonProperty(ticket)\nprivate String ticket;</p>\n<p>@JsonProperty(url)\nprivate String url;\n}</p>\n<p>这个 MpService 类，在请求微信 API 碰到异常时，会封装一个 Fallback 的 MpQR 类：\njava\npublic MpQR getMpQrCode() {\nURI uri = URI.create(this.qrCodeCreateUrl);\nHttpRequest request = HttpRequest.newBuilder().POST(HttpRequest.BodyPublishers.ofString()).uri(uri).build();</p>\n<pre><code>try {\n    HttpResponse&#x3C;String> response = this.httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    WeixinTicketResponse ticketResponse = new Gson().fromJson(response.body(), WeixinTicketResponse.class);\n    ...\n    return new MpQR().ticket(ticketResponse.ticket).imageUrl(ticketResponse.url).expireSeconds(ticketResponse.expiresInSeconds).url(ticketResponse.url);\n    } catch (InterruptedException ie){\n    return new MpQR().ticket(interrupted).imageUrl(Constants.FALLBACK_QR_URL);\n} catch (Exception ex) {\n    return new MpQR().ticket(error).imageUrl(Constants.FALLBACK_QR_URL);\n}\n</code></pre>\n<p>}</p>\n<p><a name=MuPAG></a></p>\n<h2>使用土办法打桩的方式</h2>\n<p>测试 MpService 类的正常路径（API 请求正常返回）</p>\n<p>自己写个土的 MockHttpClient （好吧，还是叫了 mock 的名字，但是实际上它是用来打桩的）：\njava\npublic class MockHttpClient extends HttpClient {\n@Override\npublic Optional<CookieHandler> cookieHandler() {\nreturn Optional.empty();\n}</p>\n<pre><code>@Override\npublic Optional&#x3C;Duration> connectTimeout() {\n    return Optional.empty();\n}\n\n@Override\npublic Redirect followRedirects() {\n    return null;\n}\n\n@Override\npublic Optional&#x3C;ProxySelector> proxy() {\n    return Optional.empty();\n}\n\n@Override\npublic SSLContext sslContext() {\n    return null;\n}\n\n@Override\npublic SSLParameters sslParameters() {\n    return null;\n}\n\n@Override\npublic Optional&#x3C;Authenticator> authenticator() {\n    return Optional.empty();\n}\n\n@Override\npublic Version version() {\n    return null;\n}\n\n@Override\npublic Optional&#x3C;Executor> executor() {\n    return Optional.empty();\n}\n\n@Override\npublic &#x3C;T> HttpResponse&#x3C;T> send(HttpRequest request, HttpResponse.BodyHandler&#x3C;T> responseBodyHandler) throws IOException, InterruptedException {\n    return new HttpResponse&#x3C;T>() {\n        @Override\n        public int statusCode() {\n            return 200;\n        }\n\n        @Override\n        public HttpRequest request() {\n            return null;\n        }\n\n        @Override\n        public Optional&#x3C;HttpResponse&#x3C;T>> previousResponse() {\n            return Optional.empty();\n        }\n\n        @Override\n        public HttpHeaders headers() {\n            return null;\n        }\n\n        @Override\n        public T body() {\n            return (T) {ticket:gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmmn3sUw==,expire_seconds:60,url:http://weixin.qq.com/q/kZgfwMTm72WWPkovabbI};\n        }\n\n        @Override\n        public Optional&#x3C;SSLSession> sslSession() {\n            return Optional.empty();\n        }\n\n        @Override\n        public URI uri() {\n            return null;\n        }\n\n        @Override\n        public Version version() {\n            return null;\n        }\n    };\n}\n\n@Override\npublic &#x3C;T> CompletableFuture&#x3C;HttpResponse&#x3C;T>> sendAsync(HttpRequest request, HttpResponse.BodyHandler&#x3C;T> responseBodyHandler) {\n    return null;\n}\n\n@Override\npublic &#x3C;T> CompletableFuture&#x3C;HttpResponse&#x3C;T>> sendAsync(HttpRequest request, HttpResponse.BodyHandler&#x3C;T> responseBodyHandler, HttpResponse.PushPromiseHandler&#x3C;T> pushPromiseHandler) {\n    return null;\n}\n</code></pre>\n<p>}</p>\n<p>这真是麻烦，只想返回假的 json，结果要写一大段代码（尽管多数是 IDE 帮忙生成的）。</p>\n<p>然后就可以这样来写测试：\njava\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)\npublic class MpServiceTest {\nprivate MpService mpService = new MpService(new MockHttpClient());</p>\n<pre><code>@Test\nvoid testGetMpQrCode() {\n    MpQR mpQR = mpService.getMpQrCode();\n    assertThat(mpQR.getTicket()).isEqualTo(gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmm);\n}\n</code></pre>\n<p>}</p>\n<p><a name=hRPC0></a></p>\n<h2></h2>\n<p><a name=CfVx3></a></p>\n<h2>使用 Mockito 打桩</h2>\n<p>使用上面那种手写打桩对象的方式不灵活，当要测试异常场景时，又得新写一个打桩对象，仅仅在 send 方法的实现有所差别：直接抛出错误。如果采用第三方库，就会灵活很多，比如 mockito。以上的测试完全可以使用 mockito 来做，由于不需要手写打桩对象，代码量少很多。主要利用了 @Mock 注解。\njava\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)\npublic class MpServiceTest {\nprivate MpService mpService;</p>\n<pre><code>@Mock\nprivate HttpClient mockHttpClient;\n\n@BeforeEach\nvoid setup() {\n    MockitoAnnotations.initMocks(MpServiceTest.class);\n}\n \n@Test\nvoid testGetMpQrCode() {\n</code></pre>\n<p>when(mockHttpClient.send(any(), any())).thenReturn(new HttpResponse<Object>() {\n@Override\npublic int statusCode() {\nreturn 0;\n}</p>\n<pre><code>        @Override\n        public HttpRequest request() {\n            return null;\n        }\n\n        @Override\n        public Optional&#x3C;HttpResponse&#x3C;Object>> previousResponse() {\n            return Optional.empty();\n        }\n\n        @Override\n        public HttpHeaders headers() {\n            return null;\n        }\n\n        @Override\n        public Object body() {\n            return {ticket:gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmmn3sUw==,expire_seconds:60,url:http://weixin.qq.com/q/kZgfwMTm72WWPkovabbI};\n        }\n\n        @Override\n        public Optional&#x3C;SSLSession> sslSession() {\n            return Optional.empty();\n        }\n\n        @Override\n        public URI uri() {\n            return null;\n        }\n\n        @Override\n        public HttpClient.Version version() {\n            return null;\n        }\n    });        \n\n    mpService = new MpService(mockHttpClient);\n    MpQR mpQR = mpService.getMpQrCode();\n    assertThat(mpQR.getTicket()).isEqualTo(gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmm);\n}\n</code></pre>\n<p>如果现在需要加一个测试异常的用例，就非常简单：\njava\n@Test\nvoid testGetMpQrCodeMetInterruptedException() throws IOException, InterruptedException {\nwhen(mockHttpClient.send(any(), any())).thenThrow(new InterruptedException(Test Exception));</p>\n<pre><code>mpService = new MpService(mockHttpClient);\nMpQR mpQR = mpService.getMpQrCode();\nassertThat(mpQR.getTicket()).isEqualTo(interrupted);\n</code></pre>\n<p>}</p>\n<p><a name=wIeNj></a></p>\n<h2></h2>\n<p><a name=yKfhh></a></p>\n<h2>如何采用模拟的方式来写这样的测试？</h2>\n<p>采用模拟的方式来实现这些测试用例，就需要使用真实的 http client，那么要被替换的内容就得往后靠。在 NodeJs 中，可以使用 nock ，直接 nock(<a href=\"https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKEN\">https://api.weixin.qq.com</a>)。但是在 Java 的世界里，我没有找到对等的工具。于是似乎得把微信 API 的域名，抽象出来，在测试时，灌入一个 localhost，然后在 localhost 启动一个模拟的服务，让其返回期待的 json。这种方式，搜一搜，可以找到 MockWebServer 的方法。</p>\n<p>这里给出第一个测试用例的 MockWebServer 实现\njava\nimport okhttp3.mockwebserver.MockResponse;\nimport okhttp3.mockwebserver.MockWebServer;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.core.env.Environment;\nimport org.springframework.test.context.junit4.SpringRunner;</p>\n<p>import java.io.IOException;</p>\n<p>import static org.assertj.core.api.Assertions.assertThat;</p>\n<p>@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.None)\npublic class WechatMpApiControllerTest {\npublic static MockWebServer mockBackEnd;</p>\n<pre><code>@BeforeAll\nstatic void setUp() throws IOException {\n    mockBackEnd = new MockWebServer();\n    mockBackEnd.start();\n}\n\n@AfterAll\nstatic void tearDown() throws IOException {\n    mockBackEnd.shutdown();\n}\n\n@BeforeEach\nvoid initialize() {\n    String baseUrl = String.format(http://localhost:%s,\n            mockBackEnd.getPort());\n\n    mpService.setQrCodeCreateUrl(baseUrl + /test);\n}\n\nprivate MpService mpService;\n\n@Test\nvoid testMpUrlHappyPath() {\n    MockResponse mockResponse = new MockResponse();\n    mockResponse.setBody({ticket:gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmmn +\n            3sUw==,expire_seconds:60,url:http://weixin.qq.com/q/kZgfwMTm72WWPkovabbI});\n    mockResponse.addHeader(Content-Type, application/json);\n    assertThat(mockBackEnd.getRequestCount()).isEqualTo(0);\n    mockBackEnd.enqueue(mockResponse);\n\n    mpService = new MpService();\n    MpQR mpQR = mpService.getMpQrCode();\n    assertThat(mpQR.getTicket()).isEqualTo(gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmm);\n    \n    assertThat(mockBackEnd.getRequestCount()).isEqualTo(1);\n}\n</code></pre>\n<p>}</p>\n<p><a name=D9bnV></a></p>\n<h1>总结</h1>\n<p>对于打桩和模拟，我有个粗浅的理解，不知道对不对。举例来说明：</p>\n<p>对于依赖 http client 的待测试对象，要测试它，不是替换 http client 本身，就是要替换它背后的 http server。通过替换 http client 本身来测试，就是打桩测试；通过替换背后的 http server，就是模拟测试。打桩测试似乎更纯粹，因为只测试待测对象的逻辑，将依赖替换成简单的立刻反弹对象，从而避免代码走得过深，可能更适合单元测试。而模拟测试，则使用了真实的 http client，可能更适合端到端集成测试。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622786127716-655ae3fb-a4fa-4650-8030-d1c99dc5b490.png#height=321&#x26;id=rN5Wm&#x26;margin=%5Bobject%20Object%5D&#x26;name=Untitled%20Diagram.png&#x26;originHeight=321&#x26;originWidth=561&#x26;originalType=binary&#x26;size=51482&#x26;status=done&#x26;style=none&#x26;width=561\" alt=\"Untitled Diagram.png\"></p>\n<p>还有个偏题的小感悟：写 java 果然很累，原因是为了满足静态类型的要求，不得不写很多填充型的代码。当然 Mockito 可以缓解，IDE 的自动填充也可以缓解，但是仍然有点累！</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}