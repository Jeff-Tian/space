{"componentChunkName":"component---src-templates-post-js","path":"/posts/giuoee","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/giuoee","relativePath":"posts/giuoee","frontmatter":{"title":"做纯洁的人，写纯洁的代码","stackbit_url_path":"posts/giuoee","date":"2021-02-18T12:16:03","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>一个函数，如果不纯洁，那么它的行为将不可预料，即使当前没有发现什么异常，但是会埋下很大的隐患：有一天线上出问题了，你怎么也想不到，居然是某一个看上去不会干坏事的函数捣的鬼。</p>\n<p><a name=HTSxL></a></p>\n<h2>不纯洁的危害，血淋淋的例子：</h2>\n<p>曾经碰到一个线上的问题，在非生产环境没有出现过，在生产环境上也只是偶尔出现，经过长时间的排查，最后发现罪魁祸首正是一个看上去是一个很正常的函数做了一件不纯洁的事情，最后做得一个紧急修复如下：<br />\ndiff</p>\n<ul>\n<li>const { data, response } = await this.httpClient.executeJsonRequest(url, options)</li>\n</ul>\n<ul>\n<li>const { data, response } = await this.httpClient.executeJsonRequest(url, { ...options })</li>\n</ul>\n<p>改动虽然很小，但是代码变得更丑了，但这没有办法，因为 executeJsonRequest 是一个公共库，它的名字看上去只是执行一个 http 请求，但是实际上它偷偷干了一点其他的事情，就是会改变传入的参数 options 下的某个属性，正好在后面某处有人把这个 options 传给了一个 logger，然而这个 logger 使用了 JSON.stringify 。</p>\n<p>多数情况下，这没有问题，但是看了这个公共库的源码才知道，这个原本发送请求的方法竟然将 options 参数改成了一个网络请求中的对象，本来这个 options 参数只是一个 Plain JavaScript Object，但是被改成了一个网络请求中的对象后就复杂了，在某些网络情况下，这个对象的层次会变得很深，而且某一层的属性引用了父级属性，如此导致出现了一个循环引用，这在运行时的内存中不会引发任何问题，但是当后面的日志模块将这个 options 进行序列化时就崩溃了！</p>\n<p>但是后面的日志模块哪里会想到这个 Plain JavaScript Object 会被别人修改呢？所以这就是<strong>不纯洁的危害</strong>。\ntypescript\nasync executeRequest(url: string, options: RequestOptions = {}): Promise<HttpResponse> {\nconst timer = new Date()\nconst requestMethod: string = options.method || GET</p>\n<p>// 罪魁祸首！为什么要修改外部传进来的参数？！\nif (url.startsWith(https)) {\noptions.agent = this.httpsAgent\n} else {\noptions.agent = this.httpAgent\n}\n...\n}</p>\n<p><a name=NxX7K></a></p>\n<h2>和纯函数相处，拥有纯粹的快乐</h2>\n<blockquote>\n<p>给定相同的输入，总是返回相同的输出，并且不存在任何可以观测到的副作用的函数，就是纯函数。\n副作用指的是在函数计算出结果的同时，改变了系统状态或者改变了与外界的可观测到的交互行为。</p>\n</blockquote>\n<p>上面的血淋淋的例子，就是那个本该只发送网络请求的函数，改变了外部传入的参数中的某个属性。当然，发送网络请求的函数，涉及到网络 IO，无论如何做不到完全的纯粹，但是应该将不纯粹的部分减少到最小。无论如何，修改外部传入的参数是不允许的，关于发送网络请求的函数如何保证同样的输入总是得到同样的输出，可以使用 memoize 实现（后面有机会单独分享）。</p>\n<p>和纯函数相处，将拥有纯粹的快乐，这些快乐包括但是不限于：</p>\n<ul>\n<li>可缓存性好（参考 memoize）</li>\n<li>可移植性好/自文档（完全自包含，强制做到了依赖“注入”）</li>\n<li>可测试性好（只需要给定输入验证输出，连 mock 都用不着啦！）</li>\n<li>可推理性好（引用透明性）</li>\n<li>可并行性好（由于没有副作用，所以不会产生竞态条件）</li>\n</ul>\n<p><a name=YCwuL></a></p>\n<h2>挑战：异常处理</h2>\n<p>看到这个么多纯粹的快乐，你很可能已经动手开始写纯函数式的代码了，这似乎不难，比如对于那个不纯洁的公共库，只要改成不要修改外部传入的参数就很接近了。但是我的代码总要进行异常处理吧，难以置信的是，try/catch/throw 这种代码竟然也是不纯洁的。</p>\n<p>因为当有错误被抛出时，这个函数与平时的表现不一样，没有返回值，取而代之的竟然是打断了程序的正常运行，抛出一些奇奇怪怪的东西出来。</p>\n<p>前面提到通过使用 memoize 可以将原本不纯洁的网络 IO 操作变成一个纯洁的函数，像知名的 _lodash 和 rambda 都有 memoize 供你伸手取用，那么对于异常处理的 try/catch/throw 这种代码是否也有相应的库呢？</p>\n<p>你一定没有想到这里会出现一个广告：弱弱地推荐一下我 8 个月前写的一个纯洁的异常处理小库，名曰： @jeff-tian/failable 。已经用在公司的生产环境快一年了，觉得有一点点价值，可以帮你做一些脏活累活，特出此文专门分享。</p>\n<p><a name=bxFAV></a></p>\n<h2>@jeff-tian/failable</h2>\n<p>使用姿势（可以用在 TypeScript 和 JavaScript 项目中）：</p>\n<ol>\n<li>安装：</li>\n</ol>\n<p>typescript\nnpm i --save @jeff-tian/failable</p>\n<ol start=\"2\">\n<li>使用示例</li>\n</ol>\n<p>太简单了，直接贴一下这个小库中的测试代码吧（不是有句话叫测试即文档吗？）。\ntypescript\ndescribe(wrap throwable functions, () => {\nconst sut = (x: number) => {\nif (x > 100) {\nthrow new Error(too big!)\n}</p>\n<pre><code>    return x\n}\n\nit(ok, () => {\n    assert(Failable.dontThrow(sut, 5).toString() === Ok(5))\n})\n\nit(err, () => {\n    const res = Failable.dontThrow(sut, 101)\n    assert(res instanceof Err)\n    assert(res.value.message === too big!)\n})\n</code></pre>\n<p>})</p>\n<p>可见，对于一个可能抛异常的代码，只要将它用 @jeff-tian/failable 封装，它就一定会返回一个值，并且对同样的输入，一定得到同样的输出，完全可以预期，不会有任何意外。<br />对于异步代码仍然适用，举例如下：\ntypescript\ndescribe(Async, () => {\nconst sut = async (x: number) => {\nawait sleepAtLeast(1)</p>\n<pre><code>    if (x > 100) {\n        throw new Error(too big!)\n    }\n\n    return x\n}\n\nit(ok, async () => {\n    let res = await Failable.dontThrowAsync(sut, 5)\n    assert(res.value === 5)\n})\n\nit(err, async () => {\n    const res = await Failable.dontThrowAsync(sut, 101)\n    assert(res instanceof Err)\n    assert(res.value.message === too big!)\n\n    return err\n})\n</code></pre>\n<p>})</p>\n<p><a name=mWMbd></a></p>\n<h2>额外的好处</h2>\n<p>通过使用 @jeff-tian/failable 可以是代码变得更加简洁和易读，拿一段实际代码举个例子：经常会有那种发送网络请求，确保拿到预期结果后，才做下一步逻辑；拿到结果不符合预期或者网络错误的情况下，执行另外一段逻辑。所以可能会看到这样的代码（我在实际项目中经常碰到这样的代码，当然，我总是使用 @jeff-tian/failable 把它重构掉）\ntypescript\ntry {\nconst response = await this.request(url, options)</p>\n<p>if (!response) {\n// 这里是错误处理逻辑\n} else {\n// 进行后续处理逻辑\n}\n} catch {\n// 这里又是一段错误处理逻辑（和 try 里的一段重复）\n}</p>\n<p>使用 @jeff-tian/failable 重构后的代码大致长这样：\ntypescript\nconst response = await Failable.dontThrowAsync(this.request, url, options)</p>\n<p>if (!response.isOk() || !response.value) {\n// 错误处理逻辑\n} else {\n// 后续处理逻辑\n}</p>\n<p><a name=wiRzs></a></p>\n<h2>总结</h2>\n<p>本文给出了一个将异常处理纯洁化的 TypeScript 语言实现，欢迎留言给出其他语言对应的示例。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}