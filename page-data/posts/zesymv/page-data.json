{"componentChunkName":"component---src-templates-post-js","path":"/posts/zesymv","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/zesymv","relativePath":"posts/zesymv","frontmatter":{"title":"Free Arch：给 GraphQL 加上服务器端响应缓存","stackbit_url_path":"posts/zesymv","date":"2021-10-27T13:00:45","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=CdND2></a></p>\n<h1>题外话（声明本文和图数据库无关）</h1>\n<p>最近写了几篇关于 GraphQL 的文章：</p>\n<p>《<a href=\"https://zhuanlan.zhihu.com/p/412196725\">一顿操作猛如虎，部署一个万能 BFF</a>》<br />《<a href=\"https://zhuanlan.zhihu.com/p/415577362\">使用万能 BFF，将语雀文章 GraphQL 服务化</a>》<br />《<a href=\"https://zhuanlan.zhihu.com/p/416697232\">在小程序里接入 GraphQL</a>》<br />《<a href=\"https://zhuanlan.zhihu.com/p/423766959\">Free Arch：给 GraphQL 增加 CDN 缓存</a>》</p>\n<p>得到一些私信以及评论，问我关于图数据库的问题。我声明一下，<strong>目前我还没有任何使用图数据库的经验！</strong></p>\n<p>当然如果通过<a href=\"https://www.zhihu.com/consult/people/1073548674713423872\"><strong>付费咨询</strong></a>来问我，我可能不会这么说，我会悄悄地学习一下，再回答，哈哈哈哈哈。</p>\n<p>我在另一个<a href=\"https://www.zhihu.com/question/336797348/answer/2189072784\">回答</a>里，也简单声明了，GraphQL 和图数据库完全是两码事，这里再澄清一下：</p>\n<ul>\n<li>图数据库是一种将数据存储在图中的数据存储技术，如果数据和数据间存在相互关系的话（当前的大多数数据集正好符合这个特征），据说它的性能是非常非常好的。但是我本人目前并没有任何使用图数据库的经验。</li>\n<li>GraphQL 是查询数据的一种方式。它定义了灵活的 API 协议，允许你查询指定的刚好需要的数据，并且按需返回。至于数据存储技术采用什么，GraphQL 完全不管。这个我有一些经验。</li>\n</ul>\n<p><a name=Ffzl4></a></p>\n<h2>GraphQL 总结</h2>\n<p>GraphQL 和图数据库是两回事情，GraphQL 是一种灵活的查询语言，其优势并不依赖图数据库，所以放心地使用吧！</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635309885666-1ffdcd5f-649e-470b-ad70-86d0734c6678.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;id=u90e65e35&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=558&#x26;originWidth=1330&#x26;originalType=binary%E2%88%B6=1&#x26;size=86807&#x26;status=done&#x26;style=none&#x26;taskId=u847243c2-2912-4257-ba1e-abe82e0941f\" alt=\"image.png\">\n<a name=OqhqF></a></p>\n<h1>前情提要</h1>\n<p>在 《<a href=\"https://zhuanlan.zhihu.com/p/423766959\">Free Arch：给 GraphQL 增加 CDN 缓存</a>》一文里，详细叙述了如何薅各种云厂商的羊毛，从而给 GraphQL 服务加速，以一个非常慢的的查询为例子，解决了其三慢合一中的两慢。</p>\n<ul>\n<li>服务器端慢查询</li>\n<li><del>AWS lambda 冷启动</del>，通过 CDN 缓存直接响应，多数请求不再打到 AWS lambda。</li>\n<li><del>Heroku 冷启动</del>，通过 AWS API Gateway 的自定义域名，不再依赖 Heroku 上的代理服务。</li>\n</ul>\n<p>其中服务器端慢查询并未解决，从而需要 CDN 预热。即正如前文所说的，请求量分布越广泛，请求量越大，该服务的整体性能表现越好。但是对于小站点来说，用户是零星分布在各个不同的地域。就是说尽管每个地域只要有第一个人访问了该服务，触发了该地域的 CDN 缓存建立，从而使得后续该地域的用户感受到极快的服务响应，但是这个小站点在该地域就那么一个用户，他的体验不好，就直接流失了，没有更多的用户来感受到后续的极快响应。所以反而是小站点更需要解决第一个慢的问题，因为它的用户发出的请求，更容易直接打到服务器。而大站点，多数用户的请求只到达 CDN 就直接折返了。</p>\n<p>今天就来解决这第一个慢的问题。</p>\n<p><a name=XgNUh></a></p>\n<h1>思路</h1>\n<p>尽管慢查询的根本原因在后端的代码，但是免费架构的思路确实从前到后去做优化。就是尽量在烂代码的前提下，提升系统的整体表现。在烂代码的前提下，改善了系统整体性能表现后，再去优化后端代码（如果追求极致的话）；多数情况下可能直接省略了烂代码的优化过程，毕竟，又不是不能跑，而且已经跑得很好了！</p>\n<p>CDN 缓存是最靠前的优化，今天往后一步，在请求从服务器端发出时做个拦截，将请求发出去时，同时将响应体写在内存里。这样，再有请求打到服务器端，就直接从内存读取上次查询得到的结果并发出去，从而避免执行慢查询。</p>\n<p><a name=glA66></a></p>\n<h1>启用响应缓存</h1>\n<p>使用 Apollo 的话，有官网可以参考。所以从编码层面不做详述，具体的实际案例的细节，可以参考这个提交：<br /><a href=\"https://github.com/Jeff-Tian/serverless-space/commit/45cce5614866b340c8fb08b8b911dc9294c2017e\">https://github.com/Jeff-Tian/serverless-space/commit/45cce5614866b340c8fb08b8b911dc9294c2017e</a></p>\n<p>这仍然是一篇免费架构的系列文章，因此重点会放在如何薅羊毛上，以及分享其他的小妙招。</p>\n<p><a name=ovzLI></a></p>\n<h1></h1>\n<p><a name=HQTMg></a></p>\n<h1>效果展示</h1>\n<p><a name=IbaBS></a></p>\n<h2>端到端体验（微信扫码）</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635337609720-6c0cebdb-b95f-4db6-ae6e-89afa27a954a.png#clientId=u4f79e532-51a5-4&#x26;from=ui&#x26;id=u7ab74c63&#x26;margin=%5Bobject%20Object%5D&#x26;name=%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png&#x26;originHeight=800&#x26;originWidth=2172&#x26;originalType=binary%E2%88%B6=1&#x26;size=6950538&#x26;status=done&#x26;style=none&#x26;taskId=u2231683a-74cc-4403-9406-ce45f11c351\" alt=\"扫码_搜索联合传播样式-微信标准绿版.png\"></p>\n<p><a name=NPPn4></a></p>\n<h2>响应速度</h2>\n<p>通过 Apollo Studio，直接访问 AWS lambda API Gateway 的原始默认链接（绕过 CDN）：<br /><a href=\"https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/nest/graphql\">https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/nest/graphql</a>，请求慢查询，可以看到延时在 1 秒以内！（要知道，因为使用的是 AWS 免费账户，所以是 AWS 海外的 lambda 服务）<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635337730382-83860f2f-f176-407d-82bd-8468e7b3a85d.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;height=474&#x26;id=uc5531099&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=948&#x26;originWidth=2682&#x26;originalType=binary%E2%88%B6=1&#x26;size=301460&#x26;status=done&#x26;style=none&#x26;taskId=ue8883dd6-7d1a-4fb4-b844-a3128ca9b90&#x26;width=1341\" alt=\"image.png\"></p>\n<p><a name=n89Qb></a></p>\n<h2>请求头</h2>\n<p>缓存控制被正确设置<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635337959300-e34b616a-d677-4f0b-a348-b54f8f8ba927.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;height=430&#x26;id=ufe1c464c&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=860&#x26;originWidth=2372&#x26;originalType=binary%E2%88%B6=1&#x26;size=242112&#x26;status=done&#x26;style=none&#x26;taskId=u5101f8a2-bfa7-44e7-b63f-30413570b91&#x26;width=1186\" alt=\"image.png\"></p>\n<p><a name=azsRe></a></p>\n<h2>Redis 缓存的内容展示</h2>\n<p>后面会详述如何使用免费的 Redis 服务，以及为什么需要使用公开服务展示 Redis 的缓存内容。</p>\n<p>访问： <a href=\"https://uniheart.herokuapp.com/redis\">https://uniheart.herokuapp.com/redis</a> 可以展示 Redis 的缓存内容，可以看到慢查询的结果被正确缓存了，并且以 Apollo 默认的 fqc:xxxx 作为键值：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635338521823-c0cc06fb-b84e-44fb-a725-11ba62a30bf3.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;height=371&#x26;id=u6943e2f7&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=741&#x26;originWidth=1919&#x26;originalType=binary%E2%88%B6=1&#x26;size=575457&#x26;status=done&#x26;style=none&#x26;taskId=u8003af57-52e2-4f87-b9c6-87245a663a1&#x26;width=959.5\" alt=\"image.png\"></p>\n<blockquote>\n<p>这里为了方便在线展示，复用了几年前的免费服务。如果被滥用，以上路由可能会被加上锁。</p>\n</blockquote>\n<p><a name=L6med></a></p>\n<h1>免费使用 Redis To Go 的中转方案</h1>\n<p>正如 Apollo 官网所说，启用响应缓存，可以使用 Redis 或者其他内存数据库。这里发现一个好的在线 Redis 服务，Redis To Go：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635338666871-0c8afeb8-e729-4204-94fe-9f9773c93b41.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;height=261&#x26;id=udf8eb54b&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=522&#x26;originWidth=1541&#x26;originalType=binary%E2%88%B6=1&#x26;size=93272&#x26;status=done&#x26;style=none&#x26;taskId=ub6159c01-2574-46fc-af87-391d4d43578&#x26;width=770.5\" alt=\"image.png\"></p>\n<p>正如上图首页展示的，官网没有免费选项，但是免费架构教你如何免费使用 Redis To Go 的服务。很简单，去 Heroku 里创建一个应用，然后在这个应用里添加一个 Redis add-on，选择 Redis To Go。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635338796244-b8a6a5c1-2475-4489-9a76-419c0cf32c66.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;id=ua2203985&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=675&#x26;originWidth=958&#x26;originalType=binary%E2%88%B6=1&#x26;size=81862&#x26;status=done&#x26;style=none&#x26;taskId=ucf14243f-f7e8-4024-9084-aad6a2503bf\" alt=\"image.png\"></p>\n<p>然后你就可以从环境变量里读取链接字符串，形如：redis://redistogo:<a href=\"mailto:password@hostname.redistogo.com\">password@hostname.redistogo.com</a>:9295</p>\n<p><a name=KdZeH></a></p>\n<h1>Redis Insight 小妙招分享</h1>\n<p>Redis Insight 是一个 Redis Web 控制台，使用它可以方便观测 Redis 服务器。要启动很简单，可以参考如下 docker-compose 文件：</p>\n<p>yaml\nversion: 3\nservices:\nredis:\nimage: redis\nports:\n- 6379:6379</p>\n<p>redisinsight:\nimage: redislabs/redisinsight:latest\nports:\n- 8001:8001</p>\n<p>然后执行：</p>\n<p>shell\ndocker compose up -d\nopen <a href=\"http://localhost:8001\">http://localhost:8001</a></p>\n<p>接下来是一个小妙招系列。打开 Redis Insight 后，添加 Redis 服务器时，会看到对话框中分开给予了配置项，但是我们拿到的是一个连接字符串。我曾经准备给 Redis Insight 提改进意见，让它直接接收连接字符串，从而不需要手动去拆开连接字符串。但是实际上 Redis Insight 是支持连接字符串的！只需要复制连接字符串，然后在对话框里粘贴就行，它会自动拆解：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635339263887-55731036-72af-4a85-96e0-e6ba12279af9.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;id=u847b66a3&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=246&#x26;originWidth=386&#x26;originalType=binary%E2%88%B6=1&#x26;size=38295&#x26;status=done&#x26;style=none&#x26;taskId=ucf6713f8-82b6-4ac0-9d8a-19bd704884c\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1635339304122-4aac1cd0-93ec-4dd7-8e9c-47f3633ba453.png#clientId=u4f79e532-51a5-4&#x26;from=paste&#x26;id=u2898727d&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=685&#x26;originWidth=1360&#x26;originalType=binary%E2%88%B6=1&#x26;size=177620&#x26;status=done&#x26;style=none&#x26;taskId=u257ed327-7a12-4878-86ec-0a229379187\" alt=\"image.png\"></p>\n<p><a name=wgASU></a></p>\n<h1>总结</h1>\n<p>通过 Heroku 免费应用的中转，成功薅到 Redis To Go 的 Redis 服务羊毛。启用 GraphQL 响应缓存，使得在没有 CDN 的情况下，也能改善系统的整体响应速度。结合前面的 CDN 缓存，解决三慢合一问题，既优化了第一个用户的体验，又优化了后续其他用户的体验。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}