{"componentChunkName":"component---src-templates-post-js","path":"/posts/ee4y3g","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/ee4y3g","relativePath":"posts/ee4y3g","frontmatter":{"title":"一顿操作猛如虎，部署一个万能 BFF","stackbit_url_path":"posts/ee4y3g","date":"2021-09-20T02:46:24","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<blockquote>\n<p>通过将 gatsby 的本地开发 GraphQL 服务器 Serverless 化，借助其强大和丰富的插件系统以及生态，实现一个万能的 BFF 层。</p>\n</blockquote>\n<p><a name=McS6U></a></p>\n<h1>Gatsby Js</h1>\n<p>Gatsby Js 最初的定位是一个静态站点生成器，和一般的静态站点生成器不同，它拥有丰富的源插件，可以从各种数据源同步数据，通过 GraphQL Server 将这些数据暴露给客户端。</p>\n<p>由于它追求极致的性能和用户体验，因此其 GraphQL Server 只在站点生成阶段运行。也就是说，在本地开发和站点编译时，拥有一个动态服务器，编译阶段，会读取所有的数据，最终生成静态的 html 文件，并且分发到强大的 CDN 网络，从而实现页面秒开效果。</p>\n<p>gatsby 的生态，几乎集成了一切数据源，不管是调用 API、还是读取数据库、还是直接解析各种配置文件或者 markdown，都不用再写代码，只需要添加相关插件即可。尽管目前这一切只发生在编译阶段，但是只需要稍作魔改，就能将其部署成一个动态服务，变成一个万能 BFF！</p>\n<p><a name=biINm></a></p>\n<h1>BFF 层</h1>\n<p>我不仅被它的极致用户体验解决方案所吸引，还被它的本地 GraphQL Server 所吸引，凭借它丰富的插件，它这个 GraphQL Server 就是一个天然优秀的 BFF 层呀！</p>\n<p>虽然其本地 GraphQL Server 只是用来生成静态站点的，但是如果能将它部署到公网，就可以实时为多端提供服务了，不仅网站可以使用其数据源，小程序，APP 都可以使用。</p>\n<p>BFF 层的提出，本来是针对不同的端提供不同的 BFF 服务，但由于使用了 GraphQL，将服务的聚合裁剪功能扔到前端，于是一个服务就能同时给到不同的端。</p>\n<p><a name=AccYj></a></p>\n<h1>免费的 AWS lambda</h1>\n<p>部署到公网很有吸引力，但是要花钱的话，就没意思了。</p>\n<p>于是，我把目光瞄准了 AWS lambda，它的免费额度够我用的了。</p>\n<p><a name=n76Vg></a></p>\n<h1>说干就干</h1>\n<p>最终效果演示： <a href=\"https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql\">https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql</a><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1632103436787-c0c0c672-5eb5-4068-936e-bc082b00327a.png#clientId=ub7561baf-757a-4&#x26;from=paste&#x26;height=713&#x26;id=u87598e79&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1426&#x26;originWidth=2686&#x26;originalType=binary%E2%88%B6=1&#x26;size=357075&#x26;status=done&#x26;style=none&#x26;taskId=u158ec210-4189-4c12-81f4-a88acc7f10d&#x26;width=1343\" alt=\"image.png\"><br />源代码库： <a href=\"https://github.com/Jeff-Tian/serverless-space\">https://github.com/Jeff-Tian/serverless-space</a></p>\n<p>源代码库代码较多，主要是把 gatsby-js 的一个库 gatsby-recipes 拷贝过来做了一番魔改，以绕过 AWS lambda 环境中，不能写文件的问题。下面对主要的改造过程做个分解。</p>\n<p><a name=jMMOQ></a></p>\n<h1>Serverless</h1>\n<p>Serverless 本意是去掉服务器，让开发者只需要关注业务逻辑，不用管基础设施，不同的云厂商对其有不同的实现。Serverless 框架做了个抽象，让开发者通过一个统一的 yaml 文件定义服务，它来对不同的云厂商做具体的适配。</p>\n<p><a name=qCRph></a></p>\n<h2>安装</h2>\n<p>shell\nnpm install -g serverless</p>\n<p><a name=CxvYV></a></p>\n<h2>定义服务</h2>\n<p>serverless.yml\nyaml\nservice: serverless-space</p>\n<p>provider:\nname: aws\nruntime: nodejs12.x\nlambdaHashingVersion: 20201221</p>\n<p>package:\npatterns:\n- !node_modules/**\n- !layers/**</p>\n<p>functions:\ngatsby:\nhandler: dist/src/gatsby.handler\nlayers:\n- {Ref: LibLambdaLayer}\nevents:\n- http:\nmethod: ANY\npath: gatsby/\n- http:\nmethod: ANY\npath: gatsby/{proxy+}\nenvironment:\nSERVERLESS_EXPRESS_PLATFORM: aws</p>\n<p>plugins:</p>\n<ul>\n<li>serverless-plugin-layer-manager</li>\n<li>serverless-offline</li>\n<li>serverless-express</li>\n</ul>\n<p>layers:\nlib:\npath: layers\nname: space-lib\ndescription: My dependencies\nretain: true</p>\n<p>从上面可以看到，定义中使用了一些插件，serverless-offline 和 serverless-express 是为了方便本地运行用的，实现 serverless offline 在本地环境下模拟 lambda。而 serverless-plugin-layer-manager 则是用来对 lambda 分层。通过使用这个插件，只需要定义层就好，省去了手动压缩、上传、关联等等繁杂的工作，非常方便。</p>\n<p><a name=BUic8></a></p>\n<h2>分层</h2>\n<p>分层的好处是把变动不频繁的 node_modules 部分与变动频繁的应用业务逻辑代码隔离，从而减小每次发布时的网络传输大小，以及可以实现同一个层同时为多个 lambda 服务。</p>\n<p>在 serverless yaml 配置文件里，对于分层有个命名约定。比如你的分层命名为 xxx，那么在引用它时，就要用 {Ref: XxxLambdaLayer}，并且注意大小写。</p>\n<p><a name=r9pPz></a></p>\n<h2>全局安装 serverless 及其插件</h2>\n<p>这并不是必需的，但是推荐。原因是无论是对于 lambda 应用代码，以及 node_modules 分层大小，都有一个 250 M 的上限，这个上限是压缩前的大小。如果不采用全局安装，会导致 serverless 自动将插件安装在 node_modules 里，导致增加 node_modules 文件夹的大小。</p>\n<p>bash\nnpm install -g serverless\nnpm install -g serverless-plugin-layer-manager\n...</p>\n<p><a name=FgiUo></a></p>\n<h2>部署</h2>\n<p>serverless 可以一键部署，自动搞定资源分配和建立关联、以及权限配置等等。在写好应用代码，配置好 serverless.yml 文件后，就能一键部署：</p>\n<p>bash\nserverless deploy</p>\n<p><a name=w8dZn></a></p>\n<h1>项目大致目录结构</h1>\n<p>bash\n|---- layers\n|---- nodejs\n|---- .npmrc\n|---- node_modules\n|---- node_modules\n|---- src\n|---- gatsby.ts\n|---- gatsby-recipes\n|---- ...\n|---- serverless.yml\n|---- tsconfig.json\n|---- tsconfig.build.json\n|---- package.json</p>\n<p>layers 目录是分层用的，注意它一定要包含一个 nodejs 目录，在部署前，必须的依赖就安装在这个目录下，所以可以在这个目录下建立一个文件 .npmrc，并配置为只安装生产必须的依赖：</p>\n<p>.npmrc\nbash\nonly=production</p>\n<p><a name=yaSgw></a></p>\n<h1>TypeScript 配置</h1>\n<p>TypeScript 是 JavaScript 的一个超集，解决了原生 JavaScript 饱受诟病的动态特性，建立了一个完善的类型系统。为了使用 TypeScript 开发的同时，部署成 JavaScript，需要配置指示 tsc 如何将 TypeScript 转译成 JavaScript。</p>\n<p>tsconfig.json\njson\n{\ncompilerOptions: {\nmodule: commonjs,\nesModuleInterop: true,\ndeclaration: true,\nremoveComments: true,\nemitDecoratorMetadata: true,\nexperimentalDecorators: true,\nallowSyntheticDefaultImports: true,\ntarget: es2017,\nsourceMap: true,\noutDir: ./dist,\nbaseUrl: ./,\nincremental: true,\nskipLibCheck: true,\nallowJs: true,\njsx: react-jsx,\n},\ninclude: [\nsrc/**/*,\nREADME.md\n]\n}</p>\n<p>注意这里在 include 部分除了包含必要的 src 目录下的文件外，还额外引入了根目录下的 READ.md 文件，这只是为了让生成的 dist 目录保留原始项目结构（即有 src 部分），不然 dist 目录下会直接是 src 下的被转译后的文件。</p>\n<p>为了排除不必要的文件，可以在 tsconfig.build.json 里指定：\njson\n{\nextends: ./tsconfig.json,\nexclude: [\ndist,\ntest,\n**/*spec.ts\n]\n}</p>\n<p>这里还配置了 jsx 以支持 react-jsx，因为 gatsby-recipes 里需要。</p>\n<p><a name=h5x1C></a></p>\n<h1>魔改 gatsby-recipes</h1>\n<p>将 0.9.3 这个版本的 gatsby-recipes 源文件拷贝到项目，删除其 dist 目录，然后打开 src/gatsby-recipes/src/providers/npm/package.js 文件，将其原本的 getConfigStore 引用删除，然后改写：</p>\n<p>diff</p>\n<ul>\n<li>import {getConfigStore} from gatsby-core-utils</li>\n</ul>\n<ul>\n<li>const getConfigStore = () => ({ get: () => yarn })</li>\n</ul>\n<p>这样就能避免在 lambda 环境，该文件尝试写文件的错误。</p>\n<p><a name=rUE1h></a></p>\n<h1>gatsby.ts 入口文件</h1>\n<p>这是整个 lambda 的入口，详细参见源代码。主要工作是将 express 替换成 serverless/express，同时引入 bodyParser，否则会接受不到客户端传来的 GraphQL 查询。因为 GraphQL 本质上是一个 HTTP Post 请求。</p>\n<p>typescript\nimport express from serverless-express/express\nimport {graphqlHTTP} from express-graphql\nimport cors from cors\nimport bodyParser from body-parser</p>\n<p>const app = express()</p>\n<p>app.use(cors())\napp.use(bodyParser.json())</p>\n<p>app.use(/graphql, graphqlHTTP({\nschema,\ngraphiql: true,\ncontext: {root: directory}\n}))</p>\n<p>const port = 3000</p>\n<p>if (require.main === module) {\nconsole.log(called directly)</p>\n<pre><code>app.listen(port, () => {\n    console.log(Example gatsby serverless app listening at http://localhost:${port})\n})\n</code></pre>\n<p>}</p>\n<p>export default app</p>\n<p>const bootstrap = async () => {\nreturn serverlessExpress({app})\n}</p>\n<p>let server</p>\n<p>export const handler: Handler = async (\nevent: any,\ncontext: Context,\ncallback: Callback,\n) => {\nserver = server ?? (await bootstrap())\nreturn server(event, context, callback)\n}</p>\n<p>以上代码判断 require.main，如果是本地直接运行，就会监听 （3000） 端口，准备提供服务。而如果是在 lambda 环境，那么 handler 函数会被触发。</p>\n<p><a name=SVuiB></a></p>\n<h1>总结</h1>\n<p>通过对 gatsby-recipes 的魔改，使得 gatsby 本地开发用的 GraphQL Server 可以运行在 AWS lambda 上，从而实现了一个免费又强大（万能）的 BFF 层。</p>\n<p>后面只需要添加不同的数据源插件，就能给不同的前端提供几乎所有服务了。</p>\n<p>有兴趣的同学欢迎持续关注，后面将持续更新，使用真实案例，分解如何利用该万能 BFF，应用在具体的场景上。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}