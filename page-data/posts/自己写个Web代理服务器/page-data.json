{"componentChunkName":"component---src-templates-post-js","path":"/posts/自己写个Web代理服务器/","result":{"data":{"sitePage":{"id":"SitePage /posts/自己写个Web代理服务器/"}},"pageContext":{"url":"/posts/自己写个Web代理服务器/","relativePath":"posts/自己写个Web代理服务器.md","relativeDir":"posts","base":"自己写个Web代理服务器.md","name":"自己写个Web代理服务器","frontmatter":{"title":"自己写个Web代理服务器","stackbit_url_path":"posts/自己写个Web代理服务器","date":"2010-06-24 03:53:19","excerpt":"","comments_count":0,"positive_reactions_count":0,"tags":[null],"canonical_url":"https://be-net.azurewebsites.net/post/2010/06/24/自己写个Web代理服务器","template":"post"},"html":"<pre><code>    &#x3C;p>这是《计算机网络 自顶向下方法》一书中的编程实验。&#x3C;/p>\n</code></pre>\n<p><strong><a target=\"_blank\" href=\"http://www.myfootprints.cn/OldWeb/blog/upload/ProxyCache.rar\">下载源码与可执行文件</a> --&gt;&nbsp;</strong><a href=\"http://www.myfootprints.cn/OldWeb/blog/upload/ProxyCache.rar\" target=\"_blank\">ProxyCache.rar</a></p>\n<p>这个实验研发一个简单的Web代理服务器，该服务器将接收来自浏览器的GET报文，向目的地Web服务器转发GET报文，从目的地服务器接收HTTP响应报文，向浏览器转发HTTP响应报文。这是一个非常简单的代理服务器，它仅能理解简单的GET请求。然而，该服务器能够处理各种对象，并不仅仅是HTML页面，而且也包括图像。</p>\n<p>以下是Java代码，共分为三个类，分别是ProxyCache.java，HttpRequest.java，HttpResponse.java。</p>\n<p>编译后，要运行，只需在命令行中输入：java ProxyCache 9999，其中9999为端口号，你可以指定为6899等别的端口号。</p>\n<p>然后，在浏览器中需要配置代理服务器，IP地址为运行该程序的机器的IP地址，端口号为你刚才指定的，如9999。</p>\n<p>ProxyCache.java :</p>\n<pre class=\"brush: c++\">/**\n * ProxyCache.java\t-\tSimple caching proxy\n * \n * $Id:\tProxyCache.java, v 1.3 2004/02/16 15:22:00\tkangasha Exp $\n *\n */\n<p>import java.net.<em>;\nimport java.io.</em>;\nimport java.util.*;</p>\n<p>public class ProxyCache {\n/** Port for the proxy <em>/\nprivate static int port;\n/</em>* Socket for client connections */\nprivate static ServerSocket socket;</p>\n<pre><code>/** Create the ProxyCache object and the socket */\npublic static void init(int p) {\n\tport = p;\n\ttry {\n\t\tsocket = new ServerSocket(port);\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error creating socket: \" + e);\n\t\tSystem.exit(-1);\n\t}\n}\n\npublic static void handle(Socket client) {\n\tSocket server = null;\n\tHttpRequest request = null;\n\tHttpResponse response = null;\n\t\n\t/* Process request. If there are any exceptions, then simply\n\t * return and end this request. This  unfortunately means the \n\t * client will hang for a while, until it timeouts.\n\t */\n\t\n\t/* Read request */\n\ttry {\n\t\tBufferedReader fromClient = new BufferedReader(new InputStreamReader(client.getInputStream()));\n\t\trequest = new HttpRequest(fromClient);\n\t\t\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error reading request from client: \" + e);\n\t\treturn ;\n\t}\n\t\n\t/* Send request to server */\n\ttry {\n\t\t/* Open socket and write request to socket */\n\t\tserver = new Socket(request.getHost(), request.getPort());\n\t\tDataOutputStream toServer = new DataOutputStream(server.getOutputStream());\n\t\ttoServer.writeBytes(request.toString());\n\t\t// 以下toServer不能够close，它关闭会导致连接server也会关闭\n</code></pre>\n<p>//\t\t\ttoServer.close();\nSystem.out.println(\"Request forwarded.\");</p>\n<pre><code>\t} catch (UnknownHostException e) {\n\t\tSystem.out.println(\"Unknown host: \" + request.getHost());\n\t\tSystem.out.println(e);\n\t\treturn;\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error writing request to server: \" + e);\n\t\treturn ;\n\t}\n\t\n\t/* Read response and forward it to client */\n\ttry {\n\t\tDataInputStream fromServer = new DataInputStream(server.getInputStream());\n\t\tresponse = new HttpResponse(fromServer);\n\t\tDataOutputStream toClient = new DataOutputStream(client.getOutputStream());\n\t\ttoClient.writeBytes(response.toString());\n\t\ttoClient.write(response.body);\n\t\t/* Write response to client. First headers, then body */\n\t\tclient.close();\n\t\tserver.close();\n\t\t/* Insert object into the cache */\n\t\t/* Fill in (optional exercise only) */\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error writing response to client: \" + e);\n\t}\n}\n\n/** Read command line arguments and start proxy */\npublic static void main (String args[]) {\n\tint myPort = 0;\n\t\n\ttry {\n\t\tmyPort = Integer.parseInt(args[0]);\n\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\tSystem.out.println(\"Need port number as argument\");\n\t\tSystem.exit(-1);\n\t} catch (NumberFormatException e) {\n\t\tSystem.out.println(\"Please give port number as integer.\");\n\t\tSystem.exit(-1);\n\t}\n\t\n\tinit(myPort);\n\t\n\t/** Main loop. Listen for incoming connections and spawn a new \n\t * thread for handling them \n\t */\n\tSocket client = null;\n\t\n\twhile (true) {\n\t\ttry {\n\t\t\tclient = socket.accept();\n\t\t\thandle(client);\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Error reading request from client: \" + e);\n\t\t\t/* Definitely cannot continue processing this request, \n\t\t\t * so skip to next iteration of while loop.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n</code></pre>\n<p>}\n</pre></p>\n<div>&nbsp;</div>\n<p>HttpRequest.java :</p>\n<pre class=\"brush: c++\">/**\n * HttpRequest - HTTP request container and parser\n * \n * $Id: HttpRequest.java, v 1.2 2003/11/26 18:11:53\tkangasha Exp$\n *\n */\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n<p>public class HttpRequest {\n/** Help variables <em>/\nfinal static String CRLF = \"\\r\\n\";\nfinal static int HTTP_PORT = 80;\n/</em>* Store the request parameters <em>/\nString method;\nString URI;\nString version;\nString headers = \"\";\n/</em>* Server and port */\nprivate String host;\nprivate int port;</p>\n<pre><code>/** Create HttpRequest by reading it from the client socket */\npublic HttpRequest(BufferedReader from) {\n\tString firstLine = \"\";\n\ttry {\n\t\tfirstLine = from.readLine();\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error reading request line: \" + e);\n\t}\n\t\n\tString[] tmp = firstLine.split(\" \");\n\tmethod = tmp[0];\n\tURI = tmp[1];\n\tversion = tmp[2];\n\t\n\tSystem.out.println(\"URI is: \" + URI);\n\t\n\tif (!method.equals(\"GET\")) {\n\t\tSystem.out.println(\"Error: Method not GET\");\n\t}\n\t\n\ttry {\n\t\tString line = from.readLine();\n\t\twhile (line.length() != 0) {\n\t\t\theaders += line + CRLF;\n\t\t\t/* We need to find host header to know which server to \n\t\t\t * contact in case the request URI is not complete.\n\t\t\t */\n\t\t\tif (line.startsWith(\"Host:\")) {\n\t\t\t\ttmp = line.split(\" \");\n\t\t\t\tif (tmp[1].indexOf(':') &#x26;gt; 0 ) {\n\t\t\t\t\tString[] tmp2 = tmp[1].split(\":\");\n\t\t\t\t\thost = tmp2[0];\n\t\t\t\t\tport = Integer.parseInt(tmp2[1]);\n\t\t\t\t} else {\n\t\t\t\t\thost = tmp[1];\n\t\t\t\t\tport = HTTP_PORT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = from.readLine();\n\t\t}\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error reading from socket: \" + e);\n\t\treturn;\n\t}\n\tSystem.out.println(\"Host to contact is: \" + host + \" at port \" + port);\n}\n\n/** Return host for which this request is intended */\npublic String getHost() {\n\treturn host;\n}\n\n/** Return port for server */\npublic int getPort() {\n\treturn port;\n}\n\n/**\n * Convert request into a string for easy re-sending.\n */\npublic String toString() {\n\tString req = \"\";\n\t\n\treq = method  + \" \" + URI + \" \" + version + CRLF;\n\treq += headers;\n\t/* This proxy does not support persistent connections */\n\treq += \"Connection: close\" + CRLF;\n\treq += CRLF;\n\t\n\treturn req;\n}\n</code></pre>\n<p>}\n</pre></p>\n<div>&nbsp;</div>\n<p>HttpResponse.java :</p>\n<pre class=\"brush: c++\">/**\n * HttpResponse - Handle HTTP replies\n * \n * $Id: HttpResponse.java, v 1.2 2003/11/26 18:12:42 kangasha Exp $\n *\n */\n<p>import java.io.<em>;\nimport java.net.</em>;\nimport java.util.*;</p>\n<p>public class HttpResponse {\nfinal static String CRLF = \"\\r\\n\";\n/** How big is the buffer used for reading the object <em>/\nfinal static int BUF_SIZE = 8192;\n/</em>* Maximum size of objects that this proxy can handle. For the\n* moment set to 100KB. You can adjust this as needed.\n<em>/\nfinal static int MAX_OBJECT_SIZE = 100000;\n/</em>* Reply status and headers <em>/\nString version;\nint status;\nString statusLine = \"\";\nString headers = \"\";\n/</em> Body of reply */\nbyte[] body = new byte[MAX_OBJECT_SIZE];</p>\n<pre><code>/** Read response from server. */\npublic HttpResponse(DataInputStream fromServer) {\n\t/* Length of the object */\n\tint length = -1;\n\tboolean gotStatusLine = false;\n\t\n\t/* First read status line and response headers */\n\ttry {\n\t\tString line = fromServer.readLine();\n\t\twhile (line.length() != 0) {\n\t\t\tif (!gotStatusLine) {\n\t\t\t\tstatusLine = line;\n\t\t\t\tgotStatusLine = true;\n\t\t\t} else {\n\t\t\t\theaders += line + CRLF;\n\t\t\t}\n\t\t\t\n\t\t\t/* Get length of content as indicated by\n\t\t\t * Content-Length header. Unfortunately this is not \n\t\t\t * present in every response. Some servers return the \n\t\t\t * header \"Content-Length\", others return \n\t\t\t * \"Content-length\". You need to check for both \n\t\t\t * here.\n\t\t\t */\n\t\t\tif (line.startsWith(\"Content-Length\") || \n\t\t\t\t\tline.startsWith(\"Content-length\")) {\n\t\t\t\tString[] tmp = line.split(\" \");\n\t\t\t\tlength = Integer.parseInt(tmp[1]);\n\t\t\t}\n\t\t\tline = fromServer.readLine();\n\t\t}\n\t\t\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error reading headers from server: \" + e);\n\t\treturn;\n\t}\n\t\n\ttry {\n\t\tint bytesRead = 0;\n\t\tbyte buf[] = new byte[BUF_SIZE];\n\t\tboolean loop = false;\n\t\t\n\t\t/* If we didn't get Content-Length header, just loop until \n\t\t * the connection is closed.\n\t\t */\n\t\tif (length == -1) {\n\t\t\tloop = true;\n\t\t}\n\t\t\n\t\t/* Read the body in chunks of BUF_SIZE and copy the chunk\n\t\t * into body. Usually replies come back in smaller chunks \n\t\t * than BUF_SIZE. The while-loop ends when  either we have\n\t\t * read Content-Length bytes or when the connection is \n\t\t * closed (when there is no Content-Length in the \n\t\t * response.\n\t\t */\n\t\twhile (bytesRead &#x26;lt; length || loop) {\n\t\t\t/* Read it in as binary data */\n\t\t\tint res = fromServer.read(buf);\n\t\t\tif (res == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Copy the bytes into body. Make sure we don't exceed \n\t\t\t * the maximum object size. \n\t\t\t */\n\t\t\tfor (int i = 0; i &#x26;lt; res &#x26;amp;&#x26;amp; (i + bytesRead)  &#x26;lt; MAX_OBJECT_SIZE; i++) {\n\t\t\t\tbody[i+bytesRead] = buf[i];\n\t\t\t}\n\t\t\tbytesRead += res;\n\t\t}\n\t} catch (IOException e) {\n\t\tSystem.out.println(\"Error reading response body: \" + e);\n\t\treturn;\n\t}\n}\n\n/**\n * Convert response into a string for easy re-sending. Only \n * converts the response headers, body is not converted to a \n * string.\n */\npublic String toString() {\n\tString res = \"\";\n\t\n\tres = statusLine + CRLF;\n\tres += headers;\n\tres += CRLF;\n\t\n\treturn res;\n}\n</code></pre>\n<p>}\n</pre></p>\n<p><strong><a target=\"_blank\" href=\"http://www.myfootprints.cn/OldWeb/blog/upload/ProxyCache.rar\">下载源码与可执行文件</a>&nbsp;--&gt;&nbsp;</strong><a href=\"http://www.myfootprints.cn/OldWeb/blog/upload/ProxyCache.rar\" target=\"_blank\">ProxyCache.rar</a></p>\n<p>以下是原书的教辅材料上的提示：</p>\n<hr>\n<p>&nbsp;</p>\n<h1 style=\"font-weight: normal; font-size: 19pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Programming Assignment 4: Proxy Cache</h1>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">In this lab you will develop a small web proxy server which is also able to cache web pages. This is a very simple proxy server which only understands simple GET-requests, but is able to handle all kinds of objects, not just HTML pages, but also images.</p>\n<h2 style=\"font-weight: bold; font-size: 16pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Code</h2>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">The code is divided into three classes as follows:</p>\n<ul style=\"font-family: Simsun; line-height: normal; font-size: medium; \">\n    <li><a target=\"_blank\" style=\"color: rgb(0, 0, 102); \" href=\"http://media.pearsoncmg.com/aw/aw_kurose_network_3/labs/lab4/code.html#ProxyCache\"><code>ProxyCache</code></a>&nbsp;holds the start-up code for the proxy and code for handling the requests.</li>\n    <li><a target=\"_blank\" style=\"color: rgb(0, 0, 102); \" href=\"http://media.pearsoncmg.com/aw/aw_kurose_network_3/labs/lab4/code.html#HttpRequest\"><code>HttpRequest</code></a>&nbsp;contains the routines for parsing and processing the incoming requests from clients.</li>\n    <li><a target=\"_blank\" style=\"color: rgb(0, 0, 102); \" href=\"http://media.pearsoncmg.com/aw/aw_kurose_network_3/labs/lab4/code.html#HttpResponse\"><code>HttpResponse</code></a>&nbsp;takes care of reading the replies from servers and processing them.</li>\n</ul>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">Your work will be to complete the proxy so that it is able to receive requests, forward them, read replies, and return those to the clients. You will need to complete the classes&nbsp;<code>ProxyCache</code>,&nbsp;<code>HttpRequest</code>, and&nbsp;<code>HttpResponse</code>. The places where you need to fill in code are marked with&nbsp;<tt>/* Fill in */</tt>. Each place may require one or more lines of code.</p>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \"><b><i>NOTE:</i></b>&nbsp;As explained below, the proxy uses DataInputStreams for processing the replies from servers. This is because the replies are a mixture of textual and binary data and the only input streams in Java which allow treating both at the same time are DataInputStreams. To get the code to compile, you must use the -deprecation argument for the compiler as follows:</p>\n<pre>        javac -deprecation *.java\n</pre>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">If you do not use the -deprecation flag, the compiler will refuse to compile your code!</p>\n<h3 style=\"font-weight: bold; font-size: 14pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Running the Proxy</h3>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">Running the proxy is as follows:</p>\n<pre>       java ProxyCache <i>port</i>\n</pre>\n<p>where&nbsp;<i>port</i>&nbsp;is the port number on which you want the proxy to listen for incoming connections from clients.</p>\n<h3 style=\"font-weight: bold; font-size: 14pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Configuring Your Browser</h3>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">You will also need to configure your web browser to use your proxy. This depends on your browser. In Internet Explorer, you can set the proxy in \"Internet Options\" in the Connections tab under LAN Settings. In Netscape (and derived browsers, such as Mozilla), you can set the proxy in Edit-&gt;Preferences and then select Advanced and Proxies.</p>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">In both cases you need to give the address of the proxy and the port number which you gave when you started the proxy. You can run the proxy and browser on the same computer without any problems.</p>\n<h2 style=\"font-weight: bold; font-size: 16pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Proxy Functionality</h2>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">The proxy works as follows.</p>\n<ol style=\"font-family: Simsun; line-height: normal; font-size: medium; \">\n    <li>The proxy listens for requests from clients</li>\n    <li>When there is a request, the proxy spawns a new thread for handling the request and creates an HttpRequest-object which contains the request.</li>\n    <li>The new thread sends the request to the server and reads the server's reply into an HttpResponse-object.</li>\n    <li>The thread sends the response back to the requesting client.</li>\n</ol>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">Your task is to complete the code which handles the above process. Most of the error handling in the proxy is very simple and it does not inform the client about errors. When there are errors, the proxy will simply stop processing the request and the client will eventually get a timeout.</p>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">Some browsers also send their requests one at a time, without using parallel connections. Especially in pages with lot of inlined images, this may cause the page to load very slowly.</p>\n<h3 style=\"font-weight: bold; font-size: 14pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Caching</h3>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">Caching the responses in the proxy is left as an optional exercise, since it demands a significant amount of additional work. The basic functionality of caching goes as follows.</p>\n<ol style=\"font-family: Simsun; line-height: normal; font-size: medium; \">\n    <li>When the proxy gets a request, it checks if the requested object is cached, and if yes, then returns the object from the cache, without contacting the server.</li>\n    <li>If the object is not cached, the proxy retrieves the object from the server, returns it to the client, and caches a copy for future requests.</li>\n</ol>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">In practice, the proxy must verify that the cached responses are still valid and that they are the correct response to the client's request. You can read more about caching and how it is handled in HTTP in RFC 2068. For this lab, it is sufficient to implement the above simple policy.</p>\n<h2 style=\"font-weight: bold; font-size: 16pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Programming Hints</h2>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">Most of the code you need to write relates to processing HTTP requests and responses as well as handling Java sockets.</p>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">One point worth noting is the processing of replies from the server. In an HTTP response, the headers are sent as ASCII lines, separated by CRLF character sequences. The headers are followed by an empty line and the response body, which can be binary data in the case of images, for example.</p>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">Java separates the input streams according to whether they are text-based or binary, which presents a small problem in this case. Only DataInputStreams are able to handle both text and binary data simultaneously; all other streams are either pure text (e.g., BufferedReader), or pure binary (e.g., BufferedInputStream), and mixing them on the same socket does not generally work.</p>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">The DataInputStream has a small gotcha, because it is not able to guarantee that the data it reads can be correctly converted to the correct characters on every platform (DataInputStream.readLine() function). In the case of this lab, the conversion usually works, but the compiler will flag the DataInputStream.readLine()-method as deprecated and will refuse to compile without the -deprecation flag.</p>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">It is highly recommended that you use the DataInputStream for reading the response.</p>\n<h2 style=\"font-weight: bold; font-size: 16pt; color: rgb(167, 124, 70); font-family: Arial, sans-serif; line-height: normal; \">Optional Exercises</h2>\n<p style=\"font-size: 10pt; font-family: Arial, sans-serif; line-height: normal; \">When you have finished the basic exercises, you can try the following optional exercises.</p>\n<ol style=\"font-family: Simsun; line-height: normal; font-size: medium; \">\n    <li>Better error handling. Currently the proxy does no error handling. This can be a problem especially when the client requests an object which is not available, since the \"404 Not found\" response usually has no response body and the proxy assumes there is a body and tries to read it.</li>\n    <li>Support for POST-method. The simple proxy supports only GET-method. Add support for POST, by including the request body sent in the POST-request.</li>\n    <li>Add caching. Add the simple caching functionality described above. You do not need to implement any replacement or validation policies. Your implementation will need to be able to write responses to the disk (i.e., the cache) and fetch them from disk when you get a cache hit. For this you need to implement some internal data structure in the proxy to keep track of which objects are cached and where they are on disk. You can keep this data structure in main memory; there is no need to make it persist across shutdowns.</li>\n</ol>\n<hr style=\"font-family: Simsun; line-height: normal; font-size: medium; \">\n<p>&nbsp;</p>\n<p>下载源码与可执行文件：<a href=\"http://www.myfootprints.cn/OldWeb/blog/upload/ProxyCache.rar\" target=\"_blank\">ProxyCache.rar</a></p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}}}},"staticQueryHashes":[],"slicesMap":{}}