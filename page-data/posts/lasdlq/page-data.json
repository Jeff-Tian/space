{"componentChunkName":"component---src-templates-post-js","path":"/posts/lasdlq","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/lasdlq","relativePath":"posts/lasdlq","frontmatter":{"title":"基于 Java Spring Security 的关注微信公众号即登录的设计与实现","stackbit_url_path":"posts/lasdlq","date":"2021-07-26T11:17:25","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<blockquote>\n<p>我的（文章）很长，你忍一下</p>\n</blockquote>\n<p><a name=FpUp2></a></p>\n<h1>太长不看版本</h1>\n<blockquote>\n<p>本文通过一个实际的具有一定商业价值的项目，展示了 API 优先的开发方法。通过薅羊毛的方式，落地了 Free Arch 架构。</p>\n</blockquote>\n<p><a name=eATzJ></a></p>\n<h1>在线演示</h1>\n<p><a href=\"https://wechat-mp.herokuapp.com/login\">https://wechat-mp.herokuapp.com/login</a></p>\n<p><a name=iGEmg></a></p>\n<h1>源代码</h1>\n<p><a href=\"https://github.com/Jeff-Tian/securing-web-with-wechat-mp\">https://github.com/Jeff-Tian/securing-web-with-wechat-mp</a></p>\n<p><a name=Id7z8></a></p>\n<h1>背景和价值</h1>\n<p>通过微信公众号积累粉丝并进行商业活动宣传，是新媒体运营的常见方式。而系统对接微信登录，既能给用户带来便利，同时也能够给系统引流。但是传统或者标准的 PC 网页端微信扫码登录，用户扫码只需要做 OAuth 授权，不必关注公众号。但是对于运营者来说，更希望通过微信登录的用户，自动成为微信粉丝，实现系统中微信用户和公众号粉丝的一一对应。</p>\n<p>所以，关注公众号即登录，将系统的微信用户和公众号粉丝等同起来，方便了运营同学。</p>\n<p>另外，传统的微信扫码登录，需要在公众平台之外，额外再在开发平台申请一个应用，再和公众号做绑定，多了一个账号，就多了一份维护工作，增加了管理者的心智负担，还要多花钱，毕竟两个不同的账号需要单独缴费和认证。</p>\n<p>以及，开发平台和公众平台的 openid 不一样，还需要通过 unionid 的机制做关联，增加了开发的心智负担和开发成本。</p>\n<p>以上，通过关注公众号即登录的方案，都可以避免，和微信打交道的全程只需要 openid 即可。</p>\n<p><a name=LDjMk></a></p>\n<h1>Java Spring-Security</h1>\n<p>Spring Security 是一个专注在 Java 应用中提供认证和授权的框架。和所有 Spring 项目一样，Spring Security 的真正威力在于其极易扩展已满足定制化的需求，为认证和授权提供完整的和可扩展的支持。</p>\n<p><a name=colLc></a></p>\n<h1>Open API</h1>\n<p>Open API 即开放 API，也成为开放平台。它是服务型网站常见的一种应用，网站的服务商将自己的网站服务封装成一系列 API 开放出去，供第三方开发者使用，这种行为就叫做开放网站的 API，所开放的 API 就被称作 Open API。</p>\n<p>Open API 规范始于 Swagger 规范，经过 Reverb Technologies 和 SmartBear 等公司多年的发展，Open API 计划拥有该规范。规范是一种与语言无关的格式，用于描述 Web 服务，应用程序可以解释生成的文件，这样才能生成代码、生成文档并根据其描述的服务创建模拟应用。</p>\n<p>Swagger 的目标是为 API 定义一个标准的，与语言无关的接口，使人和计算机在看不到源码或者看不到文档或者不能通过网络流量检测的情况下能够发现和理解各种服务的功能。当服务通过 Swagger 定义，消费者通过少量的实现逻辑就能与远程服务互动。类似于低级编程接口，Swagger 去掉了调用服务时的很多猜测。</p>\n<p><a name=hUVUY></a></p>\n<h1>关注公众号即登录的流程设计</h1>\n<p>PC 网页站点实现微信登录时，需要通过用户使用微信扫描网页上展示的二维码，然后在手机上的微信授权登录。如何实现二维码的展示，并“感知”用户扫描事件，是需要解决的关键问题。传统的 OAuth 微信扫码登录，由于本质上是打开了一个微信官方的页面，因此不需要关注这其中的细节，但是不通过打开微信官方的页面，就需要自行设计这个展示和感知的能力了。</p>\n<p>常规 PC 网页端微信扫码登录，PC 打开了微信官方的页面，由微信官方展示二维码，而手机扫描后，会在微信端跳出授权页面，用户确认后，微信官方二维码页面会重定向至开发者在开放平台设置好的回调页面，并将临时授权码作为查询字符串；而关注公众号即登录，则利用了微信的带参二维码功能，用户扫描这种二维码后，手机微信会展示开发者的微信公众号，同时将用户信息（主要是 openid）通过服务器端 API 调用，发送给开发者服务器。该过程没有二次确认，对于已关注过公众号的用户，直接发送扫描事件；对于新用户，需要新用户点击关注，才会发送该事件。这里的难点在于如何感知用户的扫描事件，以及保证服务器端 API 调用的安全（主要是确认调用者真的是来自微信而不是伪造的请求）。</p>\n<p>下面通过阐述利用微信的带参二维码，通过接收微信服务器发送的消息来“感知”用户的扫描事件。首先是带参二维码的生成，它是通过调用微信官方的接口完成的。 微信公众平台提供了两种生成带参数二维码的接口，分别是一、临时二维码，有 过期时间，数量没有明确的上限；二、永久二维码，没有过期时间，但是最多只能生成 10 万个。显然，对于登录场景，适合采用临时二维码。本文的方案里， 过期时间设置为 1 分钟。如果用户在打开登录页面的 1 分钟内，都没有扫码，或者因为网络等原因扫码失败，那么就展示二维码过期，提示用户刷新二维码，这个体验和用户登录电脑版微信相似。其中调用生成二维码接口的关键是需要传递场景值，每个场景值会和一个尝试登录的请求相关，因此必须做到唯一。本文选择使用 UUID（或者称为 GUID）。UUID 由 128 位数字组成，其生成算法保证了 其极低的重复率，具体地说，如果以一秒钟生成十亿个 UUID 的速度连续生成一年，才会有 50%的机会产生一个重复 ID。下图为未登录用户成功扫码登录系统的流程图。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627268290142-1df9c221-0cca-4962-be6a-db6b32d3b8bb.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;id=u4d349a94&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=594&#x26;originWidth=884&#x26;originalType=binary%E2%88%B6=1&#x26;size=134330&#x26;status=done&#x26;style=none&#x26;taskId=u0d1f4339-f72e-4a6d-af12-bcc77db3995\" alt=\"image.png\"><br />由上图可以看出，开发者服务为尝试登录请求生成场景值后，会同时传递给微信服务和浏览器。这个场景值还会被后续查询用户扫描状态时被使用。如果用户不扫描，致使二维码过期，那么这个场景值将会被丢弃，被认为该尝试登录失败。从上图还可以看出，当用户扫描后，微信会自动进入开发者公众号页面，这为运营提供了很大的好处，因为公众号页面会展示历史图文信息，相比传统的用 户扫码后，展示的信息要丰富得多。另外可以看到，无论用户是否关注过公众号， 扫码后，微信服务都会向开发者服务推送用户的 openid 以及场景值。而且对于没有关注过公众号的新用户，还会自动关注，成为公众号新粉丝。这样就把系统 的微信用户账号和微信公众号分析的属性关联了起来。场景值被系统用来更新扫码状态，而 openid 用来关联或者创建账号。这一系列动作完成后，系统还可以通 过微信渠道向用户发送自定义的欢迎信息，这是传统微信登录方式很难做到的 （需要实现模板消息功能，但是模板消息的使用是受到严格监控和限制的，而在扫码后的消息回复则不受此限）。</p>\n<p>其次是扫码状态的更新，当开发者服务器收到微信服务生成的二维码后，就 处于等待用户扫码的阶段，当收到微信服务通知用户扫码成功或者超时，开发者服务器应该通知用户端。因此这里需要一个即时消息服务。其状态转移如下图所示，一共有三种状态：一、扫码成功，收到微信服务通知的用户 openid，场景值；二、扫码失败，收到微信服务通知的失败原因；三、扫码超时，一段时 间没有收到微信服务的通知。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627268383765-af56cc97-80e9-409f-9918-41a6bb622982.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;id=u6208b7ea&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=240&#x26;originWidth=392&#x26;originalType=binary%E2%88%B6=1&#x26;size=31941&#x26;status=done&#x26;style=none&#x26;taskId=u2a9901d0-4e45-4ddc-aac4-081685be5a1\" alt=\"image.png\"><br />开发者服务器端接收到微信服务通知或者超时后，需要通知客户端，一般有 三种技术方案，即轮询、长连接以及 Socket IO。由于普通轮询为了保持实时性， 会在短时间内发送大量的 HTTP 请求，不可取。而 Socket IO 实现较复杂，并且对服务器资源消耗过大，因此长连接方案是最适合的。在这种方案下，客户端向服务器端发送请求询问扫码状态，服务器只在扫码成功或者超时的情况下给予回应，其他情况会挂起连接。因此在超时前，一个客户端只会向服务器端发送一个查询请求，有效地减轻了服务器端连接压力。这里开发者服务会接受到客户端查询扫码状态和微信服务通知扫码结果的 HTTP 请求，两个请求到达的次序有可能 不同，在实现时需要注意。下面给出时序图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627268459815-96f7da38-bb33-4c2f-9689-bec77bfd2260.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;id=udce966e2&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=908&#x26;originWidth=914&#x26;originalType=binary%E2%88%B6=1&#x26;size=274297&#x26;status=done&#x26;style=none&#x26;taskId=u704369cf-8b86-4435-ad57-1edb30bd4ba\" alt=\"image.png\"><br />从上面的时序图可以看出，只需要对情况一进行查询请求的挂起。另外，向客户端返回扫码结果后，一定要将缓存记录清除，一方面更加安全，对重放的请求，因为查询不到扫码记录会直接回复超时；另一方面，可以及时释放内存，节省不必要的资源开销。由于生产环境往往不止单个应用实例，扫码状态需要缓存在独立于应用的缓存服务中，后续查询请求即使被另外的应用实例处理，也能返回正确的状态。当开发者服务收到扫码成功的结果后，就可以将微信的 openid 作 为第三方登录的 id，与自己的用户数据库中的用户做关联了。由于采用了关注公 众号即登录的流程，不再额外需要申请和维护微信开放平台账号，也不再需要处理 unionid 的映射。</p>\n<p>本节通过仔细研究微信公众号的开放 API 能力，梳理了一套非常规的微信扫码登录方案，通过严谨分析客户端、开发者服务和微信服务三者间的 HTTP 沟通时序，实现了对用户微信扫码的感知能力，为最终实现关注公众号即登录打下了可行性基础。</p>\n<p><a name=jeHs9></a></p>\n<h1>应用架构设计</h1>\n<p>演示应用（<a href=\"https://wechat-mp.herokuapp.com/login\">https://wechat-mp.herokuapp.com/login</a>）的架构图大致如下，基本遵从 Free Arch（杜撰，免费架构），在保证工作的前提下节省成本。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627285459749-91393e16-8a70-44b9-a530-df8b98957925.png#clientId=u4d7351e8-4184-4&#x26;from=ui&#x26;id=u6fb53350&#x26;margin=%5Bobject%20Object%5D&#x26;name=Untitled.png&#x26;originHeight=552&#x26;originWidth=1109&#x26;originalType=binary%E2%88%B6=1&#x26;size=61503&#x26;status=done&#x26;style=none&#x26;taskId=ub56c770b-a932-4ef7-8ed4-2298727983b\" alt=\"Untitled.png\"></p>\n<p>即通过 Cloudflare，使用免费的网络防火墙服务。对于要实现的 Java Spring-Security 应用，部署在 Heroku 这个 PaaS 平台上，也是免费的。对于微信服务，我们使用微信官方提供的测试号，也是免费的。但是对于测试公众号，有个限制是只能有 100 个关注者。但是对于演示来说足够用了，相信本文的阅读量不会超过 100，如果超过，甚至还有打赏，产生了收入，那我就去注册一个真正的公众号！</p>\n<p>在流程设计上提到对于扫码状态的查询，需要长链接以等待微信消息通知，至于微信发过来的消息存储方面，可以采用 Redis，也可以使用消息队列。对于 Redis 方案，也有对应的免费服务，但是本文采用了消息队列来实现，消息队列使用了 Pulsar，跟上时代。Pulsar 号称是下一代的消息队列方案，比 Kafka 有过之而无不及。为了节省成本，采用了免费的 Pulsar as a service：<a href=\"https://kesque.com/\">https://kesque.com/</a></p>\n<p>关于使用 Redis 的方案，详见这篇文章：《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现</a>》。</p>\n<p><a name=mi8JK></a></p>\n<h1>API first 开发方式</h1>\n<p>应用程序向云环境这一演变趋势为更好地集成服务和增加代码重用提供了机会，只要拥有一个接口，然后通过该接口，其他服务的应用程序就可以与你的应用程序进行交互，这是向其他人公开你的功能，但是，开发 API 不应该是在开发后才公开功能。</p>\n<p>API 文档应该是构建应用程序的基础，这个原则正式 API first 开发的全部内容。你需要设计和创建描述新服务与外部世界之间交互的文档，一旦建立了这些交互，就可以开发代码逻辑来支持这些交互。它的好处是：</p>\n<ul>\n<li>团队在开发过程中更快地开始彼此交互。API 文档是应用程序与使用它的人之间的合同。</li>\n<li>内部开发可以在 API 合同背后进行，而不会干扰使用它的人的努力，计划使用你的应用程序的团队可以使用 API 规范来了解如何与你的应用程序进行交互，甚至在开发前，他们还可以使用文档创建用于测试其他应用程序的虚拟服务。</li>\n</ul>\n<p><a name=HP3u0></a></p>\n<h1>基于 Java Spring Security 的关注公众号即登录的实现及其关键代码</h1>\n<p>促销服务企业基本都会通过微信公众平台与用户互动，但是微信公众平台的限制在于，公众号不能主动找到用户和向用户主动发消息的，而只有用户主动先 关注公众号成为其粉丝，才能有互动的可能。用户扫码并关注微信公众号，是在手机端完成的。如何从应用层面“感知”到用户的操作，是实现中的主要难点。 同时，开发者服务层本身是无状态的，但是扫码流程又是有状态流转的，所以需要解决状态存储的问题。另外，开发者服务层需要同时与微信服务和前端页面打交道，这个过程中会有设计用户敏感信息的发送与接收，如何保证和验证数据来源的可信性和安全性就成了必须要考虑的问题。在具体实现前，需要申请微信公众号，并配置好相关参数。由于存在开发者服务和微信服务之间的消息传送，所以还需要在公众号后台配置好开发者服务接收消息的 URL，并同时配置好密钥字符串，微信服务发送消息是会使用这个密钥字符串对消息加密，并且只发送到开发者配置的 URL，同时这个 URL 必须为 https 协议的，这样即使数据包被第 三方截获，也不能做任何改动，如果将数据包转发，则接收方可以识别出消息已被篡改拒绝接收，由于采用了开发者配置的密钥加密了消息，因此第三方基本无法破译，从而保证了消息的安全。同时，还需要将从公众号后台获取的 AppID 和 AppSecret 配置到开发者服务（即本系统）中。</p>\n<p>整体上看，要实现微信登录就需要拿到用户在微信端的唯一标志符 openid， 查找用户数据库看是否存在该用户，有的话直接登录，否则注册后登录。而要拿到用户的 openid，一般做法是通过微信网页的 OAuth 授权，但是缺点是不能给公众号引流。关注公众号即登录功能在统一移动端和桌面端的微信登录用户体验、 便利用户运营都起了非常重要的作用，可以增加微信粉丝、发送登录后消息等等。 要实现的功能目标是去除对微信开放平台的依赖，减少用户二次点击。因为已经有微信公众平台，所以系统应该尽量利用公众平台完成一切和微信相关的交互， 而用户主动扫码，已经是一个确认的行为，减少一次额外的点击，使得登录行为更加流畅。有上述功能目标分析，再结合流程设计中介绍的浏览器、开发者服务以及微信服务的交互流程可知，要拿到用户的 openid，只需用户扫码带参二维码， 用户扫码后会被导流到公众号。同时，如果用户关注公众号，或者已经关注过该 公众号，那么微信服务层会给开发这服务层发送用户的 openid 消息。所以要实现关注公众即登录，就要实现<strong>参数场景值的生成</strong>、<strong>扫码状态存储</strong>、<strong>状态查询</strong>、<strong>消息收发的安全性</strong>等这几个关键点。</p>\n<p><a name=TAnCE></a></p>\n<h2>定义 API</h2>\n<p>使用 API 优先的方式开发，那么先定义一下接口。采用 Swagger 的 Yaml 格式，去 <a href=\"https://app.swaggerhub.com/\">https://app.swaggerhub.com/</a> 使用 Github 登录，即可免费使用 Swagger Hub 的服务，既可以作为对外文档，又可以直接使用现成的模拟服务。定义好的文档见：<a href=\"https://app.swaggerhub.com/apis/UniHeart/wechat-mp/0.0.1\">https://app.swaggerhub.com/apis/UniHeart/wechat-mp/0.0.1</a></p>\n<p>从 paths 字段可以看到一共定义了 3 个接口：</p>\n<ul>\n<li>/mp-qr：用来展示二维码，并实现参数场景值的生成</li>\n<li>/mp-qr-scan-status： 用来查询二维码扫码状态</li>\n<li>/mp-message： 用来接收微信服务发来的消息，并将其保存至消息队列，存储扫码状态，并要保证消息的确来自微信服务</li>\n</ul>\n<p>使用 Swagger 定义开放 API 的好处之一是 Schema 支持，这个定义在 components 字段的 schemas 下，完整的 Swagger 文档是：</p>\n<p>yaml\nopenapi: 3.0.0\ninfo:\nversion: 0.0.1\ntitle: Authenticate with Wechat MP!\nservers:</p>\n<h1>Added by API Auto Mocking Plugin</h1>\n<ul>\n<li>description: SwaggerHub API Auto Mocking\nurl: <a href=\"https://virtserver.swaggerhub.com/UniHeart/wechat-mp/0.0.1\">https://virtserver.swaggerhub.com/UniHeart/wechat-mp/0.0.1</a></li>\n<li>url: <a href=\"http://localhost:8080\">http://localhost:8080</a></li>\n</ul>\n<p>paths:\n/mp-qr:\nget:\nsummary: Gets a temporary qr code with parameter\noperationId: mp-qr-url\ntags:\n- mp-qr\nresponses:\n200:\ndescription: Got the temporary qr code image link\ncontent:\napplication/json:\nschema:\n$ref: #/components/schemas/MpQR\nexample:\nexpire_seconds: 60\nimageUrl: <a href=\"https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQGT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAycnE3QWw3b3JmazMxb2FMQnh3Y1UAAgTOrmVgAwQ8AAAA\">https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQGT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAycnE3QWw3b3JmazMxb2FMQnh3Y1UAAgTOrmVgAwQ8AAAA</a>\nsceneId: 66afab27-c8fa-417d-a28a-95d5a977e1d3\nticket: gQGT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAycnE3QWw3b3JmazMxb2FMQnh3Y1UAAgTOrmVgAwQ8AAAA\nurl: <a href=\"http://weixin.qq.com/q/02rq7Al7orfk31oaLBxwc\">http://weixin.qq.com/q/02rq7Al7orfk31oaLBxwc</a>\n/mp-qr-scan-status:\nget:\nsummary: Get the scanning status of qr code\noperationId: mp-qr-scan-status\ntags:\n- mp-qr\nparameters:\n- in: query\nname: ticket\nrequired: true\ndescription: the ticket for the qr code to query scanning status\nschema:\ntype: string\nexample: gQE48DwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyb2U4U2wwb3JmazMxcS1kQ3h3YzgAAgSCjWZgAwQ8AAAA\nresponses:\n200:\ndescription: The scanning stqtus of qr code\ncontent:\napplication/json:\nschema:\n$ref: #/components/schemas/MpQRScanStatus\nexample:\nopenId: oWFvUw5ryWycy8XoDCy1pV0SiB58\nstatus: SCANNED\n/mp-message:\npost:\nsummary: Receive xml messages sent from wechat mp server\noperationId: mp-message\ntags:\n- mp-qr\nrequestBody:\ndescription: wechat mp messages in xml format\nrequired: true\ncontent:\napplication/xml:\nschema:\n$ref: #/components/schemas/xml\nresponses:\n200:\ndescription: the message was well received</p>\n<p>components:\nschemas:\nMpQR:\ntype: object\nproperties:\nexpire_seconds:\ntype: integer\nformat: int64\nexample: 60\nimageUrl:\ntype: string\nexample: <a href=\"https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQGT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAycnE3QWw3b3JmazMxb2FMQnh3Y1UAAgTOrmVgAwQ8AAAA\">https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQGT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAycnE3QWw3b3JmazMxb2FMQnh3Y1UAAgTOrmVgAwQ8AAAA</a>\nsceneId:\ntype: string\nexample: 66afab27-c8fa-417d-a28a-95d5a977e1d3\nticket:\ntype: string\nexample: gQGT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAycnE3QWw3b3JmazMxb2FMQnh3Y1UAAgTOrmVgAwQ8AAAA\nurl:\ntype: string\nexample: <a href=\"http://weixin.qq.com/q/02rq7Al7orfk31oaLBxwc\">http://weixin.qq.com/q/02rq7Al7orfk31oaLBxwc</a>\nMpQRScanStatus:\ntype: object\nproperties:\nopenId:\ntype: string\nexample: oWFvUw5ryWycy8XoDCy1pV0SiB58\nstatus:\ntype: string\nexample: SCANNED\nxml:\ntype: object\nproperties:\nToUserName:\ntype: string\nexample: oWfv\nFromUserName:\ntype: string\nexample: 1234\nCreateTime:\ntype: number\nexample: 1357290913\nMsgType:\ntype: string\nexample: Text\nEvent:\ntype: string\nexample: subscribe\nEventKey:\ntype: string\nexample: qrscene_123123\nTicket:\ntype: string\nexample: TICKET</p>\n<p><a name=wC5cx></a></p>\n<h2>创建工程</h2>\n<p>通过官网的指引，即可创建出一个 Spring Security 模版工程，创建好后，在 build.gradle 文件中，增加一些依赖，主要有</p>\n<ul>\n<li>implementation io.swagger.parser.v3:swagger-parser:2.0.20 和 implementation org.springdoc:springdoc-openapi-ui:1.5.2<br />用来对接预先定义好的 API 文档，并自动生成相关代码</li>\n<li>implementation org.openapitools:jackson-databind-nullable:0.2.1<br />用来处理 json 反/序列化时的 null 值</li>\n<li>implementation com.fasterxml.jackson.core:jackson-databind:2.10.0 和 implementation com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.10.1<br />用来处理 xml，因为微信服务发送过来的消息是 XML 格式的，而 Spring 工程默认是不会解析 XML 的 payload 的。如果不加入这个依赖，会导致接受消息的 controller 报 415 方法不允许的错误。</li>\n</ul>\n<p>题外话，关于这个 415 错误，一定要往 Request Body 的解析上定位，否则你会浪费不必要的时间去找原因，比如这位同学：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627289622006-8f3939a9-8539-4e9c-a5fc-14ef01a48037.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;height=495&#x26;id=u87a0b57c&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=990&#x26;originWidth=1030&#x26;originalType=binary%E2%88%B6=1&#x26;size=259987&#x26;status=done&#x26;style=none&#x26;taskId=u98d9344a-7e1a-4dbf-ab98-655c8e2f20b&#x26;width=515\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627289587157-636f6792-b3bf-4e21-98f4-9be749e8bac0.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;height=69&#x26;id=u7bc31b91&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=138&#x26;originWidth=1962&#x26;originalType=binary%E2%88%B6=1&#x26;size=153696&#x26;status=done&#x26;style=none&#x26;taskId=u9c12eb75-acdb-4824-80e7-23f82739de2&#x26;width=981\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627289662095-2b619808-f425-4163-b227-2db2293d6bba.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;height=482&#x26;id=ua955379f&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=964&#x26;originWidth=998&#x26;originalType=binary%E2%88%B6=1&#x26;size=219530&#x26;status=done&#x26;style=none&#x26;taskId=ua951d127-4a91-4009-80db-f801cc2f1cf&#x26;width=499\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627289677743-0a23336d-1e1c-4785-8178-6214c14db69e.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;height=132&#x26;id=u5efeecbc&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=264&#x26;originWidth=1002&#x26;originalType=binary%E2%88%B6=1&#x26;size=63024&#x26;status=done&#x26;style=none&#x26;taskId=uac8bcde4-c852-4ef7-ae11-ab863e3d460&#x26;width=501\" alt=\"image.png\"></p>\n<ul>\n<li>implementation org.apache.pulsar:pulsar-client:2.6.3<br />用来和 pulsar 打交道</li>\n</ul>\n<p>然后再在 build.gradle 文件里添加一个任务，用来根据最新的 Swagger 文档生成相关的类型代码等：</p>\n<p>groovy</p>\n<p>// generates the spring controller interfaces from openapi spec in src/main/resources/service.yaml\nopenApiGenerate {\ngeneratorName = spring\ninputSpec = $projectDir/swagger-output/swagger.yaml\noutputDir = $buildDir/generated\napiPackage = com.uniheart.wechatmpservice.api\ninvokerPackage = com.uniheart.wechatmpservice\nmodelPackage = com.uniheart.wechatmpservice.models\nconfigOptions = [\ndateLibrary: java8,\ninterfaceOnly: true,\n]\n}</p>\n<p>这样每次文档有更新，就只需要在项目目录下跑一下命令：</p>\n<p>shell\n./gradlew openApiGenerate</p>\n<p>注意，我们采用了 Swagger Hub 来更新 API 文档，它有个 Sync 功能，可以在每次文档改动后点击一下，就会自动提交一个改动推送到你的 git 仓库。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627290659919-718d00d8-b618-4994-a367-53623e34c6e7.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;height=698&#x26;id=u02a7c7a0&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1396&#x26;originWidth=1902&#x26;originalType=binary%E2%88%B6=1&#x26;size=322364&#x26;status=done&#x26;style=none&#x26;taskId=ued12d1d2-fcbe-4161-857e-21085e07687&#x26;width=951\" alt=\"image.png\"></p>\n<p>由于使用了 swagger 相关的依赖，它自带了 Swagger UI，所以即使在不能访问 Swagger Hub 的情况下，也可以直接访问项目本身 Host 的 Swagger UI：<a href=\"https://wechat-mp.herokuapp.com/swagger-ui\">https://wechat-mp.herokuapp.com/swagger-ui</a> 。通过 swagger.json，你还可以将你的项目文档直接同步到 YAPI 或者 Backstage 等 API 管理工具或者 dev portal 上。这个 json 可以直接从项目中实时获得：<a href=\"https://wechat-mp.herokuapp.com/v3/api-docs\">https://wechat-mp.herokuapp.com/v3/api-docs</a>。</p>\n<p><a name=vqVyX></a></p>\n<h2>配置路由</h2>\n<p>Spring-Security 项目模版默认做了一些配置，我们需要额外添加几个，主要是放通我们的 API，以及 swagger 相关的路由，这在 WebSecurityConfig 里完成，主要代码如下：</p>\n<p>java\npackage com.uniheart.securing.web.wechat.mp;</p>\n<p>import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.provisioning.InMemoryUserDetailsManager;</p>\n<p>@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\nhttp\n.authorizeRequests()\n.antMatchers(/, /home).permitAll()\n.antMatchers(/mp-qr, /mp-qr).permitAll()\n.antMatchers(/mp-qr-scan-status, /mp-qr-scan-status).permitAll()\n.antMatchers(HttpMethod.POST, /mp-message).permitAll()\n.antMatchers(/v3/api-docs, /v3/api-docs).permitAll()\n.antMatchers(/swagger-ui, /swagger-ui).permitAll()\n.anyRequest().authenticated()\n.and()\n.formLogin()\n.loginPage(/login)\n.permitAll()\n.and()\n.logout()\n.permitAll();</p>\n<pre><code>    http.csrf().disable();\n}\n</code></pre>\n<p>}</p>\n<p><a name=xG7KG></a></p>\n<h2></h2>\n<p><a name=sQPX7></a></p>\n<h2>实现二维码的展示</h2>\n<p>本示例应用效果是登录页面除了可以输入用户名和密码登录外，还会显示一个二维码，扫码后即登录成功，并且在页面上显示一个欢迎信息：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627291505855-708ca7fe-5ca7-4f4e-8497-d078bf139344.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;height=641&#x26;id=ua46df7dd&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1282&#x26;originWidth=2082&#x26;originalType=binary%E2%88%B6=1&#x26;size=355106&#x26;status=done&#x26;style=none&#x26;taskId=ucfd631c6-0725-45b3-b581-6877ccfcf3c&#x26;width=1041\" alt=\"image.png\"><br />扫码登录成功后，可以看到 Cookie 多了一个 JSESSIONID 项：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1627291663613-edc40dfb-97fb-439b-909a-710dc69e8d36.png#clientId=u4d7351e8-4184-4&#x26;from=paste&#x26;height=467&#x26;id=ufb41f929&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=934&#x26;originWidth=2212&#x26;originalType=binary%E2%88%B6=1&#x26;size=233680&#x26;status=done&#x26;style=none&#x26;taskId=uf4b8c76c-4408-4570-a58f-64977bf499b&#x26;width=1106\" alt=\"image.png\"><br />要实现二维码的展示，由于采用了 Swagger 生成轮廓代码，这里只需要添加一个新的 Controller 去实现预先定义好的 MpQrApi 即可：</p>\n<p>java\npackage com.uniheart.securing.web.wechat.mp;</p>\n<p>import com.uniheart.securing.web.wechat.mp.services.MpServiceBean;\nimport com.uniheart.wechatmpservice.api.MpQrApi;\nimport com.uniheart.wechatmpservice.models.MpQR;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RestController;</p>\n<p>@RestController\npublic final class WechatMpApiController implements MpQrApi {\n@Autowired\nprivate MpServiceBean mpServiceBean;</p>\n<pre><code>@Override\npublic ResponseEntity&#x3C;MpQR> mpQrUrl() {\n    return new ResponseEntity&#x3C;>(this.mpServiceBean.getMpQrCode(), HttpStatus.OK);\n}\n</code></pre>\n<p>}</p>\n<p>可见核心业务逻辑在 MpServiceBean 中，代码如下：</p>\n<p>java\npackage com.uniheart.securing.web.wechat.mp.services;</p>\n<p>import com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport com.uniheart.securing.web.wechat.mp.Constants;\nimport com.uniheart.wechatmpservice.models.MpQR;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;</p>\n<p>import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.UnknownFormatConversionException;</p>\n<p>@Component\npublic class MpServiceBean {\nprivate final HttpClient httpClient;</p>\n<pre><code>@Value(${weixin-qr-code-creation-endpoint:default-test-value})\nprivate String qrCodeCreateUrl;\n\n@Value(${weixin-token-endpoint:default-test-value})\nprivate String weixinAccessTokenEndpoint;\n\npublic String getQrCodeCreateUrl() {\n    return this.qrCodeCreateUrl;\n}\n\npublic MpServiceBean() {\n    this.httpClient = HttpClient.newHttpClient();\n}\n\npublic MpServiceBean(HttpClient client, String qrCodeCreateUrl, String tokenEndpoint) {\n    this.httpClient = client;\n    this.qrCodeCreateUrl = qrCodeCreateUrl;\n    this.weixinAccessTokenEndpoint = tokenEndpoint;\n}\n\npublic void setQrCodeCreateUrl(String url) {\n    this.qrCodeCreateUrl = url;\n}\n\npublic void setWeixinAccessTokenEndpoint(String url) {\n    this.weixinAccessTokenEndpoint = url;\n}\n\nLogger logger = LoggerFactory.getLogger(MpServiceBean.class);\n\npublic MpQR getMpQrCode() {\n    var mpTokenManager = new MpTokenManager(this.weixinAccessTokenEndpoint);\n\n    URI uri = URI.create(this.qrCodeCreateUrl + mpTokenManager.getAccessToken().accessToken);\n\n    logger.info(Getting qr code with  + uri);\n\n    var payload = WeixinQrCodeRequestPayload.getRandomInstance();\n\n    HttpRequest request =\n            HttpRequest.newBuilder().POST(HttpRequest.BodyPublishers.ofString(payload.toJson())).uri(uri).build();\n\n    try {\n        HttpResponse&#x3C;String> response = this.httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        WeixinErrorResponse errorResponse = new Gson().fromJson(response.body(), WeixinErrorResponse.class);\n        WeixinTicketResponse ticketResponse = new Gson().fromJson(response.body(), WeixinTicketResponse.class);\n\n        if (ticketResponse.ticket != null) {\n            return new MpQR().ticket(ticketResponse.ticket).imageUrl(ticketResponse.url).expireSeconds(ticketResponse.expiresInSeconds).url(ticketResponse.url).sceneId(String.valueOf(payload.action_info.scene.scene_id));\n        }\n\n        if (errorResponse.errcode == (40001)) {\n            return new MpQR().ticket(test).imageUrl(Constants.FALLBACK_QR_URL);\n        }\n\n        throw new UnknownFormatConversionException(response.body());\n    } catch (InterruptedException ie) {\n        System.err.println(Exception =  + ie);\n        ie.printStackTrace();\n\n        return new MpQR().ticket(interrupted).imageUrl(Constants.FALLBACK_QR_URL);\n    } catch (Exception ex) {\n        System.err.println(Exception =  + ex);\n        ex.printStackTrace();\n        return new MpQR().ticket(error).imageUrl(Constants.FALLBACK_QR_URL);\n    }\n}\n</code></pre>\n<p>}</p>\n<p>代码比较长，不逐行解释了，建议对照项目中的测试代码一起看，主要是调用微信的 API，并根据响应走到不同的逻辑分支。以上的关键在于 WeixinQrCodeRequestPayload.getRandomInstance()，会生成场景值。场景值以及带参二维码，因为每个登录请求尝试都是独立发生的， 所以应该是全局唯一；为了防止恶意者攻击，这个场景值应该具有不可猜性。前面介绍其可以使用 UUID 来满足这两点，参见《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现</a>》的具体实现，这里给出一种简便的实现，即根据当前时间来计算出一个场景值，由于精确到纳秒，所以很难重复。</p>\n<p>java\npackage com.uniheart.securing.web.wechat.mp.services;</p>\n<p>import com.google.gson.Gson;\nimport com.uniheart.securing.web.wechat.mp.Now;\nimport org.joda.time.Instant;</p>\n<p>public class WeixinQrCodeRequestPayload {\npublic String action_name;\npublic ActionInfo action_info;\npublic int expire_seconds;</p>\n<pre><code>public String toJson() {\n    return new Gson().toJson(this);\n}\n\npublic static WeixinQrCodeRequestPayload getRandomInstance() {\n    var timestamp = Now.instant();\n\n    var ret = new WeixinQrCodeRequestPayload();\n    ret.action_name = QR_SCENE;\n    ret.expire_seconds = 604800;\n    ret.action_info = new ActionInfo();\n    ret.action_info.scene = new Scene();\n    ret.action_info.scene.scene_id = timestamp.getEpochSecond() + timestamp.getNano();\n\n    return ret;\n}\n</code></pre>\n<p>}</p>\n<p>class ActionInfo{\npublic Scene scene;\n}</p>\n<p>class Scene {\npublic long scene_id;\n}</p>\n<p><a name=FIUAX></a></p>\n<h2>实现微信消息的接收</h2>\n<p>消息接收后还需要存储起来，Redis 方案的实现详见《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现</a>》，这里给出利用 pulsar 的具体实现。</p>\n<p>java\npackage com.uniheart.securing.web.wechat.mp.services;</p>\n<p>import com.google.gson.Gson;\nimport com.uniheart.wechatmpservice.models.Xml;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.apache.pulsar.client.api.*;\nimport org.springframework.stereotype.Component;</p>\n<p>import java.util.concurrent.TimeUnit;</p>\n<p>@Component\npublic class MpMessageService {\nLogger logger = LoggerFactory.getLogger(MpMessageService.class);</p>\n<pre><code>private final String pulsarUrl;\nprivate final String pulsarToken;\nprivate final String pulsarTopic;\n\npublic MpMessageService(@Value(${pulsar-service-url}) String pulsarUrl, @Value(${pulsar-auth-token}) String pulsarToken, @Value(${pulsar-producer-topic}) String pulsarTopic) {\n    this.pulsarUrl = pulsarUrl;\n    this.pulsarToken = pulsarToken;\n    this.pulsarTopic = pulsarTopic;\n}\n\npublic void saveMessageTo(Xml message) throws PulsarClientException {\n    var client = PulsarClient.builder().serviceUrl(pulsarUrl).authentication(AuthenticationFactory.token(pulsarToken)).build();\n    var producer = client.newProducer().topic(pulsarTopic).create();\n    producer.send(new Gson().toJson(message).getBytes());\n    producer.close();\n    client.close();\n}\n\npublic synchronized Xml getMessageFor(String ticket) throws PulsarClientException {\n    var client = PulsarClient.builder().serviceUrl(pulsarUrl).authentication(AuthenticationFactory.token(pulsarToken)).build();\n    var consumer = client.newConsumer().topic(pulsarTopic).subscriptionName(my-subscription).subscribe();\n    var xml = new Xml().fromUserName(empty);\n\n    var received = false;\n\n    var count = 0;\n\n    do {\n        var msg = consumer.receive(1, TimeUnit.SECONDS);\n        count++;\n        if (msg != null) {\n            var json = new String(msg.getData());\n\n            try {\n                xml = new Gson().fromJson(json, Xml.class);\n\n                received = xml.getTicket().equals(ticket);\n\n                if(received){\n                    consumer.acknowledge(msg);\n                }\n            } catch (Exception ex) {\n                logger.error(Failed to parse json:  + json);\n                xml.fromUserName(json);\n\n                consumer.acknowledge(msg);\n            }\n        }\n    } while (!received &#x26;&#x26; count &#x3C; 30);\n\n    consumer.close();\n    client.close();\n\n    return xml;\n}\n</code></pre>\n<p>}</p>\n<p>以上服务封装了保存和获取方法，消息接收的 Controller 调用起保存消息的方法：</p>\n<p>java\npackage com.uniheart.securing.web.wechat.mp;</p>\n<p>import com.uniheart.securing.web.wechat.mp.services.MpMessageService;\nimport com.uniheart.wechatmpservice.api.MpMessageApi;\nimport com.uniheart.wechatmpservice.models.Xml;\nimport io.swagger.annotations.ApiParam;\nimport org.apache.pulsar.client.api.PulsarClientException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;</p>\n<p>import javax.validation.Valid;</p>\n<p>@RestController\npublic class WechatMessageController implements MpMessageApi {\nLogger logger = LoggerFactory.getLogger(WechatMessageController.class);</p>\n<pre><code>private final MpMessageService mpMessageService;\n\npublic WechatMessageController(MpMessageService mpMessageService) {\n    this.mpMessageService = mpMessageService;\n}\n\n@Override\npublic ResponseEntity&#x3C;Void> mpMessage(@ApiParam(value = wechat mp messages in xml format, required = true) @Valid @RequestBody Xml xml) {\n    try {\n        this.mpMessageService.saveMessageTo(xml);\n        logger.info(saved info:  + xml);\n        return new ResponseEntity&#x3C;>(HttpStatus.OK);\n    } catch (PulsarClientException e) {\n        e.printStackTrace();\n        return new ResponseEntity&#x3C;>(HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n</code></pre>\n<p>}</p>\n<p><a name=mEiky></a></p>\n<h2>实现扫码状态查询</h2>\n<p>从以上实现可以看出，接收到微信服务的消息通知后，会同时保存两个信息，即保存被扫描的二维码对应的用户标识 openid，以及更新该二维码的扫码状态为已扫描。这个消息很重要，如前所述， 我们对客户端的扫码状态查询请求使用了长连接方案。查询扫码状态的部分比较复杂，因为这里把将用户登录的逻辑也放在这里了。即查询到对应的二维码被扫描后，在返回扫码成功前，新建一个 HTTP 上下文，将登录的用户实例化出来：</p>\n<p>java\npackage com.uniheart.securing.web.wechat.mp;</p>\n<p>import com.uniheart.securing.web.wechat.mp.services.MpMessageService;\nimport com.uniheart.wechatmpservice.api.MpQrScanStatusApi;\nimport com.uniheart.wechatmpservice.models.MpQRScanStatus;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.bind.annotation.RestController;</p>\n<p>import java.security.Principal;\nimport java.util.ArrayList;\nimport java.util.List;</p>\n<p>@RestController\npublic final class WechatMpQRScanStatusApiController implements MpQrScanStatusApi {\nprivate final MpMessageService mpMessageService;</p>\n<pre><code>public WechatMpQRScanStatusApiController(MpMessageService mpMessageService) {\n    this.mpMessageService = mpMessageService;\n}\n\n@Override\npublic ResponseEntity&#x3C;MpQRScanStatus> mpQrScanStatus(String ticket) {\n    try {\n        var xml = this.mpMessageService.getMessageFor(ticket);\n\n        if(xml.getFromUserName().equals(empty)){\n            return new ResponseEntity&#x3C;>(new MpQRScanStatus().openId(), HttpStatus.REQUEST_TIMEOUT);\n        }\n\n        var user = new Object() {};\n\n        List&#x3C;GrantedAuthority> authorities = new ArrayList&#x3C;>();\n        authorities.add(new SimpleGrantedAuthority(WechatMP));\n\n\n        Authentication authentication = new UsernamePasswordAuthenticationToken(user, null, authorities);\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n\n        return new ResponseEntity&#x3C;>(new MpQRScanStatus().openId(xml.getFromUserName()).status(SCANNED), HttpStatus.OK);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        return new ResponseEntity&#x3C;>(new MpQRScanStatus().openId(ex.getMessage()), HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n</code></pre>\n<p>}</p>\n<p>这样就实现了服务器端的三个开放 API。服务器端还有些逻辑，比如对微信的 Access Token 的管理等等，再次略过，详见 Github 仓库：<a href=\"https://github.com/Jeff-Tian/securing-web-with-wechat-mp/tree/master/src/main/java/com/uniheart/securing/web/wechat/mp/services\">https://github.com/Jeff-Tian/securing-web-with-wechat-mp/tree/master/src/main/java/com/uniheart/securing/web/wechat/mp/services</a> 。</p>\n<p><a name=sHumr></a></p>\n<h2>实现客户端逻辑</h2>\n<p>服务器端的 API，最终要由客户端来调用，这里的客户端逻辑，为了实现最小代码改动，直接写了原生 JavaScript 添加在了模版项目的 html 文件里（login.html），没有使用任何前端工程框架，直接手写了两个 ajax，完成：</p>\n<p>javascript\nfunction queryScanStatus(ticket) {\nvar req = new XMLHttpRequest();</p>\n<pre><code>        req.onreadystatechange = function () {\n            if(req.readyState === 4 &#x26;&#x26; req.status === 200) {\n                const json = JSON.parse(req.responseText);\n\n                if (json.status === SCANNED) {\n                    location.href = /hello;\n                }else{\n                    alert(发生错误（也许是超时了）！)\n                }\n            }\n        };\n\n        req.open(GET, /mp-qr-scan-status?ticket= + ticket);\n        req.send();\n    }\n\n    function showQRCodeImage() {\n        var req = new XMLHttpRequest();\n        req.onreadystatechange = function () {\n            if (req.readyState === 4 &#x26;&#x26; req.status === 200) {\n                const json = JSON.parse(req.responseText);\n\n                document.getElementById(wechat-mp-qr).setAttribute(src, https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket= + encodeURIComponent(json.ticket));\n\n                queryScanStatus(json.ticket);\n            }\n        };\n\n        req.open(GET, /mp-qr, true);\n        req.send();\n    }\n\n    showQRCodeImage();\n</code></pre>\n<p><a name=Nkvwk></a></p>\n<h1>总结</h1>\n<p>本文通过一个实际的具有商业价值的项目，展示了 API 优先的开发方法。通过薅羊毛的方式，落地了 Free Arch 架构。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}