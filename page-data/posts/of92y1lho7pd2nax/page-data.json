{"componentChunkName":"component---src-templates-post-js","path":"/posts/of92y1lho7pd2nax/","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/of92y1lho7pd2nax","relativePath":"posts/of92y1lho7pd2nax","frontmatter":{"title":"不使用 spring-boot-starter-oauth2-resource-server，如何使用 OIDC Server 保护 API？","stackbit_url_path":"posts/of92y1lho7pd2nax","date":"2023-07-18T11:48:27","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>参考《<a href=\"https://zhuanlan.zhihu.com/p/623303771\">升级 spring-security-oauth2 到 spring-boot-starter-oauth2-resource-server - Jeff Tian的文章 - 知乎</a> 》和 《<a href=\"https://zhuanlan.zhihu.com/p/626130631\">通过 Bean 的方式扩展 Spring 应用，使其同时支持多个授权服务颁发的令牌。 - Jeff Tian的文章 - 知乎 </a> 》，我们可以使用 <strong>spring-boot-starter-oauth2-resource-server</strong> 来对接 OIDC Server。</p>\n<p>今天再介绍一下另一种方式，不依赖已有的包，而是自己写代码来完成同样的事情。</p>\n<p><a name=kv7xE></a></p>\n<h1>示意图</h1>\n<p>重述问题，我们使用了 OIDC Server 来保护我们的 API。 API 的调用者可以是人类用户，也可以是机器（另一个 API）。即 OIDC Server 起到了一个认证中心的作用，API 消费方通过认证中心获取令牌，并在请求 API 提供方时携带令牌。API 提供方需要依赖认证中心来核实令牌的有效性。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/__mermaid_v3/00ccf37af9fcafb2b298749ece1149bd.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuICAgICAgQVtBUEnmtojotLnmlrldIC0tLS0-IHwxLiDor7fmsYLku6TniYx8IEJ76K6k6K-B5Lit5b-DfSA7XG4gICAgICBCIC0tLS0-fDIuIOmigeWPkeS7pOeJjHwgQTtcbiAgICAgIEEgLS0-IHwzLiDosIPnlKjmnI3liqF8IENbQVBJIOaPkOS-m-aWuV07XG5cdFx0XHRDIC0tLS0-IHw0LiDmoKHpqozku6TniYx8IEI7XG5cdFx0XHRCIC0tLS0-IHw1LiDku6TniYzmnInmlYh8IEM7XG5cdFx0XHRDIC0tPiB8Ni4g5o-Q5L6b5pyN5YqhfCBBOyIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvMDBjY2YzN2FmOWZjYWZiMmIyOTg3NDllY2UxMTQ5YmQuc3ZnIiwiaWQiOiJoMDhmUyIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=\" alt=\"\">\n无效就拒绝服务：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/__mermaid_v3/53a06f6c0ada7de3e50d541a1a61db59.svg#lake_card_v2=eyJ0eXBlIjoibWVybWFpZCIsImNvZGUiOiJncmFwaCBURFxuICAgICAgQVtBUEnmtojotLnmlrldIC0tLS0-IHwxLiDor7fmsYLku6TniYx8IEJ76K6k6K-B5Lit5b-DfSA7XG4gICAgICBCIC0tLS0-fDIuIOmigeWPkeS7pOeJjHwgQTtcbiAgICAgIEEgLS0-IHwzLiDosIPnlKjmnI3liqF8IENbQVBJIOaPkOS-m-aWuV07XG5cdFx0XHRDIC0tLS0-IHw0LiDmoKHpqozku6TniYx8IEI7XG5cdFx0XHRCIC0tLS0-IHw1LiDku6TniYzml6DmlYh8IEM7XG5cdFx0XHRDIC0teCB8Ni4g5ouS57ud5pyN5YqhfCBBOyIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX21lcm1haWRfdjMvNTNhMDZmNmMwYWRhN2RlM2U1MGQ1NDFhMWE2MWRiNTkuc3ZnIiwiaWQiOiJ4U00xeSIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=\" alt=\"\"><a name=q0jLt></a></p>\n<h1>前提</h1>\n<p>API 消费方在认证中心已经注册为一个有效的客户端。对于 API 消费方是机器的场景，这种客户端的许可类型是 client_credentials；如果 API 消费方是代替人类用户来请求 API 提供方，那么最终的客户端的许可类型很可能是 authorize_code。</p>\n<p>我们现在的 API 提供方，假设是使用 springboot 开发，只是去掉了对 <strong>spring-boot-starter-oauth2-resource-server</strong> 的引用。</p>\n<p><a name=MA52r></a></p>\n<h1>配置</h1>\n<p>由于需要和认证中心做远程调用沟通，不妨这样配置：\nyaml\nrpc:\nauthServer:\nurl: ${AUTH_SERVER_URL:<a href=\"https://id6.azurewebsites.net%7D\">https://id6.azurewebsites.net}</a></p>\n<p>要发远程调用，需要一个 HTTP 客户端，为了排查问题的方便，我们增加一个客户端配置，用来将请求以 cURL 的形式打印到日志里（参考《<a href=\"https://zhuanlan.zhihu.com/p/386126054\">将 FeignClient 的请求记录成 cURL 格式 - Jeff Tian的文章 - 知乎 </a> 》）。\njava\n@Slf4j\n@Configuration\n@EnableFeignClients(basePackages = com.hardway.infrastructure.rpc)\npublic class AuthClientInterceptor {</p>\n<pre><code>public static final String CURL_PATTERN = curl --location --request %s %s %s --data-raw %s;\n\n@Bean\npublic RequestInterceptor requestInterceptor() {\n    return template -> {\n        template.header(TRACE_NO, MDC.get(TRACE_NO));\n        log.info(cURL to replay  + toCurl(template));\n    };\n}\n\npublic String toCurl(feign.RequestTemplate template) {\n    try {\n        val headers = Arrays.stream(template.headers().entrySet().toArray())\n                .map(header -> header.toString()\n                        .replace(=, :)\n                        .replace([,  )\n                        .replace(],  ))\n                .map(h -> String.format( --header %s , h))\n                .collect(Collectors.joining());\n        val httpMethod = template.method().toUpperCase(Locale.ROOT);\n        val url = template.feignTarget().url() + template.url();\n        final byte[] bytes = template.body();\n        val body = bytes == null ?  : new String(bytes, StandardCharsets.UTF_8);\n\n        return String.format(CURL_PATTERN, httpMethod, url, headers, body);\n    } catch (Exception ex) {\n        log.error(ex.getMessage(), ex);\n        return ex.getMessage();\n    }\n}\n\n@Bean\nLogger.Level feignLoggerLevel() {\n    return Logger.Level.FULL;\n}\n</code></pre>\n<p>}</p>\n<p><a name=K4Wfs></a></p>\n<h1>接口</h1>\n<p>然后，我们来定义 HTTP 客户端的接口。分析一下需求，在 API 提供方，依赖认证中心的部分有两点，第一是需要校验令牌，第二是在令牌有效的情况下，需要基于令牌识别调用者的身份。对于结构化令牌 JWT 来说，要校验令牌是否为认证中心颁发，只需要验证该令牌的第三部分，即签名。认证中心会使用自己的私钥对令牌进行签名，而验证该签名，需要其公钥信息。因此我们需要调用认证中心的公钥信息获取接口，我们将这个方法命名为 getPublicKey。在签名验证通过后，我们从 JWT 的载荷里解析出过期时间，如果令牌未过期，就可以从中获取调用者的身份信息。如果出于各种原因（比如防止 PII 泄露），载荷中没有身份信息，或者不够，就需要再次调用认证中心以获取身份信息，我们将这个方法命名为 getPublicKey。</p>\n<p>java\n@FeignClient(name = auth-client, url = ${rpc.authServer.url:}, configuration = AuthClientInterceptor.class)\npublic interface IAuthClient {</p>\n<pre><code>@GetMapping(value = /connect/userinfo)\nUserInfoResponse getUserInfo(@RequestHeader(authorization) String token);\n\n@GetMapping(value = /.well-known/openid-configuration/jwks)\nPublicKeyResponse getPublicKey();\n</code></pre>\n<p>}</p>\n<p>一个典型的 OIDC Server 认证中心，其公钥接口如下：<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c16aff6ff3bc7d4f27600c8ec6e031c7/e78c9/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA2UlEQVR42q2Q3U7EIBCFef839FLjum2321JgZoACxzCtq9EbTST5Mr+ZOYNhEdwXi/m+wHmPzR0QC1gi8r7/ipQzUowwRISUEv7rGekK1xGze0aICxxPkOyxl4hcBFlt/BEfvpz5Xk9orcEQB1g/4e5fsPEIS286tNuNBzgeFS+z1j/iTRng5aYxxQW1VRjhiBACHN90W9oZtZU/n9rVtT4wkMdsL7iuT7B0wRpesdGgKg810wNL10eu+71P4QGSnH6BYSaUmlHqrpL7lqqUk/rNnn4tn3y56B0tySJK1LJiMwAAAABJRU5ErkJggg=='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/c16aff6ff3bc7d4f27600c8ec6e031c7/fcda8/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png\"\n        srcset=\"/static/c16aff6ff3bc7d4f27600c8ec6e031c7/12f09/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png 148w,\n/static/c16aff6ff3bc7d4f27600c8ec6e031c7/e4a3f/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png 295w,\n/static/c16aff6ff3bc7d4f27600c8ec6e031c7/fcda8/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png 590w,\n/static/c16aff6ff3bc7d4f27600c8ec6e031c7/efc66/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png 885w,\n/static/c16aff6ff3bc7d4f27600c8ec6e031c7/c83ae/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png 1180w,\n/static/c16aff6ff3bc7d4f27600c8ec6e031c7/e78c9/1689678921515-45f98dab-232d-4cec-bd46-9a6ff322f274.png 3734w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>以上是 HTTP 客户端的 rpc 接口，但是以上两个接口返回的信息，在短时间内都不会发生变化，我们可以将其缓存起来。为些我们再定义一个服务接口，为代码中的其他部分提供服务：</p>\n<p>java\nimport org.springframework.cache.annotation.Cacheable;</p>\n<p>public interface IAuthService {</p>\n<pre><code>@Cacheable(cacheNames = user-info, key = #userId, unless = #result == null)\nString getAccount(String userId, String token);\n\n@Cacheable(cacheNames = public-key, key = #kid, unless = #result == null)\nString getPublicKey(String kid);\n</code></pre>\n<p>}</p>\n<p><a name=YgrrG></a></p>\n<h1>实现接口</h1>\n<p>实现服务接口以对外提供服务，底层调用 HTTP 客户端。\njava</p>\n<p>@Slf4j\n@Service\n@AllArgsConstructor\npublic class AuthService implements IAuthService {</p>\n<pre><code>private final IAuthClient authClient;\nprivate final ObjectMapper objectMapper;\n\n@Override\npublic String getAccount(String userId, String token) {\n    UserInfoResponse response = authClient.getUserInfo(token);\n    String email = Objects.isNull(response) ? null : response.getEmail();\n\n    return email;\n}\n\n@SneakyThrows\n@Override\npublic String getPublicKey(String kid) {\n    PublicKeyResponse response = authClient.getPublicKey();\n    return Objects.isNull(response) ? null : objectMapper.writeValueAsString(response.getKey(kid));\n}\n</code></pre>\n<p>}</p>\n<p><a name=ljQer></a></p>\n<h1>对接口进行保护</h1>\n<p>我们希望以一种方便的途径来标记要保护的接口，比如这样：</p>\n<p>java\n@Slf4j\n@RequiredArgsConstructor\n@RestController\n@RequestMapping(/protected/api)\npublic class ProtectedApiController {\n@RequireAuth()\n@PostMapping(api1)\npublic ApiResponse&#x3C;?> doSomething() {\n...\nreturn ApiResponse.success();\n}\n}</p>\n<p>为此，我们可以通过切面编程实现以上标记。首先实现一个接口：\njava\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RequireAuth {\nboolean moreFields() default true;\n}</p>\n<p>然后定义一个切面类。<br />切面类和切入点用于在应用程序中定义横切关注点的行为。通过 @Aspect 注解将类标记为切面类，然后使用 @Pointcut 注解定义一个切入点。切入点指定了在何处应该应用切面的逻辑。<br />doAround() 方法是一个环绕通知，在目标方法执行之前和之后执行额外的逻辑。它在 @RequireAuth 注解标记的方法执行之前验证和处理身份验证和授权逻辑，并在之后执行目标方法。<br />doAfterThrowing() 方法是一个异常通知，在目标方法抛出异常时执行额外的逻辑。它用于记录和处理目标方法抛出的异常。</p>\n<p>java\n@Aspect\n@Component\n@Slf4j\n@AllArgsConstructor\npublic class AuthPointcut {\nprivate final IAuthService authService;</p>\n<pre><code>@Pointcut(@annotation(RequireAuth))\npublic void authPointcut() {}\n\n@Around(authPointcut())\npublic Object doAround(ProceedingJoinPoint pjp) throws Throwable {\n    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n\n    if(attributes == null) {\n        throw new RuntimeException(缺少 HTTP 必要元信息);\n    }\n\n    String token = attributes.getRequest().getHeader(authorization);\n\n    if(StringUtils.isBlank(token)) {\n        throw new RuntimeException(token 缺失);\n    }\n\n    String finalToken = StringUtils.removeStart(token, Bearer );\n\n    DecodedJWT decodedJWT = JWT.decode(finalToken);\n    String kid = decodedJWT.getKeyId();\n    String key = authService.getPublicKey(kid);\n\n    Security.addProvider(new BouncyCastleProvider());\n\n    JWK jwk = JWK.parse(key);\n    RSAPublicKey rsaPublicKey = (RSAPublicKey) jwk.toRSAKey().toPublicKey();\n\n    byte[] encoded = rsaPublicKey.getEncoded();\n    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);\n    PublicKey publicKey = KeyFactory.getInstance(RSA).generatePublic(keySpec);\n\n    Claims body = Jwts.parserBuilder()\n        .setSigningKey(publicKey)\n        .require(client_id, 前提中在认证中心提前注册好的 client_id)\n        .build()\n        .parseClaimsJws(token)\n        .getBody();\n\n    String userId = body.get(sub, String.class);\n    String email = authService.getAccount(userId, token);\n\n    if(StringUtils.isBlank(email)) {\n        throw new RuntimeException(身份信息缺失);\n    }\n\n    Class&#x3C;?> clazz = pjp.getTarget().getClass();\n    MethodSignature signature = (MethodSignature) pjp.getSignature();\n    Method targetMethod = clazz.getDeclaredMethod(signature.getName(), signature.getParameterTypes());\n    RequireAuth requireAuth = targetMethod.getAnnotation(RequireAuth.class);\n\n    if(!auth.moreFields()) {\n        // 更多自定义逻辑\n    }\n\n    return pjp.proceed();\n}\n\n@AfterThrowing(value=authPointcut(), throwing = throwable)\npublic void doAfterThrowing(Throwable throwable) {\n    log.error(异常： {}, throwable.getMessage());\n}\n</code></pre>\n<p>}</p>\n<p>以上 Security.addProvider(new BouncyCastleProvider()) 这行代码的作用是向 Java 的安全提供者列表中添加 Bouncy Castle 提供的安全提供者。</p>\n<blockquote>\n<p>Java 的安全架构中使用了安全提供者（Security Provider）的概念，安全提供者是一个实现了 Java Security API 的具体实现，它提供了一系列的加密、解密、签名、验证等安全功能。不同的安全提供者可能支持不同的加密算法、密钥管理方式等。\nBouncy Castle 是一个开源的密码学库，提供了丰富的密码学算法和安全服务，如加密、签名、密钥交换等。它不仅实现了标准的 Java Security API，还提供了一些额外的功能和算法。\n通过调用 Security.addProvider(new BouncyCastleProvider())，将 Bouncy Castle 提供的安全提供者添加到 Java 运行时的安全提供者列表中。这样，在后续的安全操作中，就可以使用 Bouncy Castle 提供的算法和功能。\n在提供者列表中，提供者是按照其优先级顺序进行搜索和使用的。因此，通过添加 Bouncy Castle 提供者，可以在使用安全功能时使用 Bouncy Castle 的实现。\n需要注意的是，一般情况下，只有在需要使用 Bouncy Castle 特定的算法或功能时才需要将其添加为安全提供者。如果你的应用程序不需要使用 Bouncy Castle 提供的功能，那么添加它可能是不必要的。</p>\n</blockquote>\n<p>以上代码从 HTTP 标头中提取出令牌，并对其进行解析，验证签名，并确保是可信客户端。其期待的令牌解析后的格式如下：\njson\n{\niss: <a href=\"https://id6.azurewebsites.net\">https://id6.azurewebsites.net</a>,\nnbf: 1689651711,\niat: 1689651711,\nexp: 1689653511,\naud: abcdef,\namr: [\nexternal\n],\nat_hash: roYexupGNPvXDeVliTAHTA,\nsid: C438CEAB57171B0BBD788008F767EBF9,\nsub: d9df1959-7a18-4753-8642-c0ec0d20ae67,\nauth_time: 1689651693,\nidp: id6\n}</p>\n<p><a name=hY0Yf></a></p>\n<h1>总结</h1>\n<p>如果不使用现有的库，代码量还是挺大的，但是这允许深度定制，可以满足复杂的需求。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[],"slicesMap":{}}