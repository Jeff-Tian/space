{"componentChunkName":"component---src-templates-post-js","path":"/posts/greu6l","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/greu6l","relativePath":"posts/greu6l","frontmatter":{"title":"使用 IdentityServer 保护 Web 应用（AntD Pro 前端 + SpringBoot 后端）","stackbit_url_path":"posts/greu6l","date":"2022-06-23T12:34:00","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=RLALE></a></p>\n<h1>需求背景</h1>\n<p>使用前后端分离开发的 Web 应用，想通过 IdentityServer 作为授权服务器将它保护起来，只允许登录后的用户使用。不管是前端页面，还是后端 API，都希望在登录前不可使用，而在登录后，都可以使用。即没有复杂的权限管理，只有登录和未登录的区别。\n<a name=KrIoG></a></p>\n<h1>技术栈</h1>\n<p>这个 Web 应用的前端项目基于 AntD Pro，而后端 API 项目基于 Java SpringBoot；同时，授权服务器是基于 ASP.NET Core 的 IdentityServer。保护的方式是 OAuth 2 的授权码流程，即在打开页面时，如果没有登录，会自动跳转到 IdentityServer 做统一登录，登录完成后，跳转回 Web 应用的页面，这时页面已经拿到了访问令牌，同时页面开始向后端发送 ajax 请求，并带上这个访问令牌。也就是说，无论前端页面还是后端 API，都对同样的访问令牌做校验，通过则页面与 API 都能访问，否则，都不能访问。</p>\n<p>关于如何部署一个 IdentityServer，可以参考：\n<a name=sr7yj></a></p>\n<h1>流程示意</h1>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655982913911-7f68876b-68da-4255-b52b-84a1d53b1228.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=319&#x26;id=ue4fe3647&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=638&#x26;originWidth=1500&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=71277&#x26;status=done&#x26;style=none&#x26;taskId=u10c941bf-46ec-4d6b-a334-fb8ca071279&#x26;title=&#x26;width=750\" alt=\"image.png\"></p>\n<p><a name=fUlkD></a></p>\n<h1>前端接入</h1>\n<p>前端使用了 AntD Pro 框架，而 AntD Pro 又是基于 UmiJs，在网上找到了一个 UmiJs 对接 OAuth 2 Server 的示例： <a href=\"https://github.com/io84team/umi-plugin-oauth2-client\">https://github.com/io84team/umi-plugin-oauth2-client</a>，除了它没有将插件发布的嘈点外，其他都很好。这里列一下在 AntD Pro 项目中利用 umi-plugin-oauth2-client 接入 IdentityServer 的详细步骤：\n<a name=zoPRP></a></p>\n<h2>引入 umi-plugin-oauth2-client</h2>\n<p>由于上面提到的那个示例，作者似乎没有发布成 npm 包，因此引入的方式不太优雅，但能工作！拷贝相应的源码到 plugins 目录，如下图所示：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655984042574-8f2dcf8c-4744-4213-a83f-8f23d8835d02.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=641&#x26;id=u273f582a&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1282&#x26;originWidth=1122&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=169464&#x26;status=done&#x26;style=none&#x26;taskId=ued6ee0f4-546b-4aa5-9bf6-295b69a7435&#x26;title=&#x26;width=561\" alt=\"image.png\"></p>\n<p>然后再在配置文件里，增加这个插件的引用：\ntypescript\n// .umirc</p>\n<p>...\nplugins: [\n...\nrequire.resolve(./plugins/oauth2-client),\n],</p>\n<p>...</p>\n<p><a name=YzHqT></a></p>\n<h2>接入 IdentityServer 配置</h2>\n<p><a name=llyOJ></a></p>\n<h3>IdentityServer 增加一个客户端</h3>\n<p>首先，给这个 Web App 起个名字，比如叫 CoolApp，然后，在 IdentityServer 里增加该客户端，相当于备一个案：\ncsharp\n// src/IdentityServer/Config.cs</p>\n<p>using Duende.IdentityServer;\nusing Duende.IdentityServer.Models;</p>\n<p>namespace IdentityServer;</p>\n<p>public static class Config\n{\n...\npublic static IEnumerable<Client> Clients =>\nnew[]\n{\nnew()\n{\nClientId = CoolApp,\nClientSecrets =\n{\nnew Secret(CoolApp.Sha256())\n},\nClientName = CoolApp,\nAllowedGrantTypes = GrantTypes.CodeAndClientCredentials,\nRequireClientSecret = false,\nRedirectUris =\n{\n<a href=\"http://localhost:8000/oauth2/callback\">http://localhost:8000/oauth2/callback</a>,\n<a href=\"https://your.cool.app/oauth2/callback\">https://your.cool.app/oauth2/callback</a>\n},\nAllowedScopes =\n{\nIdentityServerConstants.StandardScopes.OpenId,\nIdentityServerConstants.StandardScopes.Profile,\nIdentityServerConstants.StandardScopes.Email,\n}\n},\n...\n};\n...</p>\n<p>然后要将客户端添加到 IdentityServer 数据存储中，这里以内存为例：\ncsharp\n// src/IdentityServer/HostingExtensions.cs</p>\n<p>namespace IdentityServer;</p>\n<p>internal static class HostingExtensions\n{\npublic static WebApplication ConfigureServices(this WebApplicationBuilder builder)\n{\n// uncomment if you want to add a UI\nbuilder.Services.AddRazorPages();</p>\n<pre><code>    builder.Services.AddIdentityServer()\n        .AddInMemoryIdentityResources(Config.IdentityResources)\n        .AddInMemoryApiScopes(Config.ApiScopes)\n        .AddInMemoryClients(Config.Clients)\n        .AddTestUsers(TestUsers.Users);\n</code></pre>\n<p>...</p>\n<p><a name=wOzaq></a></p>\n<h3>在前端配置该 IdentityServer 元数据</h3>\n<p>typescript\n// .umirc</p>\n<p>...\noauth2Client: {\nclientId: CoolApp,\naccessTokenUri: <a href=\"https://your.identity.server/connect/token\">https://your.identity.server/connect/token</a>,\nauthorizationUri: <a href=\"https://your.identity.server/connect/authorize\">https://your.identity.server/connect/authorize</a>,\nredirectUri:\n<a href=\"http://localhost:8000/oauth2/callback\">http://localhost:8000/oauth2/callback</a>,\nscopes: [openid, email, profile],\nuserInfoUri: <a href=\"https://your.identity.server/connect/userinfo\">https://your.identity.server/connect/userinfo</a>,\nuserSignOutUri: <a href=\"https://your.identity.server/connect/endsession\">https://your.identity.server/connect/endsession</a>,\nhomePagePath: /,\n},\n...</p>\n<p><a name=IejYh></a></p>\n<h2>路由修改</h2>\n<p>由于是保护所有的页面，因此将原来的父级路由增加一个 wrappers（参考官网文档），同时增加一个登录的路由，如下：\ntypescript\n// .umirc.ts</p>\n<p>const routes: IRoute[] = [\n{\npath: /login, // 非必须，可以留作后续扩展使用\ncomponent: login,\nlayout: false,\n},\n{\npath: /,\nwrappers: [@/wrappers/auth],\ncomponent: ../layouts/BlankLayout,\nflatMenu: true,\nroutes: [\n{\nname: xxx\npath: /yyy,\ncomponent: ./zzz,\n},\n...\n]\n}\n]</p>\n<p><a name=FsfNN></a></p>\n<h2>实现 auth wrapper</h2>\n<p>typescript\n// src/wrappers/auth.tsx</p>\n<p>import React from react;\nimport { useEffect } from react;\nimport type { IRouteComponentProps } from umi;\n// @ts-ignore\nimport { useOAuth2User } from umi;</p>\n<p>const Auth: React.FC<IRouteComponentProps> = (props) => {\nconst { children } = props;</p>\n<p>// const { token, user, signIn, getSignUri } = useOAuth2User();\nconst { token, user, signIn } = useOAuth2User();</p>\n<p>useEffect(\n() => {\nif (token === undefined &#x26;&#x26; user === undefined) {\n// token 和 user 都是 undefined 时才需要请求。</p>\n<pre><code>    // const uri = getSignUri();\n    // return &#x3C;a href={uri}>Goto SSO&#x3C;/a>;\n    // 显示登录链接，或者自动跳转登录，或者跳转到自己的登录页面。\n    debugger;\n    signIn();\n  }\n},\n// 注销时不会重复登录\n// eslint-disable-next-line react-hooks/exhaustive-deps\n[],\n</code></pre>\n<p>);</p>\n<p>if (token !== undefined &#x26;&#x26; user !== undefined) {\nreturn children;\n}\nreturn <span>Loading...</span>;\n};</p>\n<p>export default Auth;</p>\n<p><a name=pboqP></a></p>\n<h2>实现 login 组件</h2>\n<p>这不是必须的，但是建议增加一个简单的组件，展示一下登录态，如果已登录，就展示用户信息，并且提供一个退出的按钮（链接）。</p>\n<p>typescript\n// src/pages/login.tsx</p>\n<p>import { Link } from react-router-dom;\nimport { OAuth2UserContext } from umi;</p>\n<p>export default () => {\nreturn (\n&#x3C;OAuth2UserContext.Consumer>\n{({ user, token, signOut }) => {\nconst userContent = token &#x26;&#x26; user &#x26;&#x26; (\n<div>\n{user.name}\n<br />\n<Link to=/ onClick={signOut}>\nSignOut\n</Link>\n</div>\n);\nreturn (\n<div>\n<div>Login Page</div>\n<div>User: {JSON.stringify(user)}</div>\n<div>Token: {JSON.stringify(token)}</div></p>\n<pre><code>        {userContent}\n        &#x3C;Link to=/>Home&#x3C;/Link>\n      &#x3C;/div>\n    );\n  }}\n&#x3C;/OAuth2UserContext.Consumer>\n</code></pre>\n<p>);\n};</p>\n<p><a name=Xge44></a></p>\n<h2>效果</h2>\n<p>打开任意页面（除了 /login 外），只要是非登录态，就会跳转到 IdentityServer 服务器，登录后跳回。如果打开 /login 页面，可以查看已登录用户信息：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655986103323-f9c522b0-12eb-4bff-be52-86ccb8f33c44.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=367&#x26;id=u3f0d50b5&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=734&#x26;originWidth=1964&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=180209&#x26;status=done&#x26;style=none&#x26;taskId=u0e4b1f22-0e11-4834-9330-8d3c99e4c67&#x26;title=&#x26;width=982\" alt=\"image.png\"><br />同时，发现 Local Storage 里有了访问令牌信息：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655986152048-e2a5de23-90f8-4417-9462-04838e00990c.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=289&#x26;id=u8b2163cf&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=578&#x26;originWidth=2056&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=78897&#x26;status=done&#x26;style=none&#x26;taskId=u575f13e9-0f58-46df-82ca-3b79b9a8f29&#x26;title=&#x26;width=1028\" alt=\"image.png\"><br />该令牌是一个 JWT，结构如下：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655986207779-ec354ff9-d0b2-4cb3-8b89-6669225ba6a5.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=991&#x26;id=u3b31e564&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1982&#x26;originWidth=2934&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=651617&#x26;status=done&#x26;style=none&#x26;taskId=u77ac5fdd-8171-4e35-acbe-827fedc5b74&#x26;title=&#x26;width=1467\" alt=\"image.png\"><br />注意其中的 aud 字段，在后面保护 API 时需要用到。另外，注意 typ 字段，如果是 at+jwt，则需要对 IdentityServer 做相应配置，改成 jwt，以便让 SpringBoot 项目识别该令牌。</p>\n<p><a name=ZxUX3></a></p>\n<h1>后端接入</h1>\n<p>虽然前端页面已经被保护起来了，但是，其后端 API 仍然可以使用 Postman 等方式直接访问，绕过了被保护起来的 UI。所以 API 也得保护起来，以 SpringBoot 项目为例，详解接入 IdentityServer 的步骤。\n<a name=ZQeFL></a></p>\n<h2>IdentityServer 做个小修改</h2>\n<p>IdentityServer 颁发的令牌，其 typ 字段默认是 at+jwt，这不被 springboot 项目识别，需要修改为 jwt：</p>\n<p>csharp\n// src/IdentityServer/HostingExtensions.cs</p>\n<p>namespace IdentityServer;</p>\n<p>internal static class HostingExtensions\n{\npublic static WebApplication ConfigureServices(this WebApplicationBuilder builder)\n{\n// uncomment if you want to add a UI\nbuilder.Services.AddRazorPages();</p>\n<pre><code>    builder.Services.AddIdentityServer(options =>\n        {\n            // https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/api_scopes#authorization-based-on-scopes\n            options.EmitStaticAudienceClaim = true;\n            \n            // 将默认的 at+jwt 修改为 jwt\n            options.AccessTokenJwtType = jwt;\n        })\n</code></pre>\n<p>...</p>\n<p><a name=d57t3></a></p>\n<h2>在 SpringBoot 项目中增加必要的依赖</h2>\n<p>xml\n// pom.xml</p>\n<p>...</p>\n<pre><code>    &#x3C;dependency>\n        &#x3C;groupId>org.springframework.security.oauth.boot&#x3C;/groupId>\n        &#x3C;artifactId>spring-security-oauth2-autoconfigure&#x3C;/artifactId>\n        &#x3C;version>2.1.4.RELEASE&#x3C;/version>\n    &#x3C;/dependency>\n    &#x3C;dependency>\n        &#x3C;groupId>org.springframework.security.oauth&#x3C;/groupId>\n        &#x3C;artifactId>spring-security-oauth2&#x3C;/artifactId>\n        &#x3C;version>2.3.5.RELEASE&#x3C;/version>\n    &#x3C;/dependency>\n    &#x3C;dependency>\n        &#x3C;groupId>com.sun.xml.bind&#x3C;/groupId>\n        &#x3C;artifactId>jaxb-impl&#x3C;/artifactId>\n        &#x3C;version>2.3.1&#x3C;/version>\n    &#x3C;/dependency>\n    &#x3C;dependency>\n        &#x3C;groupId>com.sun.xml.messaging.saaj&#x3C;/groupId>\n        &#x3C;artifactId>saaj-impl&#x3C;/artifactId>\n        &#x3C;version>1.5.1&#x3C;/version>\n    &#x3C;/dependency>\n</code></pre>\n<p>...</p>\n<p><a name=CVZK9></a></p>\n<h2>增加资源服务器配置</h2>\n<p>�增加一个资源服务器配置 ResourcesServerConfiguration 类，将前面的 JWT 令牌中的 aud 字段配置为该项目的 resourceId：\njava\n// src/main/java/com/.../application/ResourcesServerConfiguration.java</p>\n<p>package com.xxx.application;</p>\n<p>import org.springframework.context.annotation.Configuration;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;</p>\n<p>@Configuration\n@EnableResourceServer\npublic class ResourcesServerConfiguration extends ResourceServerConfigurerAdapter {\n@Override\npublic void configure(ResourceServerSecurityConfigurer resources) throws Exception {\nresources.resourceId(前面的 jwt 令牌中的 aud 字段);\n}\n}</p>\n<p><a name=HR1ys></a></p>\n<h2>对需要保护的接口增加 @EnableWebSecurity 注解</h2>\n<p>java\n// xxxx controller</p>\n<p>import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</p>\n<p>...\n@RestController\n...\n@EnableWebSecurity\npublic class XxxController {</p>\n<p><a name=L2Ty3></a></p>\n<h2>效果</h2>\n<p>如果不带 token 直接访问 API，或者带上了错误的过期的 token，会得到没有权限的错误：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1656040077902-ba0d5f2e-d441-4555-bc6c-3929c0d8cac0.png#clientId=u85a640d4-9c0b-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=336&#x26;id=ubc932ab2&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=672&#x26;originWidth=1782&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=99646&#x26;status=done&#x26;style=none&#x26;taskId=ubc9857b0-ce6e-4da4-99ca-9f05b559c93&#x26;title=&#x26;width=891\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655987257671-266f8db0-df74-4fdf-9bed-6a44735f16e7.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=618&#x26;id=ub91bd974&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1236&#x26;originWidth=2644&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=353898&#x26;status=done&#x26;style=none&#x26;taskId=u3a035915-6557-4b46-b830-dfe6e14628b&#x26;title=&#x26;width=1322\" alt=\"image.png\"><br />而当带上正确有效的的 token 时，就可以得到预期的结果：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655987303626-6d69f3fc-4a7c-4ffa-b6e1-de0f6241409a.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=339&#x26;id=ud36f1618&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=678&#x26;originWidth=2126&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=110126&#x26;status=done&#x26;style=none&#x26;taskId=u756345a0-ba79-4d1c-bd2f-9908497707e&#x26;title=&#x26;width=1063\" alt=\"image.png\"></p>\n<p><a name=zgvIH></a></p>\n<h1>总结</h1>\n<p>本文以具体的例子，详解（手把手教）了如何保护前端页面和后端 API。这个方式其实可以举一反三，推广到更多的应用场景中。比如 IdentityServer 可以换成 Keycloak 等等任何支持 OAuth 2 的认证授权服务器；前端除了 Umi 技术栈外，也可以是其他技术栈，比如 Next Js，这时就可以使用 NextAuth（我做了一个示例： <a href=\"https://notion.inversify.cn/sign-in\">https://notion.inversify.cn/sign-in</a>，欢迎体验） 。后端也可以是任何的技术栈，但是需要不同的接入方法。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1655987566404-2ffbfaed-fc8c-471c-996f-1fb2849d9351.png#clientId=uf0b4b3a9-0ba2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=488&#x26;id=u72746c35&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=976&#x26;originWidth=2678&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=110277&#x26;status=done&#x26;style=none&#x26;taskId=u2a474a17-914a-471c-ae72-8c2918db71f&#x26;title=&#x26;width=1339\" alt=\"image.png\"></p>\n<p>nodejs 项目、springboot 项目和 ASP.NET Core 项目都是以前独立开发的，今天终于通过登录保护这条线，把它们串在一起了，爽！</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}