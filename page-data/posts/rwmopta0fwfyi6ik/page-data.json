{"componentChunkName":"component---src-templates-post-js","path":"/posts/rwmopta0fwfyi6ik/","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/rwmopta0fwfyi6ik","relativePath":"posts/rwmopta0fwfyi6ik","frontmatter":{"title":"基于 Duende IdentityServer 体验用户联邦的第一滴血","stackbit_url_path":"posts/rwmopta0fwfyi6ik","date":"2023-03-31T14:06:48","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>关于用户联邦，前面聊过两次了，都是基于 Keycloak。今天聊一下在第一次在 Duende IdentityServer 中玩用户联邦时的一点流血经验。同样的事情，在不同的技术框架中做，有着完全不同的体验。对比这两种不同的体验，作者还悟出了一些人生哲理，一并分享给大家。\n<a name=JdLhB></a></p>\n<h1>用户联邦是什么？</h1>\n<p>首先不妨问一下，联邦是什么？上网搜索联邦，会发现，这一般指国家的组织形式，几个小邦联合起来，组织成一个更大的国家，并同意做这个国家的成员。联邦共和国是几个社会连合而产生的一个新的社会，这个新社会还可以因其他新成员的加入而扩大。</p>\n<p>联邦国家，是一种国家的组织形式。在技术方面，也有类似的组织形式，也称之为某某联邦。比如公司里有多个团队，不同的团队，提供了不同的 API。它们如果将这些 API 联合起来，组织成一个更大整体来对外提供服务，这时就出现了 API 联邦。以 GraphQL API 为具体的例子，我之前尝试过 NestJs 的 GraphQL Gateway，将 Java 工程提供的 GraphQL API、NodeJs 工程提供的 GraphQL API 以及 Python 工程提供的 GraphQL API，联邦在一起，具体见：《<a href=\"https://zhuanlan.zhihu.com/p/583120262\">Free Arch: GraphQL Federation 初体验（成功，且丝滑！） - Jeff Tian的文章 - 知乎 </a> 》。</p>\n<p>那么，用户联邦是什么呢？其实就是将各个用户系统连合在一起。比如在一个系统中，可以使用另一个系统的账号无缝登录。说到这里，我想起来我在 2014 年就做了一次用户联邦，但那时并没有意识到这件事情。那时候团队自研了一套 CRM 系统，系统的使用者主要是公司内部员工，每次有新员工入职，就需要在这个系统里同步创建账号。这不仅造成了团队的负担，也给员工本人带来了不便，需要额外记住一套账号密码。我后来做了一件事，就是联邦了公司的域账号系统，从而用户可以直接使用域账号登录 CRM 系统。这次的用户联邦，只是将外部用户系统联邦到自研 CRM 系统，这个 CRM 系统本身不是标准产品。下一次，如果要在另外的系统中联邦公司的域账号系统，需要另外的系统再次开发。</p>\n<p>上次聊《<a href=\"https://zhuanlan.zhihu.com/p/606955086\">架构整洁：增加代理层解决一团乱麻的问题 - Jeff Tian的文章 - 知乎 </a> 》时，举了一个身份认证代理的例子。通过引入一个身份认证代理层，在这个代理层联邦公司域账号系统，以及更多的用户系统，就可以同时赋能它背后的所有系统。这种身份认证代理层，不建议自研开发，而是使用标准的产品，否则其他系统要对接的话会需要额外开发，而对接标准产品，则只需要配置一下即可。</p>\n<p>这种标准产品也有很多，以 Keycloak 为例，它内置联邦 LDAP 的提供者程序，要在 Keycloak 里联邦 LDAP，只需要配置即可，详见：《<a href=\"https://zhuanlan.zhihu.com/p/588455371\">Free Arch: Keycloak 用户联邦 LDAP 初体验（感谢 Authing!） - Jeff Tian的文章 - 知乎 </a>  》。而如果要联邦一些自研的用户系统，就需要自己写提供者程序了，这篇文章《<a href=\"https://zhuanlan.zhihu.com/p/618020024\">Keycloak 自定义用户联邦示例 - Jeff Tian的文章 - 知乎 </a> 》里举了一个例子。</p>\n<p>今天，作者再说一个使用 Duende IdentityServer 联邦自定义用户系统的案例。\n<a name=W7d7k></a></p>\n<h1>Keycloak 和 Duende IdentityServer，完全两种风格</h1>\n<p>Keycloak 是使用 Java 编写的开源身份认证系统，而 Duende IdentityServer 是使用 .NET Core 编写的身份认证系统。它们都对外提供 OAuth 2.0 和 OIDC 的标准协议，所以说是标准产品。其他系统要对接，只需要使用一个成熟的客户端，做一些配置即可。之前写过的很多文章，都是如何使用某个客户端，对接某个标准的身份认证系统。</p>\n<p>但是，Keycloak 和 Duende IdentityServer 的区别，不仅仅在于其开发语言，产品形态也有很大的区别。首先，Keycloak 自带管理控制台，免费开箱即用，可以完全不写代码，但同时也提供了丰富的扩展方式（以前也多次撰文举例）。而 Duende IdentityServer 更接近于一个身份认证中间件，虽然代码开源，但商用的话需要购买许可证。管理控制台有付费版。要使用 Duende IdentityServer，需要写代码，而且代码量不小。它非常灵活，可以和业务代码嵌在一起，为你的自定义业务系统提供 OIDC 能力。</p>\n<p>Keycloak 的扩展方式很丰富，但是要扩展，有一些例行事项，比如要实现它指定的接口，要将打包的 jar 放到指定目录，要在 META-INF/services 里注册你的自定义提供者程序等等；而扩展 Duende IdentityServer，则没有那么多约束，因为它只是嵌在你的业务代码里的一部分，你的代码想怎么写，仍然由你决定。\n<a name=b8Y7f></a></p>\n<h1>第一滴血</h1>\n<p>我基于 Duende IdentityServer 部署了一个身份认证服务，多个业务系统对接了它。得益于它，各个业务系统可以专注于自己的业务逻辑，不需要管理用户认证等。因为 Duende IdentityServer 帮我们实现了 OAuth 2.0 和 OIDC 这些标准协议，所以我写的身份认证服务，相当于只是创建了一个 dotnet 项目，引用了 Duende IdentityServer，配置好了数据库，并且集成了 Azure AD 和企业微信（因为用户是公司员工），就一切结束了。其他对接了该服务后，在登录时，会跳转到身份认证服务，认证完毕，跳转回各个子系统，进入登录态。这一切本来工作得很好。</p>\n<p>但是公司里还有另一个自研系统，该系统的用户是公司的合作伙伴。既他们既不是公司员工，也不是公司的终端消费者，而是帮助公司一起运营的其他公司员工。这个系统并不是标准产品，所以没有办法直接和其他系统对接，在其他系统需要给到合作伙伴使用时，就遇到了难题。自己开发不仅有开发工作量，而且还增加了用户的负担以及管理人员的负担。这时，自然希望直接对接身份认证服务，而让身份认证服务去联邦这个自研系统的用户。</p>\n<p>我之前已经实现过在 Keycloak 中对接自定义联邦用户源，所以这个场景我觉得非常熟悉，只是换个语言来做嘛，为了图快，用极简的代码，很快写好了，并且自己“测试”通过，随即上到了 QA 环境，并感觉这个 Duende IdentityServer 果然灵活，想怎么写就怎么写，没有 Keycloak 那么多条条框框限制。没想到，一上到 QA 环境，即被发现有问题：用 Azure AD 或者企业微信登录依然正常，只是用这个自研系统的账号登录不了。</p>\n<p>我很诧异，我明明测试过了，用这个自研系统账号可以正常登录呀？我又看了一下代码，是这样写的：\ncsharp</p>\n<p>try\n{\nvar res = await _federation.Login(new LoginCredentials\n{\nemail = userInput.Username,\npassword = userInput.Password\n});</p>\n<pre><code>if (!res.success || res.data is null)\n{\n    return SignInResult.Failed;\n}\n\nAuthenticationProperties props = null;\n\nif (LoginOptions.AllowRememberLogin &#x26;&#x26; userInput.RememberLogin)\n{\n    props = new AuthenticationProperties\n    {\n        IsPersistent = true,\n        ExpiresUtc = DateTimeOffset.UtcNow.Add(LoginOptions.RememberMeLoginDuration)\n    };\n}\n\nvar identityServerUser = new IdentityServerUser(res.data.id.ToString())\n{\n    DisplayName = res.data.name +  (Federated),\n    IdentityProvider = Federated\n};\n\nawait httpContext.SignInAsync(identityServerUser, props);\n\nreturn SignInResult.Success;\n</code></pre>\n<p>}\ncatch (Exception ex)\n{\n_logger.LogError(Federation Logging in error: {0}, ex);</p>\n<pre><code>return SignInResult.Failed;\n</code></pre>\n<p>}\n}</p>\n<p>不仅代码看上去没有丝毫的问题，而且我拿了一个自研系统的账号，在 QA 环境里直接登录了这个身份认证服务，非常顺利。再一问，原来问题是人家登录业务子系统，跳转到身份认证服务后，输入了用户名和密码，就白屏了，没有跳回业务子系统。而且白屏上写着存在跳转循环：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 467px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1303dd76a30fbc511a1e5cd455e9f1d0/85ff8/1680269507556-019b612b-e20b-4f11-af7e-fad42d6afea7.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.24324324324324%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVR42q2Ta2vCMBSG/f+/agrtHBMsfthgn3StbVJtbja9Je07GqfUaWWyBQ7vSch5OJdkAgBd1+G0en+4f3RNTsHWWpRleQH+EzDLMnieB8bY/wGDIHA6LH3Ygp/+XWDbtqjr2ml/dtIxG4MOgI+VOJb1Gcg5h+8/Y7VaOX2azrBcBpjPX/D29o7XxQKe72M6nWG92VxBrzI0xkIq5YaSJATbbQwhBISQ0Fq7c6UOSNMdpJQ3s7vIsKpKhGGEMAwRhRGSOAFnDIQQUEJACHXQLGPY7fdICEEcJ6A0df2+KrlqLLjSYL3J3Pl5USEvG6iiQWOsCzzacWjtjSGdgbXpEEuLdWbxySzWzCKRFpGw+KANdG2/g+4PaVByBc4ZlBQQnEEwBik4UkqhJIe15ub7HM3QGIM819C6cJr3qjUOhxy6KC76dO8XTR75Zr+59wXNz0cJtHga0wAAAABJRU5ErkJggg=='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/1303dd76a30fbc511a1e5cd455e9f1d0/85ff8/1680269507556-019b612b-e20b-4f11-af7e-fad42d6afea7.png\"\n        srcset=\"/static/1303dd76a30fbc511a1e5cd455e9f1d0/12f09/1680269507556-019b612b-e20b-4f11-af7e-fad42d6afea7.png 148w,\n/static/1303dd76a30fbc511a1e5cd455e9f1d0/e4a3f/1680269507556-019b612b-e20b-4f11-af7e-fad42d6afea7.png 295w,\n/static/1303dd76a30fbc511a1e5cd455e9f1d0/85ff8/1680269507556-019b612b-e20b-4f11-af7e-fad42d6afea7.png 467w\"\n        sizes=\"(max-width: 467px) 100vw, 467px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>我观察了一下，是业务子系统跳转到了身份认证服务，在登录完成后，跳转回业务子系统后，被认为未登录，又跳转回身份认证服务了。身份认证服务认为已登录，又跳回子系统，如此循环。\n<a name=RtxHB></a></p>\n<h1>ChatGPT 来帮忙</h1>\n<p>我百思不得其解，为什么身份认证服务认为登录过了，而子业务却查询不到登录状态呢？冥思苦想无果，求助 ChatGPT。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7525f36429d61f1c1ba543710d5e34ac/e872c/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACGklEQVR42m1SyXLaQBTUR6RyyiVgkxySSnCw2UErEpLYtLNISAIZQozxksrvd+o921QOOXS9Zd70dM+M8OXrN7TaCjo9Hd039A00mjLqTQn1poybusix3nipGy0ZzZbCoLmeaECULbjOEkKpXIEojaHpIfywwCI+IFrskRdPiNdHpPkJSXqPdXaPTfGMdXaCFxY8E853cP0NvGALfRhCUhwItese+tIIsuLAMEOY9pwXx7MEhhXBGi0wmqy4/xb70uQMSZlB0Rwomgt14EIoX1RQvepCUieQ1Qm0gQPdcNHpDiHJo38whvia64YHyw6hDz30RRs3deUM4eLyE75X2+i0dLTaOtodg9Foalz/D3QYgXIiqV718KMmonYtQbisfEa3Z6IfxrDcBJ6fY+ZlbG8yS86YOms4Xoapk3JNuRds4Po5gqiANVpC030IH0tl9Po2FCuCE+RYrH7Cj+jSd5zPl3sk6RHZ5gHZ9gF58Yh4fcd1ujlxjNM7GGYEdeBBKBGhaENVPVaxSn4hnN8ylvEB42nMw6SAHsS0F/xo1BtacwbVpI4eRnj3/gNfLLHP3JTlkzpSRpb8cMu9c4wKniOr1KOZ8TTh/UxYpCZaHZMbtGG7e0ZO1raP/Pe2t0/YH/5wJKtkudj95rk0f1lPsiOrZMJNbKDZHjIh2SNlwasKugJS4QY5vCDnPymrM+jDgAloz8AIzmRE+BcofKWgfeNjHAAAAABJRU5ErkJggg=='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"b6976104d96cfb298176f9248e77a68.png\"\n        title=\"b6976104d96cfb298176f9248e77a68.png\"\n        src=\"/static/7525f36429d61f1c1ba543710d5e34ac/fcda8/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png\"\n        srcset=\"/static/7525f36429d61f1c1ba543710d5e34ac/12f09/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png 148w,\n/static/7525f36429d61f1c1ba543710d5e34ac/e4a3f/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png 295w,\n/static/7525f36429d61f1c1ba543710d5e34ac/fcda8/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png 590w,\n/static/7525f36429d61f1c1ba543710d5e34ac/efc66/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png 885w,\n/static/7525f36429d61f1c1ba543710d5e34ac/c83ae/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png 1180w,\n/static/7525f36429d61f1c1ba543710d5e34ac/e872c/1680269930889-e052dc2a-bcf8-4881-b463-27f1045b5f87.png 2606w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>最终学习到，身份认证服务在登录完成后会调用 /connect/authorize/callback 并将授权码返回给业务子系统。而业务子系统随后用授权码来换取用户信息时，用的是 /connect/token 端点。问题就在于，这个端点告诉业务子系统，当前并非登录态（后来知道是没有查询到用户）。即对业务子系统来说，这两个端点进入了脑裂状态。 /connect/authorize/callback 告诉它已经登录了，可以换取用户信息了。而在用 /connect/token 换取用户信息时，却又拿不到用户信息。</p>\n<p>再次查看之前的代码，我发现，为了简单，我手动创建了一个 IdentityServerUser 对象，并将其用户编号（SubjectId）设置为了第三方自研系统的用户编号，再调用 httpContext.SignInAsync方法进入了登录态。这样从身份认证服务站点上看，的确进入了登录态，但是 /connect/token 端点会尝试使用 SubjectId （即第三方自研系统的用户编号）来查询用户信息，但我并没有写相关的代码，这就导致 /connect/token 会报错，查询服务器相关的日志，的确发现了该用户在系统中不存在的日志。</p>\n<p><a name=TT71k></a></p>\n<h1>修复</h1>\n<p>找到了原因，修复方向也就有了。问题的原因是，我只实现了使用第三方自研系统账号登录的方法，却没有实现查询第三方自研系统账号信息的方法，即这个联邦其实并不彻底。</p>\n<p>我这时才回想起在 Keycloak 中做同样的事情时，需要实现指定的接口，当时就有点不耐烦，为什么要重载（Override）这么多方法？当时就感觉 Keycloak 是个啰嗦的老人，喋喋不休。现在才明白，其实在运行时，整个系统就是有那么多环节，Keycloak 帮我们做了梳理，整理了一些步骤，只需要按着做就行了。但如果不理解这些背后的环节，就像办个签证，要填写很多表格一样，让人觉得费事儿。</p>\n<p>对于这个具体问题，就是少了查询用户的环节。这时有两个选择，重载默认的查询用户方法，就像上面重载默认的登录方法一样。如果不想重载默认的查询用户方法，可以在第三方用户登录时，将用户保存到本地数据库。这样默认的查询用户的方法，在查询数据库时就会查询到用户信息，从而正常在 /connect/token 接口里返回用户的信息。</p>\n<p>csharp\n...\nvar appUser = await _userManager.FindByEmailAsync(res.data.email);\nif (appUser is null)\n{\nvar createUserRes = await _userManager.CreateAsync(new ApplicationUser()\n{\nUserName = res.data.name, Email = res.data.email, EmailConfirmed = true,\n});</p>\n<pre><code>if (!createUserRes.Succeeded)\n{\n    return SignInResult.Failed;\n}\n\nappUser = await _userManager.FindByEmailAsync(res.data.email);\n\nif (appUser is null)\n{\n    return SignInResult.Failed;\n}\n</code></pre>\n<p>}</p>\n<p>var identityServerUser = new IdentityServerUser(appUser.Id)\n{\nDisplayName = res.data.name +  (Federated), IdentityProvider = Federated\n};</p>\n<p>await httpContext.SignInAsync(identityServerUser, props);\nreturn SignInResult.Success;</p>\n<p>以上，在登录成功后，用该用户的 email 查询本地数据库，没有查询到（第一次登录），即创建该用户。并且在最后调用 SignInAsync时，传递的 IdentityServerUser 的 SubjectId 设置为了在本地数据库能够查询到的用户的 Id。这样就解决了这个问题。\n<a name=AdbhJ></a></p>\n<h1>人生哲理</h1>\n<p><a name=tjXic></a></p>\n<h2>不听老人言，吃亏在眼前其实不对</h2>\n<p>刚才说了，Keycloak 就像一个老人。有句老话叫“不听老人言，吃亏在眼前”，这句话虽然押韵，但其实不对。如果不听就吃亏在眼前，那大家肯定会听的。这句话应该改成“不听老人言，吃亏在遥远”。因为反馈周期太长，短期来看不听也无所谓，但是直到过了很久之后，吃到了苦头。</p>\n<p>Keycloak 就像严谨的强类型编程语言，写起来烦琐一点，不写对，就不能编译成功和运行。而 Duende IdentityServer 有点像弱类型语言，随便你怎么写，都可以运行起来，没有编译过程，所以有些错误，只能在运行时发现。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}}}},"staticQueryHashes":[],"slicesMap":{}}