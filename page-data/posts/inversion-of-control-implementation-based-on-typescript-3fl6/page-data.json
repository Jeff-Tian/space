{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/posts/inversion-of-control-implementation-based-on-typescript-3fl6/",
    "result": {"data":{"sitePage":{"id":"SitePage /posts/inversion-of-control-implementation-based-on-typescript-3fl6/"}},"pageContext":{"url":"/posts/inversion-of-control-implementation-based-on-typescript-3fl6/","relativePath":"posts/inversion-of-control-implementation-based-on-typescript-3fl6.md","relativeDir":"posts","base":"inversion-of-control-implementation-based-on-typescript-3fl6.md","name":"inversion-of-control-implementation-based-on-typescript-3fl6","frontmatter":{"title":"The Implementation of Inversion of Control based on TypeScript","stackbit_url_path":"posts/inversion-of-control-implementation-based-on-typescript-3fl6","date":"2020-11-30T11:02:34.480Z","excerpt":"IoC   According to wikipedia, the Inversion of Control, also as known as IoC, is a design pr...","thumb_img_path":null,"comments_count":0,"positive_reactions_count":8,"tags":["typescript","ioc","di"],"canonical_url":"https://dev.to/jefftian/inversion-of-control-implementation-based-on-typescript-3fl6","template":"post"},"html":"<h2>IoC</h2>\n<p>According to wikipedia, the Inversion of Control, also as known as IoC, is a design principal in Object Oriented Programming, which is used to decouple the code.</p>\n<p>In the traditional Object Oriented Programming, when a class depends on another class, then usually the other class's instance gets created inside that class. By doing so it leads to classes couple with each other, and the more complex the dependencies are, the more tight of the couplings, and consequently harder for modifications and unit testings for the tightly coupled code. The IoC are dedicatedly used for creating and searching the dependent objects by providing a container, and hand over the controlling of the dependent objects from inside the class to the container, by doing so the classes are being decoupled, and ensure that all classes are easy to be modified.</p>\n<h3>Coupling</h3>\n<p>What the hell is coupling? We can show it by a simple example. Say we have two classes,\n<code>A</code>\nand\n<code>B</code>\n, their dependency relationship is\n<code>A</code>\ndepends on\n<code>B</code>\n:\n<code>A ⊥ B</code>\n. This is a common scenario in daily development, which can be implemented in a traditional way as the following:</p>\n<pre><code class=\"language-typescript\">// b.ts\n\nclass B {\n  constructor () {\n  }\n}\n\n// a.ts\n\nclass A {\n  b: B;\n  constructor () {\n    this.b = new B();\n  }\n}\n\n// main.ts\n\nconst a = new A();\n</code></pre>\n<p>The above code looks good for now, but if we got a new requirement which requires the innermost\n<code>B</code>\npass a parameter\n<code>p</code>\nin during the initialization:</p>\n<pre><code class=\"language-typescript\">// b.ts\n\nclass B {\n  p: number;\n  constructor (p: number) {\n    this.p = p;\n  }\n}\n</code></pre>\n<p>After the modification, we got a new problem: since\n<code>B</code>\nis instantiated inside class\n<code>A</code>\n's constructor, so we have to pass the\n<code>p</code>\ninside\n<code>A</code>\n's constructor. Where is the\n<code>p</code>\ncome from inside\n<code>A</code>\n? Obviously we can not hard code it, otherwise there is no need to add it as a parameter at the first place. So we have to add a parameter\n<code>p</code>\nfor class\n<code>A</code>\n's constructor, too, as following:</p>\n<pre><code class=\"language-typescript\">// a.ts\n\nclass A {\n  b: B;\n  constructor (p: number) {\n    this.b = new B(p);\n  }\n}\n\n// main.ts\nconst a = new A(10);\nconsole.log(a); // => A {b: B {p: 10}}\n</code></pre>\n<p>What's more tedious, after we've changed\n<code>A</code>\n, we found that\n<code>B</code>\n's new parameter\n<code>p</code>\ncan't be a\n<code>number</code>\nactually, it needs to be a\n<code>string</code>\n. So we have to change the type decoration to parameter\n<code>p</code>\ninside\n<code>A</code>\nagain. Let's imagine what if there were more upper classes that depend on\n<code>A</code>\n? With the same approach we need to change all the upper classes in the same way! This is the very problem caused by coupling, we have to change all the files in the dependent links only for a simple parameter change in the innermost class. When the application's dependencies become more complex to an extend, it's easy to encounter a phenomenon that affects the whole body, which causes huge troubles for application's maintenance.</p>\n<h3>Decoupling</h3>\n<p>In fact, we can find, in the above example, that only\n<code>B</code>\nneeds the parameter\n<code>p</code>\n, and\n<code>A</code>\nis using\n<code>p</code>\nmerely for instantiate the dependent object and cares nothing about\n<code>p</code>\n. So we can consider moving the instantiation for dependent objects out of the class itself, for example, we can rewrite the above example as:</p>\n<pre><code class=\"language-typescript\">// b.ts\nclass B {\n  p: number;\n  constructor (p: number) {\n    this.p = p;\n  }\n}\n\n// a.ts\nclass A {\n  private b: B;\n  constructor(b: B) {\n    this.b = b;\n  }\n}\n\n// main.ts\nconst b = new B(10);\nconst a = new A(b);\nconsole.log(a); // A => {b: B {p: 10}}\n</code></pre>\n<p>In the above example,\n<code>A</code>\nis not accepting parameter\n<code>p</code>\n, instead, it accepts the dependent object, and doesn't care about where does the object get instantiated. This approach solved our previously problem in a effective way, now we only need to change\n<code>B</code>\nwhen we need to change the parameter\n<code>p</code>\n, without the need to modify\n<code>A</code>\n, so we decoupled the classes.</p>\n<h2>Containers</h2>\n<p>Even though we've implemented the decoupling, we need to instantiate all the classes by ourselves, and pass them by means of parameters in constructor. If exists a global container, and it <strong>pre-registered</strong> all the class definitions and initial parameters that we need, and every object has an unique key, then we can only tell the container its key when we need an object to <strong>get</strong> the instantiated object from the container directly. By doing so the developer won't need to care about how the objects get instantiated, neither pass them as constructor's parameters in the dependency links.</p>\n<p>In other words, our container must have two functions, <strong>registering the instances</strong> and <strong>get them</strong>. It's naturally to come up with\n<code>Map</code>\n, which can be used to implement a simple container:</p>\n<pre><code class=\"language-typescript\">// container.ts\n\nexport class Container {\n  bindMap = new Map();\n\n  // Registering the instances\n  bind(identifier: string, clazz: any, constructorArgs: Array&#x3C;any>) {\n    this.bindMap.set(identifier, {clazz, constructorArgs});\n  }\n\n  // get the instances\n  get&#x3C;T>(identifier: string) : T {\n    const target = this.bindMap.get(identifier);\n    const { clazz, constructorArgs } = target;\n    const inst = Reflect.construct(clazz, constructorArgs);\n  }\n}\n</code></pre>\n<p>Here we used\n<code>Reflect.construct</code>\n, whose behavior is kind of similar to operator\n<code>new</code>\n, which helps us instantiate the object. By means of container, we can eventually abandon passing the parameters and implement the decoupling, for example:</p>\n<pre><code class=\"language-typescript\">// b.ts\n\nclass B {\n  constructor(p: number) {\n    this.p = p;\n  }\n}\n\n// a.ts\nclass A {\n  b: B;\n  constructor() {\n    this.b = container.get('b');\n  }\n}\n\n// main.ts\nconst container = new Container();\ncontainer.bind('a', A);\ncontainer.bind('b', B, [10]);\n\n// get a from container\nconst a = container.get('a');\nconsole.log(a); // A => {b: B { p: 10}}\n</code></pre>\n<p>Actually till now we have basically implemented IoC, and decoupled classes based on container. But from the lines of code perspective, code looks no clearer than before, and in the contrary, the container initialization and classes registration make us feel tedious. If that part of code can be encapsulated into framework, and all the classes registration can be automatically wired up, in the same time all classes can get the dependent instances of the classes during the construction time without manually specify them inside constructor, then the developer's hands can be freed totally, and then only focus on the inner logic of the class. This is what DI(Dependency Injection) comes in handy.</p>\n<h2>DI</h2>\n<p>Many of us can't tell the difference between DI and IoC, so was I. IoC is only a principle, DI is a concrete implementation for IoC. Simply put, we can inject the dependencies to the caller, without the need for the caller to fetch explicitly. To implement DI, two issues need to be solved:</p>\n<ul>\n<li>The classes that need to be registered in the IoC container, they need to be able to register themselves automatically during program starts</li>\n<li>When instantiate the classes inside the IoC container, the dependent objects can be fetched directly without manually specifying them inside constructor</li>\n</ul>\n<p>Regarding the two problems there are different solutions, for example, the famous Java Spring needs developers define an XML file describing the dependency relationships, and then the framework do the instances' registration and dependency injections based on the XML file. But the XML based dependency management approach is too trivial, so Midway utilizes the decoration features provided by TypeScript, by decorating the meta data to identify the registration requirements and dependencies need to be injected, to implement the dependency injection.</p>\n<h3>Reflect Metadata</h3>\n<p>To use decoration to solve the above two problems, we need to know some basics about Reflect Metadata. Reflect Metadata is a proposal to ES7, mainly used to add and read the meta data during declaration phase, which was supported from TypeScript 1.5+.</p>\n<p>Meta data can be treated as descriptive information regarding to the classes or certain properties of classes, they don't affect class's behavior by nature, but you can get the predefined metadata to a class, and apply certain operations to the class based on the metadata.</p>\n<p>The usage of Reflect Metadata is rather simple, first of all you need to install the\n<code>reflect-metadata</code>\nlibrary:</p>\n<pre><code class=\"language-shell\">npm i reflect-metadata --save\n</code></pre>\n<p>And then in your\n<code>tsconfig.json</code>\n, the\n<code>emitDecoratorMetadata</code>\nneeds to be configured to\n<code>true</code>\n.</p>\n<p>And then we can define and get the meta data using\n<code>Reflect.defineMetadata</code>\nand\n<code>Reflect.getMetadata</code>\n, for example:</p>\n<pre><code class=\"language-typescript\">import 'reflect-metadata';\n\nconst CLASS_KEY = 'ioc:key';\n\nfunction ClassDecorator() {\n  return function (target: any) {\n    Reflect.defineMetadata(CLASS_KEY, {\n      metaData: 'metaData',\n    }, target);\n\n    return target;\n  }\n}\n\n@ClassDecorator()\nclass D {\n  constructor(){}\n}\n\nconsole.log(Reflect.getMetadata(ClASS_KEY, D)); // => {metaData: 'metaData'}\n</code></pre>\n<p>With\n<code>Reflect</code>\n, we can tokenize any class, and apply special operations to the tokenized class.</p>\n<h3>Provider</h3>\n<p>Back to our initial problem, we need all classes get defined and parameters registration automatically during application starts, but not all classes need to be registered into the container, and we don't know what classes need to be registered, nor the initial parameters of them are like.</p>\n<p>We can introduce metadata to solve this issue, by appending some new special tokens to the class's metadata in the definition, we can identify them by scanning. With this bear in mind we implement a decorator to tokenize the classes need to be registered firstly, and name the decorator\n<code>Provider</code>\n, meaning it will be consumed by other classes as a provider.</p>\n<pre><code class=\"language-typescript\">// provider.ts\n\nimport 'reflect-metadata';\n\nexport const CLASS_KEY = 'ioc:tagged_class';\n\nexport function Provider(identifier: string, args?: Array&#x3C;any>) {\n  return function (target: any) {\n    Reflect.defineMetadata(CLASS_KEY, {\n      id: identifier,\n      args: args || []\n    }, target);\n    return target;\n  };\n}\n</code></pre>\n<p>We can see there are\n<code>id</code>\nand\n<code>args</code>\nin the tokens, where\n<code>id</code>\nis the\n<code>key</code>\nused to register IoC container, and\n<code>args</code>\nare the needed parameters of instantiation.\n<code>Provider</code>\ncan be used directly in a decoration fashion, as follow:</p>\n<pre><code class=\"language-typescript\">// b.ts\nimport {Provider} from 'provider';\n\n@Provider('b', [10])\nexport class B {\n  constructor(p: number) {\n    this.p = p;\n  }\n}\n</code></pre>\n<p>With tokenization done, another issue surfaces: How do we get these definitions during application starts?</p>\n<p>An easy way is scan all the files when starts, get all the classes exported by those files and bind them according to the metadata. For the simplicity we assume there were no nested directories, then the implementation is as follows:</p>\n<pre><code class=\"language-typescript\">// load.ts\n\nimport * as fs from 'fs';\nimport { CLASS_KEY } from './provider';\n\nexport function load(container) { // The container is the global IoC container\n  const list = fs.readdirSync('./');\n  for (const file of list) {\n    if (/\\.ts$/.test(file)) {\n      const exports = require(`\n./${file}\n`);\n      for (const m in exports) {\n        const module = exports[m];\n        if (typeof module === 'function') {\n          const metadata = Reflect.getMetadata(CLASS_KEY, module);\n          // register\n          if (metadata) {\n            container.bind(metadata.id, module, metadata.args);\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>So now, we can finish all the work of binding the decorated class by just running the\n<code>load</code>\ninside\n<code>main</code>\n. What worth noting is that the logic of\n<code>load</code>\nand\n<code>Container</code>\nare totally generic, they can be encapsulated in to a package and then a simplified IoC framework is in its baby shape.</p>\n<pre><code class=\"language-typescript\">import {Container} from './container';\nimport {load} from './load';\n\nconst container = new Container();\nload(container);\n\nconsole.log(container.get('a')); // A => {b: B {p: 10}}\n</code></pre>\n<h3>Inject</h3>\n<p>With registration work done, we now check the 2nd issue mentioned above: How do we get all the dependent instances directly without explicitly pass them in the constructor. Actually the initiative is simple, since we have already put all required classes into the IoC container, so when we need some class we can iterate the properties of the class during fetching the class instance, by get the corresponding object and assign the value, then the dependency injection work is done.</p>\n<p>But another issue comes out, how do we tell which properties need to be injected? Similarly we can use metadata to solve it. By defining a decorator to tokenize which properties need to be injected and name this decorator as\n<code>Inject</code>\nto indicate this property needs to be injected, then we are good.</p>\n<pre><code class=\"language-typescript\">// inject.ts\n\nimport 'reflect-metadata';\n\nexport const PROPS_KEY = 'ioc:inject_props';\n\nexport function Inject() {\n  return function (target: any, targetKey: string) {\n    const annotationTarget = target.constructor;\n\n    let props = {};\n    if (Reflect.hasOwnMetadata(PROPS_KEY, annotationTarget)) {\n      props = Reflect.getMetadata(PROPS_KEY, annotationTarget);\n    }\n\n    props[targetKey] = {\n      value: targetKey\n    };\n\n    Reflect.defineMetadata(PROPS_KEY, props, annotationTarget);\n  };\n}\n</code></pre>\n<p>Need to attention that although we are decorating the properties, the actual metadata should be defined on class to maintain the property list need to be injected of the class. So we have to use\n<code>target.constructor</code>\nas the\n<code>target</code>\nto be operated. And here uses property name (\n<code>targetKey</code>\n) as the\n<code>key</code>\nto the instance in IoC container to be simple.</p>\n<p>Then we need to change the\n<code>get</code>\nmethod of IoC container, and inject all the properties recursively:</p>\n<pre><code class=\"language-typescript\">// container.ts\n\nimport {PROPS_KEY} from './inject';\n\nexport class Container {\n  bindMap = new Map();\n\n  bind(identifier: string, clazz: any, constructorArgs?: Array&#x3C;any>) {\n    this.bindMap.set(identifier, {\n      clazz,\n      constructorArgs: constructorArgs || []\n    });\n  }\n\n  get&#x3C;T>(identifier: string) : T {\n    const target = this.bindMap.get(identifier);\n    const { clazz, constructorArgs } = target;\n    const props = Reflect.getMetadata(PROPS_KEY, clazz);\n    const inst = Reflect.construct(clazz, constructorArgs);\n    for (let prop in props) {\n      const identifier = props[prop].value;\n      // get injected object recursively\n      inst[prop] = this.get(identier);\n    }\n    return inst;\n    }\n  }\n}\n</code></pre>\n<p>To use it you can just utilize\n<code>Inject</code>\nto decorate the needed properties.</p>\n<pre><code class=\"language-typescript\">// a.ts\n\nimport {Provider} from 'provider';\n\n@Provider('a')\nexport class A {\n  @Inject()\n  b: B;\n}\n</code></pre>\n<h3>Final code</h3>\n<p>After the above adjustment, our final business code looks like this:</p>\n<pre><code class=\"language-typescript\">// b.ts\n\n@Provider('b', [10])\nclass B {\n  constructor(p: number) {\n    this.p = p;\n  }\n}\n\n// a.ts\n\n@Provider('a')\nclass A {\n  @Inject()\n  private b: B;\n}\n\n// main.ts\nconst container = new Container();\nload(container);\n\nconsole.log(container.get('a'));   // A => {b: B {p: 10}}\n</code></pre>\n<p>We can see there is no more manually instantiation, and the framework layer can automatically handle whatever how many classes to be registered, and inject required properties when instantiation. All instances can be provided are maintained by the class itself, and if it needed to be changed it doesn't need to change other files.</p>\n<h2>Summary</h2>\n<p>This post starts from classes decoupling to describe why IoC is needed, and implemented a simplified IoC framework based TypeScript. In fact, besides decoupling, we can benefit much from IoC, for example, fast unit test based on container, analyzing the dependency relations between classes.</p>\n<p>Although the concept of IoC was initiated from server side, but nowadays there are also all kinds of applications in the front end, for example AngularJS has implemented their own IoC framework to improve development efficiency and the levels of modularization.</p>\n<p><em><a href=\"https://dev.to/jefftian/inversion-of-control-implementation-based-on-typescript-3fl6\">This post is also available on DEV.</a></em></p>\n<script>\nconst parent = document.getElementsByTagName('head')[0];\nconst script = document.createElement('script');\nscript.type = 'text/javascript';\nscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/iframe-resizer/4.1.1/iframeResizer.min.js';\nscript.charset = 'utf-8';\nscript.onload = function() {\n    window.iFrameResize({}, '.liquidTag');\n};\nparent.appendChild(script);\n</script>    ","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},
    "staticQueryHashes": []}