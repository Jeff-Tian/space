{"componentChunkName":"component---src-templates-post-js","path":"/posts/duvwb2","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/duvwb2","relativePath":"posts/duvwb2","frontmatter":{"title":"构造器注入与循环依赖","stackbit_url_path":"posts/duvwb2","date":"2021-06-18T02:19:02","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<blockquote>\n<p>接上一篇《<a href=\"https://zhuanlan.zhihu.com/p/381290161\">邪恶的字段注入</a>》，再谈谈构造器注入。</p>\n</blockquote>\n<p>上一篇《<a href=\"https://zhuanlan.zhihu.com/p/381290161\">邪恶的字段注入</a>》主要是针对随处可见的字段注入现状提出了批评，并强烈推荐使用构造器注入。在历数各种字段注入的缺点，也就是相对来说使用构造器注入的优点后，只发现了 java 世界里构造器注入的一个缺点，那就是得多写点代码（当然也以 js 工程师的角度，对 java 工程师进行了劝退，因为 js 的构造器注入连这个仅有的缺点都没有）。</p>\n<p>但是实际上，即便在 java 的世界里需要多写点代码，也根本不是问题，因为有 IDE 来帮忙。那还等什么，快来改造吧！</p>\n<p><a name=yqmHE></a></p>\n<h1>怎么做</h1>\n<p>将光标定位到字段注入代码处，按下 Alt + Enter：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1623893319725-0a7bf8d6-a494-4ae7-89ee-87cdd47921c0.png#clientId=u82b44fa6-3947-4&#x26;from=paste&#x26;height=183&#x26;id=u2f3512a4&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=183&#x26;originWidth=885&#x26;originalType=binary%E2%88%B6=1&#x26;size=34052&#x26;status=done&#x26;style=none&#x26;taskId=u126860b3-23da-4db5-b361-dfeccf5375a&#x26;width=885\" alt=\"image.png\"></p>\n<p>在弹出的 popup 里选择第一个，回车，就自动完成了字段注入到构造器注入的改造：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1623893334812-f47a5f42-0406-495f-b5cf-574c8c5a15ba.png#clientId=u82b44fa6-3947-4&#x26;from=paste&#x26;height=140&#x26;id=uae3d2fac&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=140&#x26;originWidth=672&#x26;originalType=binary%E2%88%B6=1&#x26;size=19499&#x26;status=done&#x26;style=none&#x26;taskId=ua0cf8f7b-3e9b-4395-aabb-efc3a3a8093&#x26;width=672\" alt=\"image.png\"><br />可以看到，使用构造器注入，连 @Autowired 关键字都可以省略。</p>\n<p><a name=vGyi9></a></p>\n<h1>构造器注入还有什么缺点？</h1>\n<p>上面用 IDE 的强大功能抵消了《<a href=\"https://zhuanlan.zhihu.com/p/381290161\">邪恶的字段注入</a>》中提到的构造器注入的唯一缺点，不过仍然有人不喜欢构造器注入，说原因是构造器注入在<strong>极端情况</strong>下有循环依赖异常问题。但是对于循环依赖，就可以使用字段注入，并且是 Spring 官方文档推荐的方式。似乎 ——</p>\n<p><a name=v6z2k></a></p>\n<h2>构造器注入不如字段注入强大。</h2>\n<p><strong>这其实也是误解了</strong>。首先，对于循环依赖，这是明显的代码坏味道，应该首先反思设计，是不是有明显的 BUG？这里涉及到一个价值观问题，对于缺陷或者异常，是尽早暴露出来 fail fast，还是尽量把问题隐藏得越久越好？我站在 fail fast 这一边，所以我认为，构造器注入即使不如字段注入强大也不要紧，因为这个时候首先应该反思代码设计。</p>\n<p>但是，构造器注入并非不如字段注入强大，通过在构造器注入里使用 @Lazy 注解，也可以解决循环依赖异常问题。</p>\n<p><a name=nz3GP></a></p>\n<h2>总结：无论什么场景，构造器注入都优于字段注入。</h2>\n<p>以下详细说说循环依赖的异常问题：</p>\n<p><a name=Zr5DP></a></p>\n<h1>什么是循环依赖？</h1>\n<p>当 bean A 依赖 bean B，并且 bean B 也依赖 bean A 时，就产生了循环依赖：</p>\n<p>Bean A -> Bean B -> Bean A</p>\n<p>当然，有时候这种循环依赖比较含蓄（隐藏得比较深）：</p>\n<p>Bean A -> Bean B -> Bean C -> Bean D -> Bean E -> Bean A</p>\n<p><a name=iK3NT></a></p>\n<h1>Spring 中发生了什么？</h1>\n<p>当 Spring 上下文加载所有 bean 时，会依照一定的顺序创建 bean 从而使得他们可以完全工作。对于没有循环依赖的情况，比如这样的依赖关系：</p>\n<p>Bean A -> Bean B -> Bean C</p>\n<p>Spring 会先创建 bean C，然后是 bean B（同时将 bean C 注入 B），最后创建 bean A（同时把 bean B 注入 A）。</p>\n<p>但是当有循环依赖时，Spring 无法决定那个 bean 应该最先被创建出来，因为它们相互依赖。在这样的情况下，Spring 只好在加载上下文时抛出 _BeanCurrentlyInCreationException _异常。</p>\n<p>当然，这种异常只会在你使用构造器注入时抛出；如果使用别的注入方式的话，由于依赖只会在它们实际被使用时而非在上下文加载时被注入，所以不会有异常抛出。</p>\n<p><a name=XJzdI></a></p>\n<h1>举个例子</h1>\n<p>定义两个互相依赖的 bean，并且使用构造器注入：</p>\n<p>java\n@Component\npublic class CircularDependencyA {</p>\n<pre><code>private CircularDependencyB circB;\n\n@Autowired\npublic CircularDependencyA(CircularDependencyB circB) {\n    this.circB = circB;\n}\n</code></pre>\n<p>}</p>\n<p>java\n@Component\npublic class CircularDependencyB {</p>\n<pre><code>private CircularDependencyA circA;\n\n@Autowired\npublic CircularDependencyB(CircularDependencyA circA) {\n    this.circA = circA;\n}\n</code></pre>\n<p>}</p>\n<p>接着我们写一个配置类用来测试，就命名为 TestConfig 吧，它指定了扫描组件的基准包名。假设上面的 bean 定义在包“com.hardway.circular”里：</p>\n<p>java\n@Configuration\n@ComponentScan(basePackages = { com.hardway.circular })\npublic class TestConfig {\n}</p>\n<p>最后我们写一个 JUnit 测试来检查循环依赖。测试可以是空的，因为我们只要触发上下文加载即可检测到循环依赖。</p>\n<p>java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = { TestConfig.class })\npublic class CircularDependencyTest {</p>\n<pre><code>@Test\npublic void givenCircularDependency_whenConstructorInjection_thenItFails() {\n    // 测试可以是空的，因为我们只要触发上下文加载即可检测到循环依赖。\n}\n</code></pre>\n<p>}</p>\n<p>尝试运行测试，得到如下异常：</p>\n<p>shell\nBeanCurrentlyInCreationException: Error creating bean with name circularDependencyA:\nRequested bean is currently in creation: Is there an unresolvable circular reference?</p>\n<p><a name=gTHg0></a></p>\n<h1>绕过的方法</h1>\n<p>前面说了，发生循环依赖，首先应该重新思考代码设计。不过这里还是完整地列出所有可以绕过异常的办法。</p>\n<p><a name=TR1W6></a></p>\n<h2>重新设计</h2>\n<p>如果发生循环依赖，很有可能出现了设计问题：职责划分不合理。这时候应该重新设计组件让它们的层次结构变得合理和良好，从而不需要循环依赖。</p>\n<p>如果真的因为某些原因不能重新设计组件（比如遗留代码、不允许被修改的代码、没时间没资源做完整的重新设计等……），那么你可以尝试：</p>\n<p><a name=V5Edr></a></p>\n<h2>使用 @Lazy</h2>\n<p>打破环的简单办法是让 Spring 对 bean 进行懒惰的初始化，即：不要完全初始化 bean，而是创建一个代理来将它注入到其他 bean 中。被注入的 bean 仅仅在第一次被使用时才会完全初始化。</p>\n<p>比如你可以把前面的组件 CircularDependencyA 改造成这样：</p>\n<p>java\n@Component\npublic class CircularDependencyA {</p>\n<pre><code>private CircularDependencyB circB;\n\n@Autowired\npublic CircularDependencyA(@Lazy CircularDependencyB circB) {\n    this.circB = circB;\n}\n</code></pre>\n<p>}</p>\n<p>如果你再次运行测试，就会看到错误不见了。</p>\n<p><a name=XNdRC></a></p>\n<h2>使用设置器/字段注入</h2>\n<p>Spring 官方文档提出的，也是最流行的（但是我不推荐）绕过方式是使用设置器注入。简单来说就是你将 bean 们的缠绕方式从构造器注入改成设置器注入（或者字段注入），就能搞定问题。通过这个方式 Spring 只创建 bean，但是在依赖被真正用到之前都不会事先注入。</p>\n<p>我们可以把前面的例子中的类改成使用设置器注入，然后添加另一个 message 字段到 CircularDependencyB 中以便于写一个合适的单元测试：</p>\n<p>java\n@Component\npublic class CircularDependencyA {</p>\n<pre><code>private CircularDependencyB circB;\n\n@Autowired\npublic void setCircB(CircularDependencyB circB) {\n    this.circB = circB;\n}\n\npublic CircularDependencyB getCircB() {\n    return circB;\n}\n</code></pre>\n<p>}</p>\n<p>java\n@Component\npublic class CircularDependencyB {</p>\n<pre><code>private CircularDependencyA circA;\n\nprivate String message = Hi!;\n\n@Autowired\npublic void setCircA(CircularDependencyA circA) {\n    this.circA = circA;\n}\n\npublic String getMessage() {\n    return message;\n}\n</code></pre>\n<p>}</p>\n<p>单元测试改成这样：</p>\n<p>java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = { TestConfig.class })\npublic class CircularDependencyTest {</p>\n<pre><code>@Autowired\nApplicationContext context;\n\n@Bean\npublic CircularDependencyA getCircularDependencyA() {\n    return new CircularDependencyA();\n}\n\n@Bean\npublic CircularDependencyB getCircularDependencyB() {\n    return new CircularDependencyB();\n}\n\n@Test\npublic void givenCircularDependency_whenSetterInjection_thenItWorks() {\n    CircularDependencyA circA = context.getBean(CircularDependencyA.class);\n\n    Assert.assertEquals(Hi!, circA.getCircB().getMessage());\n}\n</code></pre>\n<p>}</p>\n<p>上面用到一些注解，解释如下：</p>\n<p>@Bean： 告诉 Spring 框架必须使用这些方法来获取需要被注入的 bean 的实现。<br />@Test：  测试要从上下文中获取 CircularDependencyA 这个 bean，然后断言它的 CircularDependencyB 已经被稳妥地注入了，并检查它的 message 属性的值。</p>\n<p><a name=SG2BS></a></p>\n<h2>使用 @PostConstruct</h2>\n<p>另一个打破环的方式是通过在众多 bean 中的其中一个上面应用 @Autowired 来注入依赖，然后在一个方法上面应用 @PostConstruct 注解来设置其他的依赖。</p>\n<p>比如有这样的 bean 相关的代码：</p>\n<p>java\n@Component\npublic class CircularDependencyA {</p>\n<pre><code>@Autowired\nprivate CircularDependencyB circB;\n\n@PostConstruct\npublic void init() {\n    circB.setCircA(this);\n}\n\npublic CircularDependencyB getCircB() {\n    return circB;\n}\n</code></pre>\n<p>}</p>\n<p>java\n@Component\npublic class CircularDependencyB {</p>\n<pre><code>private CircularDependencyA circA;\n\nprivate String message = Hi!;\n\npublic void setCircA(CircularDependencyA circA) {\n    this.circA = circA;\n}\n\npublic String getMessage() {\n    return message;\n}\n</code></pre>\n<p>}</p>\n<p>然后可以运行之前写好的同样的测试，你可以看到依赖能够被稳妥地注入并且不会抛出循环依赖异常。</p>\n<p><a name=uJPhF></a></p>\n<h2>实现 ApplicationContextAware 和 InitializingBean</h2>\n<p>如果有 bean 实现了 ApplicationContextAware，则这个 bean 就能够访问 Spring 上下文并能够从中抽取到其他的 bean。而通过实现 InitializingBean 可以指示这个 bean 在当其所有的属性都被设置好后必须执行一些动作；在这个场景下我们手动设置依赖。</p>\n<p>bean 相关的代码像这样：</p>\n<p>java\n@Component\npublic class CircularDependencyA implements ApplicationContextAware, InitializingBean {</p>\n<pre><code>private CircularDependencyB circB;\n\nprivate ApplicationContext context;\n\npublic CircularDependencyB getCircB() {\n    return circB;\n}\n\n@Override\npublic void afterPropertiesSet() throws Exception {\n    circB = context.getBean(CircularDependencyB.class);\n}\n\n@Override\npublic void setApplicationContext(final ApplicationContext ctx) throws BeansException {\n    context = ctx;\n}\n</code></pre>\n<p>}</p>\n<p>java\n@Component\npublic class CircularDependencyB {</p>\n<pre><code>private CircularDependencyA circA;\n\nprivate String message = Hi!;\n\n@Autowired\npublic void setCircA(CircularDependencyA circA) {\n    this.circA = circA;\n}\n\npublic String getMessage() {\n    return message;\n}\n</code></pre>\n<p>}</p>\n<p>再一次运行之前的测试可以验证仍然能够通过并且没有异常。</p>\n<p><a name=mXCaE></a></p>\n<h1>总结</h1>\n<p>本文接续《<a href=\"https://zhuanlan.zhihu.com/p/381290161\">邪恶的字段注入</a>》，强烈推荐使用构造器注入，并且手把手地讲解了如何将字段注入改造成构造器注入，以及反驳了构造器注入不如字段注入的观点。同时对循环依赖这个极端场景进行了举例说明，列举了所有可能的绕过方法，并展示了通过 @Lazy 注解，构造器注入仍然优于字段注入，但是最优的方案是重新设计代码，因为出现循环依赖是一个设计缺陷的表征。</p>\n<p>尽管 Spring 官方文档更喜欢用设置器注入和字段注入，但是我仍然更加推崇构造器注入。因为设置器/字段注入以及其他的几种绕过方法基本上都是阻拦了 Spring 对 bean 的初始化和注入的管理，然后手动来进行，这违背了使用 Spring 的初衷。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}