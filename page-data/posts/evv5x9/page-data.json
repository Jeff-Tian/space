{"componentChunkName":"component---src-templates-post-js","path":"/posts/evv5x9","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/evv5x9","relativePath":"posts/evv5x9","frontmatter":{"title":"Free Arch: babel as a service","stackbit_url_path":"posts/evv5x9","date":"2021-12-31T10:58:23","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>在昨天分享的《<a href=\"https://zhuanlan.zhihu.com/p/451816333\">FreeArch: 将 React 教程的井字棋游戏搬到微信小程序</a>》里提到的，通过实现一个 react-view，可以部分解决个人版微信小程序不能使用 webview 的缺憾。</p>\n<p>虽然完全可以在前端使用 babel standalone，动态转译 tsx 代码。但是由于 babel-standlone 压缩后的体积，也超过了小程序的代码限制，所以放在前端，只能在开发模式使用，没有办法发布。</p>\n<p>于是就要后端来提供 babel 服务了。可能网上有很多类似这样的服务，但为了更好的定制化，还是自己写一个吧。利用<a href=\"https://zhuanlan.zhihu.com/p/412196725\">万能 BFF</a>，分分钟部署一个。</p>\n<p><a name=PX0Va></a></p>\n<h1>在线演示</h1>\n<p>先看一下，直接转译一个最简单的：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png#clientId=u92230521-0fc0-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=529&#x26;id=u33933c4a&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1058&#x26;originWidth=3582&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=413033&#x26;status=done&#x26;style=none&#x26;taskId=ubf00ee76-e0a0-478e-bc8f-1b1777b7641&#x26;title=&#x26;width=1791\" alt=\"image.png\"><br />考虑到最终使用场景，是需要转译 replit （其实代码保存在 GitHub）的源文件，因为还提供了指定源文件的 url 进行转译的功能：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png#clientId=u92230521-0fc0-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=987&#x26;id=u3ea33d92&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1974&#x26;originWidth=3582&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=1161094&#x26;status=done&#x26;style=none&#x26;taskId=ud3718a60-95eb-45eb-b282-998bf137ddb&#x26;title=&#x26;width=1791\" alt=\"image.png\"></p>\n<p><a name=x3z3R></a></p>\n<h1>万能 BFF 源代码</h1>\n<p><a name=MWyBh></a></p>\n<h1>项目背景</h1>\n<p>项目采用了 nestjs 框架，对外提供 GraphQL 服务。nestjs graphql 项目，基本上是 module -> resolver -> service 这样的分层架构。\n<a name=Ip6vz></a></p>\n<h1>实现步骤</h1>\n<p>对于要实现一个 babel service，在 nest 项目中就是添加一个 babel service module，然后再添加一个 babel resolver 接收前端的请求，最后由 service 完成转译。为了省事儿，准备直接在项目里放置一个 babel.min.js 文件，用 require 方式获取 Babel 对象。</p>\n<p><a name=bPoMy></a></p>\n<h2>测试先行</h2>\n<p>尽管大概思路是非常清楚和简单粗暴，但是实践起来，还是要测试先行。实际的 TDD 过程就不详解了，为了叙述省事儿，略过了很多细枝末节。但是先写测试，再写实现，是一个最简略的版本。\n<a name=c8GCn></a></p>\n<h2></h2>\n<p><a name=e2y0h></a></p>\n<h2>自动化单元测试</h2>\n<p>首先想到的是，我们的 service，应该具备转译指定的代码的能力，即输入源代码，输出转译后的代码；然后，需要有从 url 转译的能力；最后，是一个特别定制化的需求，可以在指定 url 之后，添加一点额外代码后再进行转译。一共是 3 个测试用例：</p>\n<p>typescript\nimport { BabelService } from ./babel.service;\nimport { testTargetUrl, transformedText } from ../test/constants;\nimport axios from axios</p>\n<p>describe(babel, () => {\nconst mockHttpService = {\nget: (url) => ({ toPromise: () => axios.get(url) })\n} as any</p>\n<p>const sut = new BabelService(mockHttpService);</p>\n<p>it(transforms, async () => {\nconst res = await sut.transform(class A {})\nexpect(res).toStrictEqual(transformedText)\n})</p>\n<p>it(transforms from url, async () => {\nconst res = await sut.transformFromUrl(testTargetUrl)\nexpect(res).toMatch(/use strict;/)\n})</p>\n<p>it(transform from url with extra, async () => {\nconst res = await sut.transformFromUrl(testTargetUrl, ReactDOM.render(<Game />, document.getElementById(root)))</p>\n<pre><code>expect(res).toMatch(/use strict;/)\n</code></pre>\n<p>})\n})</p>\n<p>实现上，首先把 babel.min.js 放在了项目目录里：</p>\n<p>接着在 babel service 里引用它，并实现相应的测试用例中描述的功能：<br /><a href=\"https://github.com/Jeff-Tian/serverless-space/blob/main/src/babel-service/babel.service.ts\">https://github.com/Jeff-Tian/serverless-space/blob/main/src/babel-service/babel.service.ts</a>\ntypescript\nimport {HttpService, Injectable} from @nestjs/common;</p>\n<p>const Babel = require(./babel.min.js)</p>\n<p>@Injectable()\nexport class BabelService {\nconstructor(private readonly httpService: HttpService) {</p>\n<pre><code>}\n\nasync transform(code) {\n    return Babel.transform(code.replace(/import.+;/g, ).replace(/export/g, ), {\n        presets: [env, react],\n        plugins: []\n    })?.code?.replace(/div/g, view).replace(/ol/g, view)\n}\n\nasync transformFromUrl(url, extra = ) {\n    const {data: code} = await this.httpService.get(url).toPromise()\n\n    return this.transform(code + extra)\n}\n</code></pre>\n<p>}</p>\n<p><a name=SUTmQ></a></p>\n<h2>自动化端到端测试</h2>\n<p>端到端测试，是描述了当前端发出的这样的请求，那么返回这样的响应的测试文件。这里写了两个用例，分别对应于单元测试中的前两个用例：</p>\n<p>typescript\nimport {INestApplication} from @nestjs/common\nimport {Test} from @nestjs/testing\nimport request from supertest\nimport {AppModule} from ../src/app.module\nimport {testTargetUrl, transformedText} from ../src/test/constants</p>\n<p>jest.setTimeout(50000)</p>\n<p>describe(Babel, () => {\nlet app: INestApplication</p>\n<pre><code>beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n        imports: [AppModule],\n    })\n        .compile()\n\n    app = moduleRef.createNestApplication()\n    await app.init()\n})\n\nit(transforms, async () => {\n    return request(app.getHttpServer())\n        .post(/graphql)\n        .send({\n            query: query transformTsx {\n            transform (sourceCode: class A {}) {\n                text\n            }\n        }\n        })\n        .expect({\n            data: {\n                transform: {\n                    text: transformedText\n                }\n            }\n        })\n        .expect(200)\n})\n\nit(transforms from url, async () => {\n    return request(app.getHttpServer())\n        .post(/graphql)\n        .send({\n            query: query transformTsx {\n            transform (url: ${testTargetUrl}) {\n                text\n            }\n        }\n        })\n        .expect(res => {\n            expect(res.body).toMatchObject({data: {transform: {text: /use strict;/}}})\n        })\n        .expect(200)\n})\n</code></pre>\n<p>})</p>\n<p>要实现这个，就定义了新的 GraphQL 的schema（使用 code first 方式，实现上是写了一个 model 文件，本质上是一个 typescript 类），并分别添加了 module 和 resolver。</p>\n<p>在一开始跑第一个端到端测试时，失败是理所当然。后来添加了 module 和 resolver 之后，第一个用例还是失败了！这时才知道，忘了在入口的 module 中引入我们的 babel module。</p>\n<p>diff</p>\n<p>@Module({</p>\n<ul>\n<li>imports: [CatsModule, RecipesModule, YuqueModule, ZhihuModule, GraphqlPluginModule, GraphQLModule.forRoot(graphqlOptions)],</li>\n</ul>\n<ul>\n<li>imports: [CatsModule, RecipesModule, YuqueModule, ZhihuModule, BabelModule, GraphqlPluginModule, GraphQLModule.forRoot(graphqlOptions)],</li>\n</ul>\n<p>})\nexport class AppModule {\n}</p>\n<p>看，这就是自动化测试的价值。没有测试，很容易遗漏一些环节，导致发布上线后不能如期工具，最终只能由用户来报告问题了。自动化测试可以在代码部署前快速发现问题，但并不是说有了自动化测试之后，就不需要人肉测试了，但是人肉只需要做些冒烟验证工作。</p>\n<p><a name=PcYaC></a></p>\n<h2>人肉冒烟测试</h2>\n<p>在单元测试和端到端测试都通过之后，部署上线了。然后人肉验证，发现挂了！</p>\n<p>这是该项目后期需要改进的地方。明明端到端测试都过了，上线后却挂了！不过这个概率很小，在以前的迭代过程中从来没有发生过这样的问题。</p>\n<p>这次挂掉的原因是本次迭代里有一个骚操作，即在 src 下加入了一个 babel.min.js 文件。跑自动化测试时，是用的 src 下的文件。但是部署上线后，却是 dist 目录中的文件，并且这个 babel.min.js 文件在编译过程（nest build）中，并没有从 src 自动拷贝到 dist 目录下，导致上线后找不到这个文件！</p>\n<p>以前没有出现过，因为总是添加 typescript 文件，它们都在 nest build 过程中自动变成 js 形式生成在 dist 目录下了。</p>\n<p>为了迅速修复，在 package.json 的 build 脚本上添加了将 babel.min.js 拷贝到 dist 目录下的步骤：</p>\n<p>diff</p>\n<ul>\n<li>build: nest build,</li>\n</ul>\n<ul>\n<li>build: nest build&#x26;&#x26;cp src/babel-service/babel.min.js dist/src/babel-service/babel.min.js,</li>\n</ul>\n<p>再次线上冒烟测试，如演示部分所示，通过。</p>\n<p><a name=t8Dcr></a></p>\n<h1>项目待改进点</h1>\n<p>加入自动化冒烟测试？这种测试是通过运行编译后的代码来运行。<br />要么，直接找到 nest 配置，可以自动将 js 文件在编译过程中拷贝到 dist 中的对应位置。<br />要么，不用这种 babel.min.js 文件，而且采用引用 babel npm 包的方式。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}