{"componentChunkName":"component---src-templates-post-js","path":"/posts/evv5x9/","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/evv5x9","relativePath":"posts/evv5x9","frontmatter":{"title":"Free Arch: babel as a service","stackbit_url_path":"posts/evv5x9","date":"2021-12-31T10:58:23","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>在昨天分享的《<a href=\"https://zhuanlan.zhihu.com/p/451816333\">FreeArch: 将 React 教程的井字棋游戏搬到微信小程序</a>》里提到的，通过实现一个 react-view，可以部分解决个人版微信小程序不能使用 webview 的缺憾。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/451816333\">FreeArch: 将 React 教程的井字棋游戏搬到微信小程序</a></p>\n<p>虽然完全可以在前端使用 babel standalone，动态转译 tsx 代码。但是由于 babel-standlone 压缩后的体积，也超过了小程序的代码限制，所以放在前端，只能在开发模式使用，没有办法发布。</p>\n<p>于是就要后端来提供 babel 服务了。可能网上有很多类似这样的服务，但为了更好的定制化，还是自己写一个吧。利用<a href=\"https://zhuanlan.zhihu.com/p/412196725\">万能 BFF</a>，分分钟部署一个。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/412196725\">一顿操作猛如虎，部署一个万能 BFF</a>\n<a name=PX0Va></a></p>\n<h1>在线演示</h1>\n<p><a href=\"https://sls.pa-ca.me/nest/graphql\">https://sls.pa-ca.me/nest/graphql</a></p>\n<p>先看一下，直接转译一个最简单的：<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/69439504e39872d5a287a21091f08921/88b57/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.72972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABOklEQVR42oWPy07CUBRF+98OnCBQHglxgIBEY+LYL/AHnJgoKhEI0N4+eD9a2t62tMu0OGCkJ1k5OcnO2VnKdfORauOegtriqtKmdv1AtXGHWr+lXO+i1rtcljpcFNoU1SZqtU2p0kEtdyjVOpQqLYpqC7Xc5Kb7hPL2MeD9c8BoYjDVLTTdRhMzJrqNLmYs5gteeoLnV0F/OKHXHzEcizx/zvdYMBgbKM7BZ7t3cf2APyeNcFcrdDMrMnOEaSMMCz1DmCzXG5Sd42EvN2x2Dp4fIGVIHMf5DqXkuN8RG1PC4RdbTUMzZ0x1A01YaMLEmi2w50tMe8F656C4XsAhw5cEMkRGEWF8JIpiks2KdLsmlQFH4CDjPHeOF4T4MiPK79NDX+J4AVF8zO2SNCVN05Ppr3GSJHmx+w8/CXCx09P9fe8AAAAASUVORK5CYII='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/69439504e39872d5a287a21091f08921/fcda8/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png\"\n        srcset=\"/static/69439504e39872d5a287a21091f08921/12f09/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png 148w,\n/static/69439504e39872d5a287a21091f08921/e4a3f/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png 295w,\n/static/69439504e39872d5a287a21091f08921/fcda8/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png 590w,\n/static/69439504e39872d5a287a21091f08921/efc66/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png 885w,\n/static/69439504e39872d5a287a21091f08921/c83ae/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png 1180w,\n/static/69439504e39872d5a287a21091f08921/88b57/1640945647061-9cf6da97-ebad-418d-b4c2-25d8c3dcf5d8.png 3582w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span><br />考虑到最终使用场景，是需要转译 replit （其实代码保存在 GitHub）的源文件，因为还提供了指定源文件的 url 进行转译的功能：<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/11693da7ad7a9e83fce54a9bb390b7b6/88b57/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.4054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAByklEQVR42pWSyY7TQBRF/dusUdPK1AtgkU4AwYYtK/6BLYgW8VAe4jlTJ46HcqaDqkKi3tCCkq7erZLq+NZ7Nt4OPzN484mb3ohXvZH2g9cf6dy9o3v3npvemBcv77ntj7ntDukORnR6Y7rdMZ3BmE7/Xp/3+yOGH75gfH+w+PFgY7shQZhqTaOcMMrI8zlOkPH1W8DE9vk5EZhOgPBjHD/C8aKz9yJMN8T2Ioxt1VCUNUVZ8dxqd3uSLCdKUqI4JUoy4jTTNYwS4iTjcbPFKMqGOFuwfCyoGomUkv3+QLs/cACt9gRbuUP4U2zh4bg+tvC1V1XtLccjzecY66JitljplLJtKZuWTSmp53OaJKYJAxphUQlLX55YAtMWWI6rvQIpsDrTwFVRky/WOq561ul04nA8ctztOLYtRyk5NQ3VeoMXRNeEwgtwvADhTbVXymZLjPW2ZrUpUb1UwL8tlVxdVskU0HRcne6S0rRdstkCo6wlSk+BKuVTqVXVEi8Ir3079y649jAIExarzXnKFz0LbCT+NL6CxJ/nqr3y6kP5fHkG/nvCiF+mjSXOg7gMRsn1p/8JbFrddPXfJdmMOM11VX1ToHVRas5vTY4n3bhXqbAAAAAASUVORK5CYII='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/11693da7ad7a9e83fce54a9bb390b7b6/fcda8/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png\"\n        srcset=\"/static/11693da7ad7a9e83fce54a9bb390b7b6/12f09/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png 148w,\n/static/11693da7ad7a9e83fce54a9bb390b7b6/e4a3f/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png 295w,\n/static/11693da7ad7a9e83fce54a9bb390b7b6/fcda8/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png 590w,\n/static/11693da7ad7a9e83fce54a9bb390b7b6/efc66/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png 885w,\n/static/11693da7ad7a9e83fce54a9bb390b7b6/c83ae/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png 1180w,\n/static/11693da7ad7a9e83fce54a9bb390b7b6/88b57/1640945899845-d4e0d171-a16a-4cdb-85c7-ac0cc4d4a17f.png 3582w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><a name=x3z3R></a></p>\n<h1>万能 BFF 源代码</h1>\n<p><a href=\"https://github.com/Jeff-Tian/serverless-space/tree/main/src/babel-service\">serverless-space/src/babel-service at main · Jeff-Tian/serverless-space</a>\n<a name=MWyBh></a></p>\n<h1>项目背景</h1>\n<p>项目采用了 nestjs 框架，对外提供 GraphQL 服务。nestjs graphql 项目，基本上是 module -> resolver -> service 这样的分层架构。\n<a name=Ip6vz></a></p>\n<h1>实现步骤</h1>\n<p>对于要实现一个 babel service，在 nest 项目中就是添加一个 babel service module，然后再添加一个 babel resolver 接收前端的请求，最后由 service 完成转译。为了省事儿，准备直接在项目里放置一个 babel.min.js 文件，用 require 方式获取 Babel 对象。</p>\n<p><a name=bPoMy></a></p>\n<h2>测试先行</h2>\n<p>尽管大概思路是非常清楚和简单粗暴，但是实践起来，还是要测试先行。实际的 TDD 过程就不详解了，为了叙述省事儿，略过了很多细枝末节。但是先写测试，再写实现，是一个最简略的版本。\n<a name=c8GCn></a></p>\n<h2></h2>\n<p><a name=e2y0h></a></p>\n<h2>自动化单元测试</h2>\n<p>首先想到的是，我们的 service，应该具备转译指定的代码的能力，即输入源代码，输出转译后的代码；然后，需要有从 url 转译的能力；最后，是一个特别定制化的需求，可以在指定 url 之后，添加一点额外代码后再进行转译。一共是 3 个测试用例：</p>\n<p><a href=\"https://github.com/Jeff-Tian/serverless-space/blob/main/src/babel-service/babel.service.spec.ts\">serverless-space/babel.service.spec.ts at main · Jeff-Tian/serverless-space</a></p>\n<p>typescript\nimport { BabelService } from ./babel.service;\nimport { testTargetUrl, transformedText } from ../test/constants;\nimport axios from axios</p>\n<p>describe(babel, () => {\nconst mockHttpService = {\nget: (url) => ({ toPromise: () => axios.get(url) })\n} as any</p>\n<p>const sut = new BabelService(mockHttpService);</p>\n<p>it(transforms, async () => {\nconst res = await sut.transform(class A {})\nexpect(res).toStrictEqual(transformedText)\n})</p>\n<p>it(transforms from url, async () => {\nconst res = await sut.transformFromUrl(testTargetUrl)\nexpect(res).toMatch(/use strict;/)\n})</p>\n<p>it(transform from url with extra, async () => {\nconst res = await sut.transformFromUrl(testTargetUrl, ReactDOM.render(<Game />, document.getElementById(root)))</p>\n<pre><code>expect(res).toMatch(/use strict;/)\n</code></pre>\n<p>})\n})</p>\n<p>实现上，首先把 babel.min.js 放在了项目目录里：<br /><a href=\"https://github.com/Jeff-Tian/serverless-space/blob/main/src/babel-service/babel.min.js\">https://github.com/Jeff-Tian/serverless-space/blob/main/src/babel-service/babel.min.js</a></p>\n<p>接着在 babel service 里引用它，并实现相应的测试用例中描述的功能：<br /><a href=\"https://github.com/Jeff-Tian/serverless-space/blob/main/src/babel-service/babel.service.ts\">https://github.com/Jeff-Tian/serverless-space/blob/main/src/babel-service/babel.service.ts</a>\ntypescript\nimport {HttpService, Injectable} from @nestjs/common;</p>\n<p>const Babel = require(./babel.min.js)</p>\n<p>@Injectable()\nexport class BabelService {\nconstructor(private readonly httpService: HttpService) {</p>\n<pre><code>}\n\nasync transform(code) {\n    return Babel.transform(code.replace(/import.+;/g, ).replace(/export/g, ), {\n        presets: [env, react],\n        plugins: []\n    })?.code?.replace(/div/g, view).replace(/ol/g, view)\n}\n\nasync transformFromUrl(url, extra = ) {\n    const {data: code} = await this.httpService.get(url).toPromise()\n\n    return this.transform(code + extra)\n}\n</code></pre>\n<p>}</p>\n<p><a name=SUTmQ></a></p>\n<h2>自动化端到端测试</h2>\n<p>端到端测试，是描述了当前端发出的这样的请求，那么返回这样的响应的测试文件。这里写了两个用例，分别对应于单元测试中的前两个用例：</p>\n<p><a href=\"https://github.com/Jeff-Tian/serverless-space/blob/main/e2e/babel.e2e-spec.ts\">serverless-space/babel.e2e-spec.ts at main · Jeff-Tian/serverless-space</a>\ntypescript\nimport {INestApplication} from @nestjs/common\nimport {Test} from @nestjs/testing\nimport request from supertest\nimport {AppModule} from ../src/app.module\nimport {testTargetUrl, transformedText} from ../src/test/constants</p>\n<p>jest.setTimeout(50000)</p>\n<p>describe(Babel, () => {\nlet app: INestApplication</p>\n<pre><code>beforeAll(async () => {\n    const moduleRef = await Test.createTestingModule({\n        imports: [AppModule],\n    })\n        .compile()\n\n    app = moduleRef.createNestApplication()\n    await app.init()\n})\n\nit(transforms, async () => {\n    return request(app.getHttpServer())\n        .post(/graphql)\n        .send({\n            query: query transformTsx {\n            transform (sourceCode: class A {}) {\n                text\n            }\n        }\n        })\n        .expect({\n            data: {\n                transform: {\n                    text: transformedText\n                }\n            }\n        })\n        .expect(200)\n})\n\nit(transforms from url, async () => {\n    return request(app.getHttpServer())\n        .post(/graphql)\n        .send({\n            query: query transformTsx {\n            transform (url: ${testTargetUrl}) {\n                text\n            }\n        }\n        })\n        .expect(res => {\n            expect(res.body).toMatchObject({data: {transform: {text: /use strict;/}}})\n        })\n        .expect(200)\n})\n</code></pre>\n<p>})</p>\n<p>要实现这个，就定义了新的 GraphQL 的schema（使用 code first 方式，实现上是写了一个 model 文件，本质上是一个 typescript 类），并分别添加了 module 和 resolver。</p>\n<p>在一开始跑第一个端到端测试时，失败是理所当然。后来添加了 module 和 resolver 之后，第一个用例还是失败了！这时才知道，忘了在入口的 module 中引入我们的 babel module。</p>\n<p><a href=\"https://github.com/Jeff-Tian/serverless-space/commit/f665e8afcf0354a8fe2363cfe6015483ee2554a5#diff-089f4f2474b64391c42b6e66aed33977e132058d92108f0a63234a7862e1f8b8\">feat: add babel module · Jeff-Tian/serverless-space@f665e8a</a>\ndiff</p>\n<p>@Module({</p>\n<ul>\n<li>imports: [CatsModule, RecipesModule, YuqueModule, ZhihuModule, GraphqlPluginModule, GraphQLModule.forRoot(graphqlOptions)],</li>\n</ul>\n<ul>\n<li>imports: [CatsModule, RecipesModule, YuqueModule, ZhihuModule, BabelModule, GraphqlPluginModule, GraphQLModule.forRoot(graphqlOptions)],</li>\n</ul>\n<p>})\nexport class AppModule {\n}</p>\n<p>看，这就是自动化测试的价值。没有测试，很容易遗漏一些环节，导致发布上线后不能如期工具，最终只能由用户来报告问题了。自动化测试可以在代码部署前快速发现问题，但并不是说有了自动化测试之后，就不需要人肉测试了，但是人肉只需要做些冒烟验证工作。</p>\n<p><a name=PcYaC></a></p>\n<h2>人肉冒烟测试</h2>\n<p>在单元测试和端到端测试都通过之后，部署上线了。然后人肉验证，发现挂了！</p>\n<p>这是该项目后期需要改进的地方。明明端到端测试都过了，上线后却挂了！不过这个概率很小，在以前的迭代过程中从来没有发生过这样的问题。</p>\n<p>这次挂掉的原因是本次迭代里有一个骚操作，即在 src 下加入了一个 babel.min.js 文件。跑自动化测试时，是用的 src 下的文件。但是部署上线后，却是 dist 目录中的文件，并且这个 babel.min.js 文件在编译过程（nest build）中，并没有从 src 自动拷贝到 dist 目录下，导致上线后找不到这个文件！</p>\n<p>以前没有出现过，因为总是添加 typescript 文件，它们都在 nest build 过程中自动变成 js 形式生成在 dist 目录下了。</p>\n<p>为了迅速修复，在 package.json 的 build 脚本上添加了将 babel.min.js 拷贝到 dist 目录下的步骤：</p>\n<p><a href=\"https://github.com/Jeff-Tian/serverless-space/commit/e4ee6de47a146a772f4fe8548134d361ce3f1806#diff-7ae45ad102eab3b6d7e7896acd08c427a9b25b346470d7bc6507b6481575d519\">https://github.com/Jeff-Tian/serverless-space/commit/e4ee6de47a146a772f4fe8548134d361ce3f1806#diff-7ae45ad102eab3b6d7e7896acd08c427a9b25b346470d7bc6507b6481575d519</a></p>\n<p>diff</p>\n<ul>\n<li>build: nest build,</li>\n</ul>\n<ul>\n<li>build: nest build&#x26;&#x26;cp src/babel-service/babel.min.js dist/src/babel-service/babel.min.js,</li>\n</ul>\n<p>再次线上冒烟测试，如演示部分所示，通过。</p>\n<p><a name=t8Dcr></a></p>\n<h1>项目待改进点</h1>\n<p>加入自动化冒烟测试？这种测试是通过运行编译后的代码来运行。<br />要么，直接找到 nest 配置，可以自动将 js 文件在编译过程中拷贝到 dist 中的对应位置。<br />要么，不用这种 babel.min.js 文件，而且采用引用 babel npm 包的方式。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[],"slicesMap":{}}