{"componentChunkName":"component---src-templates-post-js","path":"/posts/vvkl0c","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/vvkl0c","relativePath":"posts/vvkl0c","frontmatter":{"title":"通过写测试来学习事件驱动设计","stackbit_url_path":"posts/vvkl0c","date":"2022-07-25T03:29:53","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>拉下一个项目到本地，第一步就是跑测试。没有测试那就得先写测试，确保后续迭代过程中不会改坏原有系统。</p>\n<p>在写测试时，经常会需要隔离外部依赖，这可以通过一些 Mock 库来实现。但是，除非有频繁的相同 Mock 逻辑，否则完全可以自行手写 Mock，这不仅可以减少引入第三方库，更可以通过手写 Mock 来学习外部依赖的设计。</p>\n<p>尽管在测试中，没有使用到真正的依赖库，而是用了自己的一个假的实现，但是假的实现必须拥有同样的对外界面。又由于它是假的，于是它可以很简单，更方便看清楚最基本的设计。\n<a name=bMwGv></a></p>\n<h1>实例</h1>\n<p>最近拉了一个自己写的老项目，其中一个场景，是测试登录失败：</p>\n<p>假定输入了错误的用户名或者密码，点击登录，期待页面组件的状态中包含错误信息。</p>\n<p>点击登录后，实现代码是使用** XMLHttpRequest** 向后端服务发送请求，传递用户名密码。那么在测试中，为了移除后端服务这个依赖，可以把 XMLHttpRequest 替换成一个假的实现，不需要让它真的发送网络请求，只需要接收以及返回测试需要的数据即可。</p>\n<p><a name=lOxNO></a></p>\n<h2>登录的实际实现</h2>\n<p>重点是这个 processForm 函数，它在用户提交表单后触发，收集组件中的用户名和密码，使用 XMLHttpRequest 构造一个 xhr 请求。它先设置好一个事件的回调，即 load 事件的回调，然后就发送这个 xhr了。在回调函数里异步拿到了服务器的返回响应，并针对不同的情况做不同的 UI 更新。</p>\n<p>javascript\nprocessForm(event) {\nevent.preventDefault();</p>\n<p>const username = encodeURIComponent(this.state.user.name);\nconst password = encodeURIComponent(this.state.user.password);\nconst formData = username=${username}&#x26;password=${password}&#x26;returnUrl=/admin/orders;</p>\n<p>let self = this;</p>\n<p>const xhr = new XMLHttpRequest();\nxhr.open(post, /admin/api/sign-in);\nconsole.log(signing requesting...)\nxhr.setRequestHeader(Content-type, application/x-www-form-urlencoded);\nxhr.addEventListener(load, () => {\nif (xhr.status === 200) {\nconsole.log(xhr = , xhr);\ntry {\nlet json = JSON.parse(xhr.response);</p>\n<pre><code>    self.setState({\n      errors: {},\n      successMessage: welcome\n    });\n\n    Auth.authenticateUser(json.token);\n\n    let returnUrl = json.returnUrl || /;\n    console.log(returnUrl);\n    browserHistory.push(returnUrl);\n    console.log(should redirect);\n  } catch (ex) {\n    console.error(ex = , ex);\n    const errors = ex.message || JSON.stringify(ex);\n\n    self.setState({\n      errors\n    });\n  }\n} else {\n  console.error(err = , xhr.response);\n  const errors = xhr.response.errors ? xhr.response.errors : {};\n  errors.summary = xhr.response.message || xhr.response;\n\n  self.setState({\n    errors\n  });\n}\n</code></pre>\n<p>});\nxhr.send(formData);\n}</p>\n<p><a name=ECNL8></a></p>\n<h2>异步事件驱动设计分析</h2>\n<p>这是一个典型的异步事件驱动代码实例。因为网络请求比较耗时，所以采用回调的设计是很合理也很高效的。除了 XMLHttpRequest，还有很多其他的对象，都遵循了这种设计，即通过一个事件监听函数，来接收某些事件的回调函数，即预先指定，当某某事件发生时，就该做些什么响应。然后，通过一些某件触发函数，用来通知系统，什么事件已触发。</p>\n<p>这样的设计之所以是合理并高效的，就是因为<strong>它将事件的处理和事件的触发做了漂亮的解藕</strong>，可以将事件的触发和处理分别放在不同的地方维护，同时这个回调机制使得不必等待事件的发生，只需要预先告诉系统当事件发生时要做什么处理就好，告诉完了就可以继续去干其他的事情。</p>\n<p>这个实例是一个很老的项目，用了 XMLHttpRequest 这个对象。目前 nodejs 的 event emitter，以及 Nest Js 库中的 EventEmitter2，其实都是这样的设计。比如 Nest Js 中的 EventEmitter2，在 Module 中注入 EventEmitterModule 后，就可以在应用程序中这样使用：</p>\n<p>typescript\n// 事件的发生和处理解藕\nthis.eventEmitter.emit(xx事件, {payload})</p>\n<p>// 事件的处理\n@OnEvent(xx事件)\npublic async handleXX(payload) {\n...\n}</p>\n<p>那么这样的设计是怎么实现的呢？</p>\n<p><a name=KtTCA></a></p>\n<h2>测试的可贵</h2>\n<p>这种设计虽然处处可见，但如果不是因为要写测试，我还真的没有去思考过它的实现方式。所以写测试的可贵之处，不仅仅在于它能帮助我构建一个安全网，还可以逼迫我思考当前系统用到的设计。</p>\n<p><a name=gVhHL></a></p>\n<h2>通过最简单的实现搞懂事件驱动设计原理</h2>\n<p>为了能够模拟这个 XMLHttpRequest，我开始思考一个最简单的实现。既然它公开了一个添加事件回调函数的接口，那么它的内部一定需要维护一系列的事件回调函数。在最简单的场景下，一个事件对应一个回调函数（因为目前实现代码也没有对同一个事件添加多个回调函数）；再简单一点，只支持一个事件（因为目前的实现场景只依赖这一个事件），那么，这个维护工作就简化成了一个可以保存回调函数变量。于是，有了这个雏形：</p>\n<p>javascript\nconst mockXhr = function () {\n}</p>\n<p>mockXhr.prototype.addEventListener = function (_, callbackHandler) {\nthis.func = callbackHandler\n}</p>\n<p>另外，它还公开了一个用来触发事件发生的接口，这个接口实际上就是去调用事件注册好的回调函数而已。对于我要测试的这个场景，是希望能够触发登录失败的响应，于是，可以这样写：</p>\n<p>javascript</p>\n<p>xhrMock.prototype.send = function () {\nthis.status = 401;\nthis.response = authErrorMessage;</p>\n<pre><code>this.func();\n</code></pre>\n<p>}</p>\n<p>整个 XMLHttpRequest 的 mock 对象，虽然简单到简陋，但是通过手工捏造了一个假的实现，XMLHttpRequest 瞬间不再神秘了。有意思的是，这样做完全可行，测试跑得欢畅无比。源代码见： <a href=\"https://github.com/Jeff-Tian/v/blob/master/client/tests/admin/Auth.test.js\">https://github.com/Jeff-Tian/v/blob/master/client/tests/admin/Auth.test.js</a></p>\n<p>当然，要注意在跑测试前用 mock 对象替换原来的 XMLHttpRequest。由于我们在 JavaScript 的世界里，于是只要通过这样就行了：</p>\n<p>javascript\nwindow.XMLHttpRequest = xhrMock;</p>\n<p>it(should fail login when input is bad, async () => {\nconst username = wrapper.find(input[name=name]);\nusername.simulate(change, {\ntarget: {name: name, value: badguy}\n});</p>\n<p>const password = wrapper.find(input[name=password]);\npassword.simulate(change, {\ntarget: {name: password, value: nopass2}\n});</p>\n<p>wrapper.find(form).simulate(submit, {\npreventDefault() {\n}\n});</p>\n<p>wrapper.update();</p>\n<p>expect(wrapper.state().errors).toEqual({summary: authErrorMessage});\n})</p>\n<p><a name=DGOQv></a></p>\n<h1>总结</h1>\n<p>写测试逼迫我去思考代码的设计，这不仅仅对自己的代码有效。哪怕是第三方代码，由于要去模拟它，在不使用其他模拟框架时，就需要思考一下第三方代码的实现了，并且可以通过写最简单的实现，来剖析它的内部原理，让它们不再神秘。</p>\n<p>本文通过一个具体的例子，将 XMLHttpRequest 对象，甚至任何事件驱动的设计本质暴露出来：</p>\n<ul>\n<li>公开的事件处理函数注册接口，无非是事件“记住”什么事件对应哪些处理函数。这可以通过一个函数变量（最简单的情况），或者一个数组，或者一个哈希映射等等来实现。</li>\n<li>公开的事件触发接口，无非是让系统知道该去寻找哪个事件处理函数的一种通知机制罢了。</li>\n</ul>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}