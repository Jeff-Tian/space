{"componentChunkName":"component---src-templates-post-js","path":"/posts/ie87li","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/ie87li","relativePath":"posts/ie87li","frontmatter":{"title":"同步用户微信头像的 NodeJs 实现","stackbit_url_path":"posts/ie87li","date":"2021-06-29T09:53:58","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>对于使用微信登录的系统，在用户授权后，将其微信头像直接同步到服务器，可以省去用户上传的操作。本文最终给出一个 NodeJs 中间层的实现，并展示实现的过程和在实施过程中几个需要注意的地方。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1624879466049-62e9674d-08aa-41cb-b6a5-000e913020b1.png#clientId=u3d73ec44-36c4-4&#x26;from=paste&#x26;id=u891c0c81&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=638&#x26;originWidth=413&#x26;originalType=binary%E2%88%B6=1&#x26;size=44464&#x26;status=done&#x26;style=none&#x26;taskId=u5913daf1-bb2b-4805-a07a-d0e2db8e928\" alt=\"image.png\"></p>\n<p><a name=V5Kpa></a></p>\n<h1>BFF 架构</h1>\n<p>微服务架构已然成为了企业信息化架构中的主流，这种架构风格给前端带来了挑战。为了灵活应对业务需求的变化和适配不同的前端用户体验，BFF 层应运而生。</p>\n<p>由于天然的限制或者使用场景的区别，不同的前端用户体验并不一致。拿阿迪达斯的微信小程序和其原生 APP 举例，你会看到用户体验完全不同，有些是因为微信小程序的限制（比如分享体验），有些是不同的产品运营需要。</p>\n<table>\n<thead>\n<tr>\n<th><strong>小程序</strong></th>\n<th><strong>APP</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1624880156326-3cf94d3b-3b20-46ec-963e-68ccdc664158.png#clientId=u3d73ec44-36c4-4&#x26;from=paste&#x26;height=520&#x26;id=ucfdb05b7&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=2079&#x26;originWidth=960&#x26;originalType=binary%E2%88%B6=1&#x26;size=1232512&#x26;status=done&#x26;style=none&#x26;taskId=u06c1f753-c68e-4f52-972c-51e2bd418c6&#x26;width=240\" alt=\"image.png\"></td>\n<td><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1624880164682-0aea42b9-79a7-4542-bb07-9f12c31dedcc.png#clientId=u3d73ec44-36c4-4&#x26;from=paste&#x26;height=520&#x26;id=u30ccd415&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=2079&#x26;originWidth=960&#x26;originalType=binary%E2%88%B6=1&#x26;size=2405575&#x26;status=done&#x26;style=none&#x26;taskId=u61930d82-38b2-402b-8149-15ab508e4a3&#x26;width=240\" alt=\"image.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>BFF 是 Backend for Frontend 的简称，它用来对众多后端微服务进行聚合和裁剪，以适配前端。如今，<strong>端用户体验层 -> 网关层 -> BFF 层 -> 微服务层</strong>这种分层模式已经成为了典型的现代微服务架构分层方式。</p>\n<p><a name=L4Pkg></a></p>\n<h1>NodeJs</h1>\n<p>NodeJs 的出现使得 JavaScript 可以运行在服务器上，并且天然适合网络 IO 密集型的场景，以及不适合计算密集型场景。这使得它作为 BFF 层非常适合，因为 BFF 层通常只是联结前端与后端，做一些透传，没有密集的计算，但是重网络传输。</p>\n<p><a name=pXaj6></a></p>\n<h1>分析微信头像的存储方案</h1>\n<p><a name=h7ysH></a></p>\n<h2>直接存储微信头像的 url</h2>\n<p>比如，我目前的微信头像 url 是 <a href=\"https://thirdwx.qlogo.cn/mmopen/vi_32/rgPgbf5XE2ancz9ibobSibZEMPOibp4LdsQEXiaQeRZ78WJgVe7xgMamYXd6eibo9rg0Wje1rnh9aLMc87DVS4vrItA/132\">https://thirdwx.qlogo.cn/mmopen/vi_32/rgPgbf5XE2ancz9ibobSibZEMPOibp4LdsQEXiaQeRZ78WJgVe7xgMamYXd6eibo9rg0Wje1rnh9aLMc87DVS4vrItA/132</a>。显然后端可以很简单的接收一个字符串，将其存储起来，这样前端下次拿到这个 url，就可以展示出来。</p>\n<p>但是这样做有个问题，以上链接是微信的 CDN 地址。一旦用户在微信端更新了头像，那么上面的地址将不再被使用。如果某一天它被清除了，那么系统的前端展示用户头像时将是一个死链接的图片。所以方案得改成：</p>\n<p><a name=b1BEz></a></p>\n<h2>将微信头像 url 下载下来以图片文件格式存储</h2>\n<p>这样就需要后端实现一个文件上传的接口，然后由 BFF 层把前端传过来的 url 转成表单数据传输给后端。所以最终后端不是存储一个字符串，而是存储图片文件。</p>\n<p>这样就没有用户更改微信头像后，系统中的头像失效的问题。至于微信头像更新后，系统中还是老的图片的不同步问题，第一种方案也不能解决。实际上这种情况下只需要再次同步即可，至于如何自动同步，不在本文讨论范围内。</p>\n<p><a name=kvpFi></a></p>\n<h2>结论</h2>\n<p>只需要在 BFF 层使用 NodeJs 将微信头像的 url 下载下来，再调用后端的文件上传接口即可。</p>\n<p><a name=vHkrS></a></p>\n<h1>代码实现</h1>\n<p>需求分析明确后，只差写代码了。经常有人问，高手写代码是不是不用百度，直接啪啪啪就能写出来？实际上，不需要搜索就能写代码的，那说明是熟练工，同样的事情干过很多回了。对于高手，也可能接到不熟悉的任务，这时他可能不用百度，而是用 Google 和 StackOverflow。</p>\n<p><a name=n0Qn6></a></p>\n<h2>Axios</h2>\n<p>既然要使用 NodeJs 上传文件到后端，那么就需要给后端发起一个 Http 请求。通过简单搜索就能知道在 NodeJs 的世界里，Axios 是一个不错的 Http 客户端，因此再进一步搜索如何使用 Axios 发起一个文件上传的 Http 请求。</p>\n<p><a name=wLNiD></a></p>\n<h2>坑</h2>\n<p>搜索工具是程序员经常要使用的，虽然说如今搜索方便，但是要甄别结果的可靠性并没那么容易。被一些答案带到坑里是常有的事情。比如搜索使用 NodeJs 上传文件，多数答案如下：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1624955881002-971a3f3f-34c6-4971-9d1b-5ed3df6958b6.png#clientId=u9f3665ae-ccbd-4&#x26;from=paste&#x26;id=ua5ed6dc9&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=446&#x26;originWidth=780&#x26;originalType=binary%E2%88%B6=2&#x26;size=74846&#x26;status=done&#x26;style=none&#x26;taskId=ue8edcc3c-9d02-4b0c-b5d5-53271e3a1d1\" alt=\"image.png\">\njavascript\nvar formData = new FormData();\nformData.append(image, yourFile);\naxios.post(upload_file, formData, {\nheaders: {\nContent-Type: multipart/form-data\n}\n})</p>\n<p>注意上面的代码显式指定了 Content-Type 这个请求头，然后实际试过后你就知道这并不工作！</p>\n<p><a name=Uy8z7></a></p>\n<h2>Postman</h2>\n<p>Postman 是一个强大的 Http 请求监控工具，可以按需定制请求体。BFF 层要同步微信头像，无非就是要调用后端接口，发送一个 Http 请求，将用户头像存储起来。因此真正的高手对这个需求是真的不会去搜索的，而是直接使用 Postman 构造一个 Http 请求，手动上传文件，拿到后端的响应结果。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1624956609988-7e3879c5-0f50-43a7-b370-b389ee53428d.png#clientId=u9f3665ae-ccbd-4&#x26;from=paste&#x26;id=u9b3dddb7&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=553&#x26;originWidth=956&#x26;originalType=binary%E2%88%B6=2&#x26;size=76745&#x26;status=done&#x26;style=none&#x26;taskId=u7ac30b6f-11f9-4475-9516-ecb9c066d6d\" alt=\"image.png\"><br />然后，点击代码，就能选择将刚才手动构造的 Http 请求，转换成可以构造同样请求的代码。我们选择 NodeJs Axios：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1624956825959-645ef07f-d26e-488d-8ad1-46add66bcf21.png#clientId=u9f3665ae-ccbd-4&#x26;from=paste&#x26;id=u8a4495cf&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=701&#x26;originWidth=1419&#x26;originalType=binary%E2%88%B6=2&#x26;size=166239&#x26;status=done&#x26;style=none&#x26;taskId=u48a926ef-548f-4d1a-a68d-ef483bd4027\" alt=\"image.png\">\n<a name=GemWL></a></p>\n<h2>抄作业</h2>\n<p>从 Postman 生成的代码可以看出，第一 NodeJs 的世界里，没有原生的表单数据结构，需要引入 form-data 包；第二在请求头里不能直接写死 Content-Type = multipart/form-data，而是要用 form-data 生成的请求头。</p>\n<p><a name=VEf3d></a></p>\n<h2>题外话</h2>\n<p>如果是前端直接文件上传，那么在 Browser 的 JavaScript 世界里，是自带 FormData 数据结构的，这时候要显式<strong>不指定</strong>  Content-Type，以实现自动生成 Content-Type 请求头。对于文件上传不能显示指定 Content-Type 的原因是，构造 Http 请求时，payload 中要使用 Content-Type 请求头中的 boundary 来分割文件和其他非文件字段，而这个 boundary 需要动态生成。如果不显示指定 Content-Type，就能享受浏览器端 FormData 或者 NodeJs 端的 form-data 自动生成的 Content-Type 以及 boundary。</p>\n<p><a name=bEXn1></a></p>\n<h2>TDD</h2>\n<p>在写实现代码前，建议先将自动化测试代码写上，以便构建重构屏障。详细步骤参考 TDD 相关的文章。</p>\n<p><a name=WJ8V2></a></p>\n<h2>jest/nock/TypeScript</h2>\n<p>在实际的 NodeJs 工程项目中，还是建议引入 TypeScript，以享受类型系统带来的好处。这里使用 jest 测试框架。为了控制后端的 Http 响应，可以使用 nock 将之前的 Postman 抓到的后端服务器响应作为 mock。</p>\n<p>后端服务器的 API 可能做了 token 验证，只信任指定的客户端（BFF 层）发来的请求，因此还需要做好相关 Token 端点的 nock，最终测试代码如下（假定要将实现写在一个叫 MemberService 的类中）：</p>\n<p>typescript\nimport { MemberService } from ./member.service\nimport * as nock from nock</p>\n<p>describe(MemberService, () => {\nbeforeEach(async () => {\nconst mockConfig = {\nbackend: {\nurl: <a href=\"https://your.back.end\">https://your.back.end</a>,\nauth: {\nurl: <a href=\"https://your.back.end/auth/token\">https://your.back.end/auth/token</a>,\nclientId: fakeId,\nclientSecret: fakeSecret,\nclientKey: fakeKey\n}\n}\n}</p>\n<pre><code>describe(update users head image, () => {\n  it(pipe weixin head img to back end, async () => {\n    const mockRes = {\n      code: 200,\n      message: 操作成功,\n      success: true,\n      data: https://upload.image.url,\n      time: 2021-06-29 11:20:30\n    }\n    \n    nock(mockConfig.backend.url).post(/auth/token).reply(200, {status: SUCCESS, data: {access_token: xxx, expires_in: 3600, refresh_token: yyy}})\n    nock(mockConfig.backend.url).put(/upload/image/head/abcdefg).reply(200, mockRes)\n    \n    const sut = new MemberService(nockConfig)\n    \n    const res = await sut.updateAvatar(abcdefg, https://thirdwx.qlogo.cn/mmopen/vi_32/rgPgbf5XE2ancz9ibobSibZEMPOibp4LdsQEXiaQeRZ78WJgVe7xgMamYXd6eibo9rg0Wje1rnh9aLMc87DVS4vrItA/132)\n    expect(res).toStrictEqual(mockRes)\n  })\n})\n</code></pre>\n<p>})\n})</p>\n<p><a name=MuB0l></a></p>\n<h2>流到流</h2>\n<p>前面分析了，实现代码只需要将微信的 url 对应的图片下载下来，再上传到后端服务器即可，但是为了提高效率，可以不用等待先全部下载完毕再进行上传，而是将下载流直接对接到上传流上。这只需要对 Postman 生成的代码稍加改造。仔细观察 Postman 生成的代码，由于我们是从本地文件系统选择的文件构造出的请求，因此生成的代码创建了一个本地文件读取流，我们需要把这个本地文件读取流改造成远程文件下载流。</p>\n<p>下载文件其实也就是想微信服务器（CDN）端构造一个 Http GET 请求，仍然采用 Axios，那么只需要设置 responseType 为 stream，就能得到文件下载流：</p>\n<p>typescript\nimport axios from axios\nimport * as FormData from form-data</p>\n<p>export class MemberService {\nconstructor(private readonly config: Config) {}</p>\n<p>async updateAvatar(userId: string, avatar: string | undefined) {\nif (!avatar) {\nreturn undefined\n}</p>\n<pre><code>// 大致逻辑，实际上从统一的令牌管理类中拿可用的 token\n\nconst {data: {access_token}} = await axios.post(this.config.backend.auth.url, {clientId, clientSecret, ...})\n\nconst formData = new FormData()\nformData.append(headImg, (await axios.get(avatar, { responseType: stream })).data, headImage.jpg)\n\nreturn axios.put(${this.config.backend.url}/upload/image/head/${userId}, {\n  data: formData,\n  headers: {\n    Authorization: Bearer ${access_token},\n    ...formData.getHeaders(),\n  }\n})\n</code></pre>\n<p>}\n}</p>\n<p><a name=cRIOS></a></p>\n<h1>总结</h1>\n<p>在实际的 BFF 开发中，可以使用 Postman 手动调用后端服务，然后生成实际的代码，这节省了搜索的工作，而且保证代码可靠。</p>\n<p>对于微信头像的同步，一定不能只保存微信的 CDN url，而要下载后保存图片。通过使用 NodeJs Axios，下载到上传是可以很方便地流到流接上的。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}