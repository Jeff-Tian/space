{"componentChunkName":"component---src-templates-post-js","path":"/posts/annht2","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/annht2","relativePath":"posts/annht2","frontmatter":{"title":"给 SpringBoot 服务添加健康检查","stackbit_url_path":"posts/annht2","date":"2021-11-11T12:31:45","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=quxnQ></a></p>\n<h1>引子</h1>\n<p>公司的后端服务基于 SpringBoot 开发，部署在 K8S 集群中。在平时开发过程中，由于部署频繁，经常导致服务队对外表现为 502 不可用，非常影响前端开发体验。</p>\n<p>如果服务长时间不可用，那么前端只能启用 mock 模式进行开发了。具体做法可以参见《<a href=\"https://zhuanlan.zhihu.com/p/351121637\">前后端分离开发中前端需要克服的挑战</a>》一文。</p>\n<p>尽管前端有办法，但是作为后端服务，还是得保证服务的可用性，不能随意找借口搪塞。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1636631963195-0787d3ab-e3e4-4ae0-8db2-bdfcffa179ee.png#clientId=u8a7784a7-47a7-4&#x26;from=paste&#x26;height=1864&#x26;id=uc0d2dd06&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1864&#x26;originWidth=961&#x26;originalType=binary%E2%88%B6=1&#x26;size=783809&#x26;status=done&#x26;style=none&#x26;taskId=u34000c3a-0606-4a04-bf7c-4989cff3098&#x26;width=961\" alt=\"image.png\"></p>\n<p>实际上，公司的 dev 环境也在 AWS 集群上，配置并不低，而且需要的话可以继续调高配置。在部署时，观察 pod 的状态，的确是滚动更新的。</p>\n<p>之所以在部署时服务会不可用，是因为没有配置服务就绪探针，K8S 没有办法获取 pod 里应用的状态，只能检查 pod 的状态。只要 pod 起来了，流量就会路由给它，但这时如果应用并未启动完毕，就会导致对外表现为 502 Bad Gateway。</p>\n<p>因此，要解决这个问题，实现服务无宕机更新，就只需要配置好探针就行了。</p>\n<p><a name=IwXs3></a></p>\n<h1>给 SpringBoot 应用添加 actuator</h1>\n<p><a name=aZGPQ></a></p>\n<h2>测试</h2>\n<p>第一步，先把测试写好，文档化我们期待的行为：</p>\n<p>java\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.availability.ApplicationAvailability;\nimport org.springframework.boot.availability.AvailabilityChangeEvent;\nimport org.springframework.boot.availability.LivenessState;\nimport org.springframework.boot.availability.ReadinessState;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.test.context.ActiveProfiles;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport org.springframework.test.web.servlet.MockMvc;</p>\n<p>import static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</p>\n<p>@RunWith(SpringRunner.class)\n@ActiveProfiles(test)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\npublic class HealthCheckControllerTest {\n@Autowired\nprivate ApplicationAvailability applicationAvailability;</p>\n<pre><code>@Autowired\nprivate MockMvc mockMvc;\n\n@Autowired private ApplicationContext context;\n\n@Test\npublic void testHealthCheck() throws Exception {\n    assertThat(applicationAvailability.getLivenessState())\n            .isEqualTo(LivenessState.CORRECT);\n\n    mockMvc.perform(get(/healthz/liveness))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath($.status.code).value(UP));\n\n    AvailabilityChangeEvent.publish(context, ReadinessState.REFUSING_TRAFFIC);\n\n    assertThat(applicationAvailability.getReadinessState())\n            .isEqualTo(ReadinessState.REFUSING_TRAFFIC);\n    mockMvc.perform(get(/healthz/readiness))\n            .andExpect(status().isServiceUnavailable())\n            .andExpect(jsonPath($.status.code).value(OUT_OF_SERVICE));\n\n}\n</code></pre>\n<p>}</p>\n<p><a name=pXLTG></a></p>\n<h2>添加依赖</h2>\n<p>以 maven 项目为例，在 pom 文件中添加：</p>\n<p>xml\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-starter-actuator</artifactId>\n</dependency></p>\n<p><a name=tgjWq></a></p>\n<h2>配置项目</h2>\n<p>可以在 bootstrap.yml 中增加这样的配置：</p>\n<p>yaml\nmanagement:\nendpoint:\nhealth:\nprobes:\nenabled: true\nlivenessState:\nenabled: true\nreadinessState:\nenabled: true\nendpoints:\nweb:\nbase-path: /\npath-mapping:\nhealth: healthz</p>\n<p>这时测试可以通过了。也可以本地启动进行手动端到端验证。先启动：</p>\n<p>shell\nmvn clean install &#x26;&#x26; mvn spring-boot:run -pl your-representation-layer</p>\n<p>执行：</p>\n<p>shell\ncurl <a href=\"http://localhost:your-port/healthz/liveness\">http://localhost:your-port/healthz/liveness</a></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1636632900548-3422d944-c4e5-4caf-946b-1e94f166e6f7.png#clientId=u8a7784a7-47a7-4&#x26;from=paste&#x26;height=497&#x26;id=u7f96fe7c&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=497&#x26;originWidth=782&#x26;originalType=binary%E2%88%B6=1&#x26;size=36636&#x26;status=done&#x26;style=none&#x26;taskId=u39f091ef-ebb1-4e21-9d2b-a2e234e4a96&#x26;width=782\" alt=\"image.png\"></p>\n<p>shell\ncurl <a href=\"http://localhost:your-port/healthz/readiness\">http://localhost:your-port/healthz/readiness</a></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1636632949891-7812c819-1055-42d2-bc2f-df1092bbed61.png#clientId=u8a7784a7-47a7-4&#x26;from=paste&#x26;height=527&#x26;id=uf7827578&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=527&#x26;originWidth=608&#x26;originalType=binary%E2%88%B6=1&#x26;size=34767&#x26;status=done&#x26;style=none&#x26;taskId=u005cd6a1-0541-471d-aae2-aa86b537107&#x26;width=608\" alt=\"image.png\">\n<a name=li0jE></a></p>\n<h1>在 deployment 文件里配置探针</h1>\n<p>在 deployment 文件中增加如下配置项：</p>\n<p>yaml</p>\n<pre><code>    readinessProbe:\n      httpGet:\n        path: /healthz/readiness\n        port: 8080\n      initialDelaySeconds: 30\n      timeoutSeconds: 10\n    livenessProbe:\n      httpGet:\n        path: /healthz/liveness\n        port: 8080\n      initialDelaySeconds: 130\n      timeoutSeconds: 10\n</code></pre>\n<p>大功告成，提交本次改动，后面的服务更新就不会影响前端开发了。当然，这只从运维层解决了服务的可用。对于开发层面，一定要注意，作为服务提供者，对于接口的修改，必须保证向前兼容。永远不要假设和要求前端和你同时更新（根本做不到，比如对于微信小程序，发布后，仍然有最长 24 小时的更新延迟；如果是原生 APP，用户不一定自动更新的）。</p>\n<p><a name=thL6O></a></p>\n<h1>总结</h1>\n<p>监控和可观测性对于分布式系统至关重要，这两点要求系统在运行时提供健康检查机制。假如现有的系统没有这个机制，那么可以参考《<a href=\"https://zhuanlan.zhihu.com/p/388319544\">利用 Vector 从日志创建指标来提高系统的可观测性</a>》一文，从日志的角度来弥补。然而，正如本文开头提到的，这依然会影响平时的开发体验，所以，本文详细介绍了如何在 SpringBoot 应用中增加健康检查机制，一来解决了开发体验问题，二来为后续捕获有用的健康指标从而与流行的工具集成以提高系统的可观测性打下了基础。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}