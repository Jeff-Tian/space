{"componentChunkName":"component---src-templates-post-js","path":"/posts/gb1ui4","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/gb1ui4","relativePath":"posts/gb1ui4","frontmatter":{"title":"强行在 TypeScript 里应用 C# 的 partial class","stackbit_url_path":"posts/gb1ui4","date":"2022-09-05T03:31:02","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>这算是 TypeScript 的奇技淫巧吗？算是吧，有什么价值？为了印证屎山是香的这一说法，必须要应用这些工程技巧。总之，无论碰到多么高的屎山，都应该遵守开闭原则去扩展，而不应该推倒重写。</p>\n<p>上次在生产环境中应用了一种奇怪的作法，对一个老项目进行扩展：发现一些不同的类之间有某些共同的特点，为了不改已有代码，就通过在新的文件中定义了一个新的方法来实现对不同类的通用扩展。目前已经上线一年多了，仍在平稳运行：<br />\n<a name=rVxPS></a></p>\n<h1>需求</h1>\n<p>还是这种老项目，它大量使用了 AWS DynamoDB，并使用一个库封装了对 DynamoDB 的常用操作，比如增删改查等等。项目中各种其他的类，都是继承自这个 库的 BaseDynamoDbService。然而，在最近的一个需求中，得删除已有表中的主键对应的所有记录，但这个方法在库中没有。写这个方法本身不难，令人纠结的是放在哪个地方？想来想去，还是觉得放在 BaseDynamoDbService 中最自然，纠结是因为这个 BaseDynamoDbService 文件在库中。</p>\n<p>我想起 C# 中的 partial class，它支持将同一个类的不同方法分散存储在不同的文件中，据说 TypeScript 借鉴了很多 C# 的设计，那么 TypeScript 有没有对 partial class 的支持呢？然而，目前还没有原生的支持。</p>\n<p><a name=LISCI></a></p>\n<h2>分析</h2>\n<p>既然没有原生支持，就只能另辟蹊径了。TypeScript 本质上还是 JavaScript，而 JavaScript 是非常灵活的。别说要扩展库中的类，就是要扩展语言中内置的类，也是非常容易的，那就是使用 prototype。要给哪个类扩展新方法，只需要把该方法写在该类的 prototype 上即可。要用在 TypeScript 当中，并获得类型支持和智能提示的话，可以使用 interface。\n<a name=wEKXo></a></p>\n<h1>解决方案</h1>\n<p>为了不修改库代码，但是又要给项目中众多继承了 BaseDynamoDbService 的类赋予新的方法，可以新建一个文件，比如叫做 base.service.ts，然后在这个文件里实现对 BaseDynamoDbService 的扩展。先将库中的 BaseDynamoDbService 导入，然后以库的名称声明一个模块，并在这个模块下定义一个和 BaseDynamoDbService 同名的接口。在这个接口里，声明一下要扩展的方法。最后，通过 prototype 的形式，去实现这些新的方法。</p>\n<p>最后的扩展文件内容结构如下：</p>\n<p>typescript\nimport { BaseDynamoDbService } from @/common/base</p>\n<p>declare module @/common/base {\nexport interface BaseDynamoDbService {\nnewMethod(param)\n}\n}</p>\n<p>BaseDynamoDbService.prototype.newMethod = function(param) {\n}</p>\n<p><a name=tZMpx></a></p>\n<h1>具体代码改动</h1>\n<p>对于这个具体的例子，我们要实现根据主键搜索出来的所有记录，并且将它们全部删除的功能。</p>\n<p><a name=mGFNs></a></p>\n<h2>测试先行</h2>\n<p>我们先建立一个测试文件。为了更通用，准备先扩展一个方法，从 DynamoDb Table 的 AttributeMap 对象中获取主键信息，从而不需要手动指定 Key，准备给这个方法起名叫 getKeyFromAttributeMap，就先来测试这个方法，给定一个假的 DynamoDb Table 的 AttributeMap，验证可以正确获取到 Key。这里以一个名字叫做 PostService 的服务为例，它是继承自 BaseDynamoDbService 的一个子类，大致长这样：\ntypescript\nimport { AttributeMap, CreateTableInput, ScanInput, UpdateTimeToLiveInput } from aws-sdk/clients/dynamodb</p>\n<p>export class PostService extends BaseDynamoService<Post> {\nconstructor(private readonly awsService: AWSService) {\nsuper(post-table, awsService)\n}</p>\n<p>protected getTableConfig(): Partial<CreateTableInput> {\nconst TableName = this.table\nconst AttributeDefinitions = [\n{\nAttributeName: operationType,\nAttributeType: S,\n},\n{\nAttributeName: postId,\nAttributeType: S,\n},\n]\nconst KeySchema = [\n{\nAttributeName: operationType,\nKeyType: HASH,\n},\n{\nAttributeName: postId,\nKeyType: RANGE,\n},\n]\nreturn { TableName, AttributeDefinitions, KeySchema }\n}\n}</p>\n<p>每个表，都会实现 BaseDynamoDbService 的 getTableConfig 方法，以获取一些基本配置信息，其中就包括了 KeySchema。于是测试用例就是通过传入一个 AttributeMap 实例，期待得到 getTableConfig 指定的 KeySchema 实例：</p>\n<p>typescript\ndescribe(PostService, () => {\nconst ps = new PostService(mockedAws)</p>\n<pre><code>it(gets key from attribute map, async () => {\n    const map = {\n        operationType: {\n            S: xyz,\n        },\n        operationId: {\n            S: abc,\n        },\n        scenarioType: {\n            S: def,\n        },\n        postId: {\n            S: fakeId,\n        },\n        memberId: {\n            S: 123,\n        },\n    }\n\n    const key = ps.getKeyFromAttributeMap(map)\n    expect(key).toStrictEqual({\n        operationType: {\n            S: xyz,\n        },\n        postId: {\n            S: fakeId,\n        },\n    })\n\n}\n</code></pre>\n<p>}</p>\n<p><a name=OwRQX></a></p>\n<h2>对 getKeyFromAttributeMap 的实现</h2>\n<p>直接测试肯定是失败的，因为 BaseDynamoDbService 里根本没有 getKeyFromAttributeMap 这个方法。如前所述，我们准备将这个方法定义在一个新文件中，所以要让测试通过，不仅需要定义出这个方法，还要注意，将 PostService 文件中的对 BaseDynamoDbService 的引用，改成从这个新文件中引用。好在，由于我们扩展后这个基类还是同一个类，因此不需要修改其他部分。</p>\n<p>typescript\n// 从库中引入要扩展的基类\nimport { BaseDynamoDbService } from @/common/base</p>\n<p>// 以这个库名作为模块名\ndeclare module @/common/base {\n// 以基类的名称作为接口名\nexport interface BaseDynamoDbService {\n// 声明新的扩展方法\ngetKeyFromAttributeMap(map)\n}\n}</p>\n<p>// 用 Prototype 方式实现新的方法\nBaseDynamoService.prototype.getKeyFromAttributeMap = function (map) {\nreturn this.getTableConfig() // 由于我们要扩展的是同一个类，可以直接用 this 引用该类中的已有方法\n.KeySchema?.map((k) => ({ key: k.AttributeName, value: map[k.AttributeName] }))\n.reduce((prev, next) => {\nprev[next.key] = next.value\nreturn prev\n}, {})\n}</p>\n<p>在这个测试通过后，就验证了这种方式的确可以正常工作。</p>\n<p>接下来就实现删除所有查询到的结果部分，仍然先写相关的测试。</p>\n<p><a name=gD1od></a></p>\n<h2>迭代对 aws dynamodb 的 mock</h2>\n<p>其实呀，看以上的测试用例非常简单，但实际上有个挑战，就是代码对 AWS sdk 是有依赖的，具体地说是依赖 aws sdk 中的 dynamodb。但是这个挑战在之前的文章中已经部分克服了：</p>\n<p>但是现在要写关于删除元素的测试了，这是之前没有涵盖到的，现在需要了，就来先完善一下这个 dynamodb 的 mock。实际上，对这个 mock 的完善也不是一步到位的，比如在用到了分页查询时，才增加 mock 中对于 query 的分页查询支持，不过为了省掉这些啰嗦的细节，这里直接给出相对上次，对这个 mock 做的改动：</p>\n<p>首先增加了 deleteItem 的 mock 实现，注意，由于我们的测试并不需要真正的删除元素，只是模拟返回被删除的元素，故这个实现是直接返回查询到的结果：\ntypescript\ndeleteItem: jest.fn().mockImplementation((params) => {\nreturn {\npromise: async () => {\n// 直接返回一个查询的返回结果\nreturn await mockDynamoDB.query(params)\n},\n}\n}),</p>\n<p>然后将 query 的 mock 改成了：</p>\n<p>typescript\nquery: jest.fn().mockImplementation((params) => {\nreturn {\npromise: () => {\nconst res = mockDynamoDB.items.filter(\nqueryByOperationKeyAndScenarioType(\nparams.ExpressionAttributeValues[:opKey],\nparams.ExpressionAttributeValues[:scType]\n)\n)</p>\n<pre><code>            if (params.ExclusiveStartKey) {\n                return Promise.resolve({\n                    Items: res,\n                })\n            }\n\n            return Promise.resolve({\n                Items: res,\n                // 这个逻辑是为了增加分页而加的，但是很简陋，一切为了测试需要，没有实现额外多余的逻辑\n                LastEvaluatedKey: res.length &#x3C; mockDynamoDB.items.length ? res.length + 1 : null,\n            })\n        },\n    }\n}\n</code></pre>\n<p><a name=t9bPZ></a></p>\n<h2>添加一个继承自基类的测试子类</h2>\n<p>有了 dynamodb mock 的增强，现在写一个删除一页数据的测试。因为删除数据是扩展到 BaseDynamoDbService 这个基类上的，所以我们期待它可以应用在任意继承于 BaseDynamoDbService 的子类中。于是先写一个测试类，继承自 BaseDynamoDbService:\ntypescript\nimport BaseDynamoService from ./base.service\nimport { Mock } from ts-mockery\nimport { DynamoDB } from aws-sdk\n// 增强后的 dynamoDb mock\nimport { mockDynamoDB } from ../../test/mocks/aws</p>\n<p>// 这里 mockAwsService 同前一个测试文件中的\nconst mockAwsService = Mock.of({\nasync getDynamoDB(): Promise<DynamoDB> {\nreturn mockDynamoDB\n},\n})</p>\n<p>class SUT extends BaseDynamoDbService {\nconstructor() {\nsuper(test-table, mockAwsService)\n}</p>\n<pre><code>// 这是基类中声明的抽象方法，在子类中必须给出具体实现\nprotected getTableConfig(): Partial&#x3C;DynamoDB.CreateTableInput> {\n    const TableName = this.table\n    const AttributeDefinitions = [\n        {\n            AttributeName: operationKey,\n            AttributeType: S,\n        },\n        {\n            AttributeName: scenarioType,\n            AttributeType: S,\n        },\n    ]\n    const KeySchema = [\n        {\n            AttributeName: operationKey,\n            KeyType: HASH,\n        },\n        {\n            AttributeName: scenarioType,\n            KeyType: RANGE,\n        },\n    ]\n    return { TableName, AttributeDefinitions, KeySchema }\n}\n\n// 这是基类中声明的抽象方法，在子类中必须给出具体实现\nprotected toAttributeMap(record): DynamoDB.AttributeMap {\n    // 这里用到的 toS 等方法，是库定义在 BaseDynamoDbService 中的，做了一些字段封装\n    return {\n        operationKey: this.toS(record.operationKey),\n        scenarioType: this.toS(record.scenarioType),\n    }\n}\n\n// 这是基类中声明的抽象方法，在子类中必须给出具体实现\nprotected toInstance(item: DynamoDB.AttributeMap) {\n    return { operationKey: item.operationKey.S, scenarioType: item.scenarioType.S }\n}\n</code></pre>\n<p>}</p>\n<p><a name=Jn27u></a></p>\n<h2>测试删除一页数据</h2>\n<p>有了这个测试子类，我们先测试删除第一页数据，aws sdk 对于查询出的数据，如果一页查询完毕了，是不返回 nextFrom 的，代表没有更多数据了。用例如下：</p>\n<p>typescript\nit(deletes one page without nextFrom, async () => {\n// 准备一个只有一个元素的伪表\nmockDynamoDB.items = [\n{\noperationKey: {\nS: key1,\n},\nscenarioType: {\nS: type1,\n},\n},\n]</p>\n<pre><code>const sut = new SUT()\n\nconst res = await sut.deleteOnePage(\n    {\n        ExpressionAttributeValues: {\n            :opKey: { S: key1 },\n            :scType: { S: type1 },\n        },\n    },\n    // 每页1个元素\n    1\n)\n\nexpect(res).toEqual(null)\n</code></pre>\n<p>})</p>\n<p>然后，实现一个基本的删除一页的实现代码，但是描述起来有点过于烦琐。直接上第二个测试吧，测试查询到的数据多于一页的场景，这时，aws 会返回一个 nextFrom 值，以备应用程序再去查下一页时，可以从这一条记录开始去查询。用例如下：</p>\n<p>typescript\nit(deletes one page with nextFrom, async () => {\n// 准备两个元素的伪表\nmockDynamoDB.items = [\n{\noperationKey: {\nS: key1,\n},\nscenarioType: {\nS: type1,\n},\n},</p>\n<pre><code>    {\n        operationKey: {\n            S: key2,\n        },\n        scenarioType: {\n            S: type2,\n        },\n    },\n]\n\nconst sut = new SUT()\n\nconst res = await sut.deleteOnePage(\n    {\n        ExpressionAttributeValues: {\n            :opKey: { S: key1 },\n            :scType: { S: type1 },\n        },\n    },\n    // 每页查询一条数据 \n    1\n)\n\n// 这个 Mg== 是基类中的方法将 aws 返回的数据计算出来的哈希值。\n// 由于每页只查询1条数据，而我们的伪表中有2条，所以一页查询不完，期待 aws 会返回 nextFrom\nexpect(res).toEqual(Mg==)\n</code></pre>\n<p>})</p>\n<p><a name=Z4NXU></a></p>\n<h2>实现删除一页数据</h2>\n<p>由测试用例可以看出，我们的删除一页数据，期待的入参是主键值，以及每页大小。返回的是查询结果中 aws 返回的 nextFrom 值，以指示是否还有更多数据（待删除）。在前面的 base.service.ts 中添加如下代码：</p>\n<p>typescript\n...\nexport interface BaseDynamoDbService {\ngetKeyFromAttributeMap(map)</p>\n<pre><code>// 第三个参数 from 可选。如果传了，就从这个位置开始查询并删除\ndeleteOnePage(params, pageSize, from?)\n</code></pre>\n<p>}\n...</p>\n<p>BaseDynamoDbService.prototype.deleteOnePage = async function (params, pageSize, from?) {\nconst onePageOfRecords = await this.queryTable(params, pageSize, from)</p>\n<pre><code>onePageOfRecords.data.forEach((record) => {\n    const deletingParams = { Key: this.getKeyFromAttributeMap(this.toAttributeMap(record)) }\n\n    return this.deleteItem(deletingParams)\n        .then((res) => logDebug(删除了： , record, res))\n        .catch((err) => logError(尝试删除 , params, pageSize, from,  时碰到错误： , err))\n})\n\nreturn onePageOfRecords.nextFrom\n</code></pre>\n<p>}</p>\n<p><a name=wXx02></a></p>\n<h2>测试删除所有数据</h2>\n<p>由于这里是先查询出记录，再去做删除。而查询又是分页查询的，所以要么使用递归要么使用循环，去一页一页地删除数据。无论怎么实现，测试用例都一样：</p>\n<p>typescript\nit(deletes all pages, async () => {\n// 还是准备了有两条记录的伪表\nmockDynamoDB.items = [\n{\noperationKey: {\nS: key1,\n},\nscenarioType: {\nS: type1,\n},\n},</p>\n<pre><code>    {\n        operationKey: {\n            S: key1,\n        },\n        scenarioType: {\n            S: type1,\n        },\n    },\n]\n\n// 复位 deleteItem 的计数\nmockDynamoDB.deleteItem.mockReset()\n\nconst sut = new SUT()\nconst res = await sut.deleteAllPages(\n    {\n        ExpressionAttributeValues: {\n            :opKey: { S: key1 },\n            :scType: { S: type1 },\n        },\n    },\n    // 通过指定页大小为1，就验证了多页场景\n    1\n)\n\nexpect(res).toEqual(undefined)\n\n// 因为有两页，每页一条数据，我们验证删除元素的操作被执行了两次，以证明每页的删除操作都执行了\nexpect(mockDynamoDB.deleteItem).toHaveBeenCalledTimes(2)\n</code></pre>\n<p>})</p>\n<p><a name=T63va></a></p>\n<h2>实现多页删除</h2>\n<p>本来使用了 while 循环来实现，后来还是改成了递归，发现代码更简洁。即先实现一个刚好通过测试的代码，在重构代码环节，改成了递归。最终在 base.service.ts 中添加了这样的代码：</p>\n<p>typescript\n...\nexport interface BaseDynamoDbService {\ngetKeyFromAttributeMap(map)</p>\n<pre><code>deleteOnePage(params, pageSize, from?)\n\ndeleteAllPages(params, pageSize, from?)\n</code></pre>\n<p>}\n...</p>\n<p>BaseDynamoDbService.prototype.deleteAllPages = async function (params, pageSize, from?) {\nconst nextFrom = await this.deleteOnePage(params, pageSize, from)</p>\n<pre><code>if (nextFrom) {\n    // 递归调用\n    return await this.deleteAllPages(params, pageSize, nextFrom)\n}\n\nreturn undefined\n</code></pre>\n<p>}</p>\n<p><a name=qrTMh></a></p>\n<h1>上线</h1>\n<p>就这么有信心地上线了，通过查看日志输出，新写的逻辑如期运行了。毕竟：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1662347661047-97b8efe9-9e83-4785-9577-05511a3ac841.png#clientId=u15ce09e2-4a7c-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=157&#x26;id=u226c1a0b&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=314&#x26;originWidth=500&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=259843&#x26;status=done&#x26;style=none&#x26;taskId=u6509d5a6-2470-407b-9339-cfb79879333&#x26;title=&#x26;width=250\" alt=\"image.png\"></p>\n<p><a name=IxQ2D></a></p>\n<h1>最后的思考🤔</h1>\n<p>TypeScript 或者说 JavaScript 使用 prototype 可以轻松实现 partial class 的效果。那么 C# 是怎么实现的呢？现在很好奇，如果你知道，欢迎留言告诉我。</p>\n<p><a name=dPhdP></a></p>\n<h1>警告</h1>\n<p>在 JavaScript 中使用 prototype 简直可以为所欲为。比如在 JavaScript 对 class 提供支持之前，就有通过 prototype 的方式来实现类和继承。这里又利用它实现了 C#<br />中的 partial class 效果，但是不要总是使用它！</p>\n<p>我曾经在开源库 flot 做一个 feature 时，也使用了对其中的类的 prototype 做扩展方式来增加新功能，但是被 flot 的维护者（在谷歌工作的大神）指出虽然 99% 的情况下没有问题，但仍然建议直接定义新的函数，而不要去污染该类的 prototype。这个建议非常中肯，有时候 prototype 被修改了而别的开发者不知道，就会有“意外的惊喜”。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1662348575879-4f6d6ac2-ab5e-47b3-8cf8-0385e029ae00.png#clientId=u15ce09e2-4a7c-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=412&#x26;id=u953801dd&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=824&#x26;originWidth=1914&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=263718&#x26;status=done&#x26;style=none&#x26;taskId=u5f6ed0ea-da94-48db-9a27-aa0e5025fc4&#x26;title=&#x26;width=957\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1662348547631-30e90bbc-8af3-4423-9d70-93bee3622f92.png#clientId=u15ce09e2-4a7c-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=576&#x26;id=ud108abe6&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1152&#x26;originWidth=2464&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=359740&#x26;status=done&#x26;style=none&#x26;taskId=u51df75f7-333c-4495-91b3-137df989e61&#x26;title=&#x26;width=1232\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1662348640351-19a54811-3244-4352-bfd5-212a1c3306d8.png#clientId=u15ce09e2-4a7c-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=799&#x26;id=u72e62580&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1598&#x26;originWidth=2300&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=544948&#x26;status=done&#x26;style=none&#x26;taskId=u3910968b-848b-467d-b50f-ff609b685cc&#x26;title=&#x26;width=1150\" alt=\"image.png\"></p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}