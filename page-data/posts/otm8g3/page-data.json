{"componentChunkName":"component---src-templates-post-js","path":"/posts/otm8g3","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/otm8g3","relativePath":"posts/otm8g3","frontmatter":{"title":"GraphQL API 设计指南","stackbit_url_path":"posts/otm8g3","date":"2022-04-21T10:14:31","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>上一篇以自己的万能 BFF 项目为例，聊了一下什么是 GraphQL 以及如何使用 NestJs 框架来开发 GraphQL API ，比较干。今天聊一聊湿一点的内容，GraphQL API 的设计。GraphQL API 的设计原则和 restful API 的设计原则还挺不一样，关于 Restful API 的设计，详见该专栏的讨论：</p>\n<p>首先强调一下我个人认为的最重要的两条指导原则，然后在这两条最重要的原则的指导下，引申阐述设计细节。\n<a name=liqsF></a></p>\n<h1>向后兼容老版本</h1>\n<p>这是我认为最重要的一条，但是在实际的团队开发中，却总是有成员违反的一条。总是有人尝试带来破坏性的改动，而且在代码审核环节被提出有兼容问题的时候，总是以前后端一起发版，没有问题来反驳。实际上，完全的同时发版，不仅做不到，更加不是一个好的实践。好的实践是不同的服务和不同的微前端，各自可以随时独立发版，不要有依赖顺序。如果做到这一点很难，那么，允许前端在服务发版之后再行发版，是必须要做到的，不能再妥协了。而且，就算同时发布，有些前端程序要推送到所有设备是有一个时间延迟的。比如微信小程序前端的更新，要100%完成，是需要最长24小时的。也就是说，最长24小时的时间里，会同时存在新老两个版本。如果 GraphQL API 不能兼容老版本，就会有用户在这段时间里碰到问题。<br />因此，原则是已有的查询无论如何不能被破坏。</p>\n<blockquote>\n<p>推论一：一旦一个字段被发布到了线上，就不能被删除了。如果真的需要删除它，那么，先将该字段标记为已废弃。当确保所有的前端都已经相应地更新完毕，再进行安全删除。在敏捷开发中，建议至少在前端修改上线后的下一个迭代周期里进行字段的删除修改。</p>\n</blockquote>\n<blockquote>\n<p>推论二：和推论一一样，一旦一个字段发布到了线上，就不能重命名了。实在需要重命名，那么请先新建一个字段，同时将旧字段标记为已废弃。确保所有前端对旧字段的引用改成使用新字段后，再对旧字段进行安全删除。</p>\n</blockquote>\n<p><a name=RUNSg></a></p>\n<h1>向前考虑扩展性</h1>\n<p>对所有的查询和操作，总是使用自定义对象类型（无论是输入参数还是响应负载都应如此）。否则，你就移除了未来向已有的查询和操作添加其他返回类型及元数据的可能性。而在设计无版本的 GraphQL API 中，提前压缩设计空间绝对不是你真正想做的。<br />并且，原始类型迷恋也是一种代码坏味道（<a href=\"https://refactoring.guru/smells/primitive-obsession\">https://refactoring.guru/smells/primitive-obsession</a>）。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1650460673110-1d14cc65-7eb2-43f8-8d12-353d314bf0c9.png#clientId=u734e93a4-e6d6-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=300&#x26;id=u03248ef4&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=600&#x26;originWidth=1000&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=183731&#x26;status=done&#x26;style=none&#x26;taskId=u39d1730a-2b80-47c9-8497-b15c6d6bb33&#x26;title=&#x26;width=500\" alt=\"image.png\"><br />不使用自定义的对象类型，还会使得参数列表随着迭代变得越来越长，而一个长的参数列表，又是另一种代码坏味道。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1650460875071-c64f342b-d50a-4452-b5fe-9aa25a779394.png#clientId=u734e93a4-e6d6-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=300&#x26;id=u484e1869&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=600&#x26;originWidth=1000&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=196371&#x26;status=done&#x26;style=none&#x26;taskId=ud6c1a690-e955-4650-ad7e-3fae8b6f0da&#x26;title=&#x26;width=500\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1650460946468-f7608832-56e1-42bc-ab59-82d01e686639.png#clientId=u734e93a4-e6d6-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=300&#x26;id=u32feee43&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=600&#x26;originWidth=1000&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=228456&#x26;status=done&#x26;style=none&#x26;taskId=u9a25aa96-2dba-436a-bf84-d7655db7ddc&#x26;title=&#x26;width=500\" alt=\"image.png\"><br />在这两条基本原则的指导下，可以引申出很多设计细节：\n<a name=aasrx></a></p>\n<h1>设计细节</h1>\n<p><a name=zAXkU></a></p>\n<h2>命名</h2>\n<ul>\n<li>对于 Mutation，推荐动词+名词（操作目标对象）的驼峰命名方式，比如：\n<ul>\n<li>createOrder</li>\n<li>updateProfile</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n<p>但是，Shopify 推荐 Mutation 使用名词+动词的形式，主要是出于将操作应用的目标对象在文件排序时能够放在一起。<a href=\"https://github.com/Shopify/graphql-design-tutorial\">https://github.com/Shopify/graphql-design-tutorial</a></p>\n<p><a name=sLy8X></a></p>\n<h2>精细化</h2>\n<p>对于操作的种类不要害怕过于精细化了，相反，为每一种可能的 UI 更新都定义一种操作都不过分。和用户能够执行的动作一一对应的精细化的操作比泛化的操作更加强大。这是因为精细化的操作对 UI 开发者来说更容易写，并且可以由后端开发做进一步优化。而且，通过提供更精细化的 API 操作，会让恶意攻击者不正当使用这些 API 的尝试变得更加困难。<br />举个例子，一个典型的 restful API 通常包含增删改查操作，但是在 GraphQL 里，推荐使用更加精细化的操作定义，就是说，不仅有增删改查，还有更多和 UI 操作相关的 API 定义，比如：</p>\n<ul>\n<li>createSomething</li>\n<li>updateSomething</li>\n<li>deleteSomething</li>\n<li>publishSomething</li>\n<li>unpublishSomething</li>\n<li>……</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1650536034369-40f97a67-d8c7-437c-9f7d-e8abc873dd44.png#clientId=uba292150-b922-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=451&#x26;id=uf18c89ca&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=902&#x26;originWidth=1666&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=171882&#x26;status=done&#x26;style=none&#x26;taskId=u3a45136d-b91d-4f83-b79a-c91ac5bef43&#x26;title=&#x26;width=833\" alt=\"image.png\">\n<a name=h0Gwg></a></p>\n<h2>输入对象参数</h2>\n<p>这是由向后兼容老版本和向前考虑扩展性的原则推论而来。因为未来的变化无法预测，所以需要留有后路。如果参数需要变化的话，那么定义一个自定义的对象，就可以将未来的参数变化控制在这个对象范围内（比如可以增加字段），而不用修改 API 的签名。并且可以兼容老版本，因为没有增加新的参数。\n<a name=mTjAw></a></p>\n<h2>唯一的返回对象类型</h2>\n<p>同上，不仅输入参数应该是自定义类型，而且返回的数据体也应该是自定义的并且每个操作都唯一的类型。\n<a name=mO9fK></a></p>\n<h2>将受到操作影响的对象作为结果返回</h2>\n<p>不要只返回 {success: true} 这样的结果，而是将受到操作影响的对象数据返回，这样使得更新前端的状态变得简单，而且可以保持更好的数据一致性。\n<a name=vFRiP></a></p>\n<h2>嵌套</h2>\n<p>在 GraphQL 的世界里，套娃是一种美德。原因还是和前面讲过的一样，即可以向前兼容老版本和向后扩展性更好。\n<a name=KtDft></a></p>\n<h2>单一 HTTP 端点</h2>\n<p>虽然 GraphQL 是可以通过多个 HTTP 端点提供服务，但是非常建议仅仅通过单个 HTTP 端点来提供所有的 GraphQL 服务。这不像 Restful API 会为同一个资源的不同操作暴露不同的 URL，GraphQL 需要使用单一端点，否则在使用 GraphiQL、PlayGround 以及 Apollo Studio 时会碰到困难。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1650535984551-9bc9dc5c-d3c5-4607-99ce-b139eb19889a.png#clientId=uba292150-b922-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=561&#x26;id=u403014a9&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1122&#x26;originWidth=2002&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=232534&#x26;status=done&#x26;style=none&#x26;taskId=ubcaffb6d-db07-46a2-98b9-c9782975031&#x26;title=&#x26;width=1001\" alt=\"image.png\">\n<a name=eJ9Fd></a></p>\n<h2>使用 Gzip 压缩 JSON 响应体</h2>\n<p>鼓励生产环境的 GraphQL 服务开启 Gzip 压缩，而且客户端最好发送一个这样的 HTTP Header：</p>\n<p>Accept-Encoding: gzip</p>\n<p>前端和 API 的开发人员都非常熟悉 JSON，它很易读和调试。事实上，GraphQL 的语法就是受 JSON 的启发而来的，但是 JSON 响应不如二进制响应那样小巧，所以启用压缩在节约传输带宽上很有帮助。\n<a name=PkAX5></a></p>\n<h2>无版本</h2>\n<p>GraphQL 仅仅返回客户端显式指定的数据，所以新的能力可以通过新的类型和新的字段来增加，而不会带来破坏性的改动。这就带来了一个通用的实践：总是通过无版本的 API 来避免破坏性改动。\n<a name=hBJpn></a></p>\n<h2>可空性</h2>\n<p>在设计 GraphQL 的 Schema 时，要记住很重要的一点：事情总会有出错的可能，所以当获取一个字段的值可能碰到错误时，该字段就应该允许为空，否则在这种情况下会导致整个 API 报一个 Schema 相关的错误，从而引起整个前端界面崩掉的风险。除非肯定不会出错，这样的字段才能够设置为不可为空的类型。\n<a name=B091g></a></p>\n<h2>分页</h2>\n<p>很多字段有可能返回长长的列表，这样的字段就应该接受分页参数，如 first、after 等，从而允许查询列表中的特定范围。after 是列表中的条目的唯一标识符。<br />要设计强大的分页功能，有一个最佳实践。即： Connections。有一些 GraphQL 的客户端工具如 Relay，会知道如何与实现了这种 Connections 模式的 GraphQL 服务打交道，并自动提供一些客户端分页支持。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1650535775456-7732bc0b-1fcb-4460-97fd-e12f64f4303e.png#clientId=uba292150-b922-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=375&#x26;id=u7027c679&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=750&#x26;originWidth=2310&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=193519&#x26;status=done&#x26;style=none&#x26;taskId=u41ee7157-be40-43f2-9250-d3e03521444&#x26;title=&#x26;width=1155\" alt=\"image.png\">\n<a name=Tz3yk></a></p>\n<h2>服务器端要支持批量操作并启用缓存</h2>\n<p>详见该专栏的讨论：\n<a name=b0gMw></a></p>\n<h2>Schema</h2>\n<p>Schema 可以用来自动生成代码、验证、解析、开启内省模式，并给 API 带来类型安全。在 GraphQL 世界里，我们根据业务模型来定义 Schema；在 Schema 里，我们为 nodes 定义不同的类型，以及它们如何互相联结。<br />即 GraphQL Schema 是应用的数据图以及操作的文本化表示。数据图定义了实体和它们之间的关系。要完成 Schema，需要添加 GraphQL 操作，这些操作提供了生成和操作数据图的信息。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}