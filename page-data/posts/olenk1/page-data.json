{"componentChunkName":"component---src-templates-post-js","path":"/posts/olenk1","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/olenk1","relativePath":"posts/olenk1","frontmatter":{"title":"使用 OIDC 在一个 Keycloak 中集成另一个 Keycloak 用户认证","stackbit_url_path":"posts/olenk1","date":"2021-03-29T12:56:37","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<blockquote>\n<p>这是一篇价值 7 元的文章，有人已经付费，免费分享给你！\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617022548905-6994bae0-6682-473e-93c1-2022d6e991d9.png#align=left&#x26;display=inline&#x26;height=1122&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=2244&#x26;originWidth=1080&#x26;size=749757&#x26;status=done&#x26;style=none&#x26;width=540\" alt=\"image.png\"></p>\n</blockquote>\n<p>周末有人在知乎上通过<a href=\"https://www.zhihu.com/consult/conversation/1358907868830470144/question\">付费咨询频道</a>问我，如何在一个 Keycloak 中集成另一个 Keycloak 用户认证。由于目前知乎付费咨询只支持手机端，因此我当时的回答比较简略的。今天再用电脑把实现步骤一步一步写下来，争取让小白也能够顺利集成，因此文章会略显啰嗦，高手请选择性地跳跃阅读或者直接忽略。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616994682876-43c371de-5e90-426c-bbcf-31fe07238ed2.png#align=left&#x26;display=inline&#x26;height=1122&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=2244&#x26;originWidth=1080&#x26;size=477275&#x26;status=done&#x26;style=none&#x26;width=540\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617068555108-7bb84ba2-5ce5-48c0-bfcd-0d3bc4ac6f8a.png#align=left&#x26;display=inline&#x26;height=1122&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=2244&#x26;originWidth=1080&#x26;size=1087024&#x26;status=done&#x26;style=none&#x26;width=540\" alt=\"image.png\"></p>\n<p><a name=kMshr></a></p>\n<h2>问题重述</h2>\n<blockquote>\n<p>我看了你关于《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现</a>》的文章，有点问题想和你沟通下。\n我现在有2个系统，a和b。它们都接入了keycloak，是2个realm。数据库也是隔离的。现在想要实现a系统通过b系统的账号登录。我想用类似微信登录的方式，把b系统当成微信。不知道这样是否合适，以及具体的实现感觉有点困难。</p>\n</blockquote>\n<br />\n<a name=qu96G></a>\n## 最终实现\n<p>完全可行，不用一行代码。</p>\n<p><a name=PBWXz></a></p>\n<h2>在线演示</h2>\n<p>在《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现</a>》里已经搭建了一个 Keycloak 站点：<a href=\"https://keycloak.jiwai.win%E3%80%82%E5%9C%A8%E8%BF%99%E5%90%8D%E5%90%8C%E5%AD%A6%E7%9A%84%E9%97%AE%E9%A2%98%E9%87%8C%EF%BC%8C%E5%8D%B3%E6%98%AF%E7%B3%BB%E7%BB%9F\">https://keycloak.jiwai.win。在这名同学的问题里，即是系统</a> b。</p>\n<p>为了演示这名同学的系统 a，我搭建了另一个 Keycloak 站点：<a href=\"https://lemur-2.cloud-iam.com/\">https://lemur-2.cloud-iam.com/</a>。你可以点击<a href=\"https://lemur-2.cloud-iam.com/auth/realms/uniheart/protocol/openid-connect/auth?client_id=security-admin-console&#x26;redirect_uri=https%3A%2F%2Flemur-2.cloud-iam.com%2Fauth%2Fadmin%2Funiheart%2Fconsole%2F%23%2Fforbidden&#x26;state=3c79a33d-1849-4715-a5ab-ffdd449ffe2f&#x26;response_mode=fragment&#x26;response_type=code&#x26;scope=openid&#x26;nonce=d70ad94e-3b8d-45a4-9d95-fec3a956c3d6&#x26;code_challenge=5xGNw7hdadcP8DYRhVJOzEZJ3xVgIAyuWSeUH4JbBUE&#x26;code_challenge_method=S256\">这里</a>，然后选择使用系统 b 登录，就可以看到效果：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616995827736-655bebc5-be8a-40f2-9e9c-b744505978c9.png#align=left&#x26;display=inline&#x26;height=769&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1538&#x26;originWidth=1630&#x26;size=423561&#x26;status=done&#x26;style=none&#x26;width=815\" alt=\"image.png\"><br />显然，Keycloak a 是一个刚部署好的 Keycloak，默认只支持用户名密码登录。但是为了使用 Keycloak b 登录，所以又增加了一个登录方式：UniHeart At Jiwai Win，这就是 <a href=\"https://keycloak.jiwai.win%E3%80%82%E9%80%89%E6%8B%A9%E8%BF%99%E4%B8%AA%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%EF%BC%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%BA%86\">https://keycloak.jiwai.win。选择这个登录方式，页面跳转到了</a> Keycloak a 的登录界面（如果看过前面的《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现</a>》，对这个界面很熟悉了吧）。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616996125963-96e683c0-0c1e-4b4a-84f0-588353391798.png#align=left&#x26;display=inline&#x26;height=745&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1490&#x26;originWidth=2066&#x26;size=223144&#x26;status=done&#x26;style=none&#x26;width=1033\" alt=\"image.png\"><br />使用 Keycloak b 的任何登录方式（正好这个 Keycloak b 支持关注微信公众号即登录功能，但这个不是必须的），成功登录后，都会回到 Keycloak a，并且是已经登录状态：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616996372763-c30e5da5-828f-4f82-994a-c38a697c7404.png#align=left&#x26;display=inline&#x26;height=527&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1054&#x26;originWidth=1792&#x26;size=128991&#x26;status=done&#x26;style=none&#x26;width=896\" alt=\"image.png\"><br />虽然页面显示用户没有权限查看该页面，但是说明登录已经成功。关于如何给该用户配置相关权限，可以自行探索。<br />如果已管理员账号登录 Keycloak a，在用户管理界面可以看到已经多了一个 Keycloak b 中的账号：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616996493374-edfd6ba2-ed07-4faa-b98c-b6385c184566.png#align=left&#x26;display=inline&#x26;height=668&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1336&#x26;originWidth=3236&#x26;size=322119&#x26;status=done&#x26;style=none&#x26;width=1618\" alt=\"image.png\">\n<a name=ElirL></a></p>\n<h2>问题分析</h2>\n<p>这名同学希望将两个不同的 Keycloak realm 用户打通，可以使用 Keycloak realm b 登录 Keycloak realm a。或者说，使用 Keycloak b 登录 Keycloak a，这是等价的。为了说明问题，我们不如建立两个 2 个 Keycloak 实例，不仅 realm 不同，整个 Keycloak 实例都不同（数据库也是独立的）。</p>\n<p>另外，这名同学看了之前的《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现</a>》一文，可能受到微信登录的影响。其实他这里想表达的和微信登录没有任何关系。</p>\n<p><a name=XrgEP></a></p>\n<h2>基础知识回顾</h2>\n<p>正如前面所说，整个实现过程不需要一行代码，而且配置步骤也非常简单。但是在实施过程中，为什么会感到困难呢？很可能是需要补充一些基础知识。这里在详细列出实现步骤前，对相关知识做一个简单回顾，从而在阅读详细步骤时，不仅知其然，还能知其所以然。</p>\n<p><a name=lv7Ob></a></p>\n<h3>单点登录</h3>\n<p>Keycloak 是一个优秀的开源的单点登录工具。想使用系统 B的用户直接登录系统 A，而不用再次去系统 A 里注册，这也是典型的单点登录场景。单点登录有多种协议：</p>\n<p><a name=Eo5GO></a></p>\n<h3>单点登录认证协议</h3>\n<p>最知名的单点登录认证协议主要是 OpenId Connect 和 SAML。下面就来看看认证服务器和被保护的应用是怎么和这些协议打交道的。</p>\n<p><a name=5e6Ga></a></p>\n<h3>OpenId Connect</h3>\n<p>OpenId Connect 通常简称为 OIDC，它是在 OAuth 2.0 的基础上扩展而成的认证协议。OAuth 2.0 只是一个构建认证协议的框架，并且很不完整，但是 OIDC 确实一个羽翼丰满的认证与授权协议。OIDC 严重使用 Json Web Token（JWT）标准。这些标准用紧凑和对网络友好的方式定义了 JSON 格式的唯一标记以及对数据进行数字化签名和加密的方法。</p>\n<p>OIDC 在 Keycloak 中的使用场景分为两种类型。第一种是应用请求 Keycloak 服务器来认证用户。当成功登录后，应用会收到一个名称为 access_token 的唯一身份标志符。这个唯一身份标志符包含了诸如用户名、电子邮箱、以及其他个人资料等等信息。 access_token 会被 realm 进行数字签名，并且包含用户的可访问信息（比如用户-角色映射），从而应用可以使用它来决定该用户被允许访问应用中的哪些资源（上面的在线演示中显示的已登录用户没有权限页面，就是因为拿到的 access_token 中没有相关的可访问信息）。</p>\n<p>第二种使用场景类型是客户端想获取远端服务的访问权限。在这个场景下，客户端请求 Keycloak 来获取一个访问令牌来代表用户调用远端服务。Keycloak 认证该用户后询问用户是否同意为该客户端授予访问权限。一旦用户同意授权，客户端就会收到访问令牌。这个访问令牌是由 realm 数字化签名过的。该客户端随后就可以使用这个访问令牌向远端服务发起 REST 调用了。这个 REST 服务抽取出访问令牌，验证令牌的签名，然后基于令牌中的可访问信息决定是否保护这个调用请求。</p>\n<p><a name=5csSS></a></p>\n<h3>OIDC 认证流程</h3>\n<p>OIDC 有多种不同的方式为客户端或者应用提供用户认证并接收身份标记和访问令牌。你要使用那种方式很大程度上取决于应用或者客户端请求访问权限的类型。所有这些认证流程都在 OIDC 和 OAuth 2.0 的规格文档中详细描述了，所以这里只是稍稍提及一些必要内容。</p>\n<p><a name=2S8mC></a></p>\n<h4>授权码流程</h4>\n<p>这是一个基于浏览器的协议，也是在验证和授权基于浏览器的应用时所推荐使用的。它严重依赖浏览器重定向来获取身份标记与访问令牌。总结如下：</p>\n<ol>\n<li>使用浏览器访问应用。这个应用会提醒用户当前还未登录，所以它指示浏览器重定向到 Keycloak 来认证。该应用会以查询参数的形式在浏览器重定向时向 Keycloak 传递一个回调 URL（即演示截图中的 redirect_uri），Keycloak 在完成认证后会使用到它。</li>\n<li>Keycloak 认证用户，并创建一次性、非常短时间有效的临时码。Keycloak 通过前面提供的回调 URL 重定向回到应用，同时将临时码作为查询参数附加到回调 URL 上。</li>\n<li>应用抽取临时码，并且在后端通过不同于前端的网络渠道向 Keycloak 发起 REST 调用，使用临时码交换身份标记、访问令牌以及刷新令牌。一旦这个临时码在获取令牌中被使用过了，它就不能再次被使用了。这防止了潜在的重放攻击。</li>\n</ol>\n<p>非常重要的一点是访问令牌通常有效期很短，一般在分钟级别过期。而刷新令牌由登录协议传送，允许应用在访问令牌过期后去获取一个新的访问令牌。这样一个刷新协议在受损系统中非常重要。如果访问令牌有效期很短，那么整个系统仅仅在被盗用的令牌剩余的有效期内是处于被攻击状态的。如果管理员吊销了访问权限，那么接下来的令牌刷新请求会失败。这样更加安全并且可伸缩性更好。</p>\n<p>该流程另一个重要的方面是所谓的开放客户端还是保密客户端的概念。保密的客户端在使用临时码交换令牌时需要提供客户端密钥。开放客户端则不需要。只要严格使用 HTTPS 并且客户端的重定向 URI 被严格注册，那么采用开放客户端完全没有问题。由于无法使用安全的方式传输客户端密钥，所以 HTML5/JavaScript 客户端不得不天然就属于开放客户端。再次强调，这仅仅在严格使用 HTTPS 并严格注册重定向 URI 时是可以的。</p>\n<p><a name=zBUCs></a></p>\n<h4>隐式流程</h4>\n<p>这也是一个基于浏览器的协议，很类似授权码流程，只是请求量更少，也不需要刷新令牌。该流程不被推荐，因为存在访问令牌泄漏的可能性。比如由于令牌通过重定向 URI （详见下）传输，所以可能通过浏览器历史记录泄漏。并且，由于该流程没有为客户端提供刷新令牌的服务，所以访问令牌不得不设置一个更长的时间，不然当令牌失效后用户需要再次认证。Keycloak 不推荐这种流程但是仍然支持这种流程，因为它存在于 OIDC 和 OAuth 2.0 的规格文档中。总结如下：</p>\n<ol>\n<li>使用浏览器访问应用。应用提示用户当前还未登录，所以它指示浏览器重定向到 Keycloak 去认证。应用将回调 URL （一个重定向 URI）作为查询参数传递给 Keycloak，在认证完成后会被其使用。</li>\n<li>Keycloak 认证用户并且创建身份标记和访问令牌。Keycloak 使用之前提供的回调 URL 重定向回到应用并使用查询参数的方式额外添加身份标记和访问令牌在回调 URL zhong。</li>\n<li>应用从回调 URL 中抽取身份标记和访问令牌。</li>\n</ol>\n<p><a name=f0QOa></a></p>\n<h4>资源拥有者密码凭据授权（直接访问授权）</h4>\n<p>这在 Keycloak 管理员控制台中指直接访问授权。当 REST 客户端希望代表用户获取令牌时使用该流程。这是一个 HTTP POST 请求，该请求中包含了用户的安全凭据和客户端 id，以及客户端的密钥（如果是保密客户端的话）。该用户的安全凭据随请求中的表单参数发送。这个 HTTP 响应中包含的身份标记、访问权限，以及刷新令牌。</p>\n<p><a name=s0IVA></a></p>\n<h4>客户端凭据授权</h4>\n<p>这也是由 REST 客户端使用的，但不是代表一个外部用户去获取令牌，而是基于和客户端相关的元数据与服务账号的权限来创建一个令牌。</p>\n<p><a name=PwRyK></a></p>\n<h3>Keycloak 服务器的 OIDC URI 端点</h3>\n<p>这一小节非常简单，但是对本文来说，却非常非常重要。因为在配置时，是直接要用到相关的端点的。</p>\n<p>Keycloak 会公布一系列的 OIDC 端点。当你使用客户端适配器与认证服务器进行 OIDC 沟通时，这些 URL 非常有用。这些全部都是相对 URL，且其根 URL 是使用 HTTP(S) 协议的，并且会在其 hostname 的基础上添加 /auth 路径。比如，典型的根 URL 是： <a href=\"https://keycloak.jiwai.win/auth%EF%BC%8C%E6%88%96%E8%80%85\">https://keycloak.jiwai.win/auth，或者</a> <a href=\"http://localhost:8080/auth%E3%80%82\">http://localhost:8080/auth。</a></p>\n<p><a name=uMhfI></a></p>\n<h4>/realms/{realm-name}/protocol/openid-connect/auth</h4>\n<p>在授权码流程中这个 URL 端点用来获取临时码，在隐式流程、直接授权或者客户端授权中，这个 URL 端点用来获取令牌。</p>\n<p><a name=o78hm></a></p>\n<h4>/realms/{realm-name}/protocol/openid-connect/token</h4>\n<p>这个 URL 端点用来在授权码流程中将临时码转换成令牌。</p>\n<p><a name=fJOH9></a></p>\n<h4>/realms/{realm-name}/protocol/openid-connect/logout</h4>\n<p>这是用来执行退出登录操作的 URL 端点。</p>\n<p><a name=xcJaM></a></p>\n<h4>/realms/{realm-name}/protocol/openid-connect/userinfo</h4>\n<p>这个 URL 端点是用来提供用户信息服务的，其详细描述参见 OIDC 规格说明。</p>\n<p><a name=Vdser></a></p>\n<h4>/realms/{realm-name}/protocol/openid-connect/revoke</h4>\n<p>这个 URL 端点用来做 OAuth 2.0 中的令牌吊销，其详细描述见 <a href=\"https://tools.ietf.org/html/rfc7009\">RFC7009</a>。</p>\n<p><a name=EFk1l></a></p>\n<h3>SAML</h3>\n<p>SAML 2.0 类似 OIDC，但是产生得更早并且更加成熟。由于本文使用 OIDC 解决这名知乎用户的问题，因此不对 SAML 做详细介绍。</p>\n<p><a name=gsa5V></a></p>\n<h3>OpenID Connect 和 SAML 的对比</h3>\n<p>选择 OpenID Connect 还是 SAML？并不推荐简单的使用新的协议（OIDC）而不是用更老的但是更成熟的协议（SAML）这种一刀切的决策思路。</p>\n<p>但是 Keycloak 在大多数情况下都推荐使用 OIDC，这也是本文解决知乎网友问题时的做法。</p>\n<p>SAML 要比 OIDC 更加啰嗦一些。</p>\n<p>除了交换数据更加啰嗦之外，如果你仔细对比规格说明文档，你会发现 OIDC 是围绕 Web 相关的工作而设计的，但是 SAML 却是在 Web 的基础上增加了新的设施。比如，相对 SAML 来说，OIDC 在客户端的实现更加容易，因此 OIDC 更加适合 HTML5/JavaScript 应用。由于令牌是 JSON 格式的，他们更容易被 JavaScript 所消费。当然，OIDC 还有其他好特性使得在 Web 应用中实现安全更加容易。比如规格文档中提到的，使用 iframe 技巧，就很容易探测用户是否还处于登录状态。</p>\n<p>当然 SAML 也还是有其用武之地的。随着 OIDC 的规格文档的演进，你会发现它实现的越来越多的特性，早在几年前 SAML 就已经有了。人们一般使用 SAML 的原因是已有系统已经使用了 SAML 加固，以及 SAML 更加成熟。</p>\n<p><a name=frE9I></a></p>\n<h2>集成步骤</h2>\n<p>好了，说了这么多，是为了在后续实现步骤中，不迷失方向。实现步骤本身特别简单，关键是需要了解这些基础知识，否则就会觉得莫名其妙。</p>\n<p><a name=vG1u4></a></p>\n<h3>准备工作：搭建两个 Keycloak 系统</h3>\n<ul>\n<li><strong>Keycloak b</strong>，我们将用它来登录其他系统，包括 Keycloak a。处于免费的考虑，可以使用 Heroku 平台。但是由于 Heroku 平台的限制，不得不对 Keycloak 做小的改造。改造后的 Keycloak 我放在了 Github 上：<a href=\"https://github.com/Jeff-Tian/keycloak-heroku\">https://github.com/Jeff-Tian/keycloak-heroku</a>，你可以点击 ReadMe 中的按钮一键部署到 Heroku 上。比如我部署好的 Keycloak b 是：<a href=\"https://keycloak.jiwai.win\">https://keycloak.jiwai.win</a> 。</li>\n<li><strong>Keycloak a</strong>，你同样可以使用 Heroku 再部署一个实例。也可以利用 <a href=\"https://www.cloud-iam.com/\">https://www.cloud-iam.com/</a> 提供的免费托管 Keycloak，它的限制是只能有 100 个用户。比如我部署好的 Keycloak a 是 <a href=\"https://lemur-2.cloud-iam.com/\">https://lemur-2.cloud-iam.com/</a>。</li>\n</ul>\n<p><a name=s7frN></a></p>\n<h3>在 Keycloak b 中注册一个客户端 Keycloak a</h3>\n<p>这很简单，如下图所示。关键配置已用红色框圈起来。</p>\n<p>用 Keycloak b 的管理员账号密码登录 Keycloak b，在相应的 Realm 中点击新建一个客户端，首先需要起个名字，比如命名为 UniHeart-Cloud-IAM。</p>\n<p>然后需要在客户端协议中选择“openid-connect”。所以说基础知识很重要，不然会在众多选项里迷失方向。</p>\n<p>随后在访问类型中，选择保密（如前面的基础知识里讲的，如果能够保证严格的 HTTPS 实施以及重定向 URI 的严格匹配，那么选择开放也是可以的）。</p>\n<p>最后，在重定向 URI 里配置好 Keycloak a 的重定向 URI（我填的是我在 Cloud IAM 中新部署的实例：<a href=\"https://lemur-2.cloud-iam.com/*%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E9%80%89%E6%8B%A9%E5%BC%80%E5%8F%91%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E9%87%8C%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91\">https://lemur-2.cloud-iam.com/*），如果是选择开发的访问类型，那么这里的重定向</a> URI 必须一字不差。但是我这里选择了保密的访问类型，所以这里使用了通配符，保持灵活性。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617021266558-9dc9736a-3198-43ad-881b-47cf68383593.png#align=left&#x26;display=inline&#x26;height=929&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1858&#x26;originWidth=2360&#x26;size=340566&#x26;status=done&#x26;style=none&#x26;width=1180\" alt=\"image.png\"><br />保存好后，切换到安全凭据面板，复制客户端密钥，后续步骤需要用到：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617021645842-86d215bf-5eb8-47a2-8ea3-3d1a8fa34dcb.png#align=left&#x26;display=inline&#x26;height=497&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=994&#x26;originWidth=2050&#x26;size=295950&#x26;status=done&#x26;style=none&#x26;width=1025\" alt=\"image.png\"><br />注意在客户端认证中选择第二项：客户端 Id 和密钥的方式，然后复制密钥。\n<a name=PZEKc></a></p>\n<h3></h3>\n<p><a name=1by2F></a></p>\n<h3>在 Keycloak a 中添加 Keycloak b 为一个身份认证服务（idp）</h3>\n<p>完成 Keycloak b 中的配置工作后，现在回到 Keycloak a，即新部署的 Cloud IAM 实例，使用 Keycloak a 的管理员账号密码登录，然后点击添加一个身份认证服务，选择 Keycloak openid connect 方式：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617021990702-8c3283b4-ce41-44bd-bf81-5e98b072dc8a.png#align=left&#x26;display=inline&#x26;height=528&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1056&#x26;originWidth=1758&#x26;size=439063&#x26;status=done&#x26;style=none&#x26;width=879\" alt=\"image.png\"><br />首先为这个身份认证服务起个名字，比如 UniHeart At Jiwai Win<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617022010876-754deb05-f7cf-475f-89c7-1938fc4d46a9.png#align=left&#x26;display=inline&#x26;height=398&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=796&#x26;originWidth=2010&#x26;size=146715&#x26;status=done&#x26;style=none&#x26;width=1005\" alt=\"image.png\"><br />然后的重点就是配置 OpenID Connect 了，基础知识又派上用场。这里最重要的是把 Keycloak b 服务器的 OIDC URI 端点中的</p>\n<ul>\n<li>/realms/{realm-name}/protocol/openid-connect/auth 以及</li>\n<li>/realms/{realm-name}/protocol/openid-connect/token</li>\n<li>/realms/{realm-name}/protocol/openid-connect/userinfo 三个端点配置进去：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617022164077-2fccf7a5-d8da-451b-b0bc-3ed26beac2b4.png#align=left&#x26;display=inline&#x26;height=982&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1964&#x26;originWidth=1942&#x26;size=255993&#x26;status=done&#x26;style=none&#x26;width=971\" alt=\"image.png\"><br />注意在客户端认证项里选择以 POST 方式发送客户端密钥，并将 UniHeart-Cloud-IAM 填写在客户端 ID 中，同时将上一步复制好的密钥粘贴进入客户端密钥一栏。</p>\n<p><a name=siLvb></a></p>\n<h3>完成</h3>\n<p>保存好就完成了。这时候点击右上角，退出当前管理员用户，就进入到了登录页面。你可以看到除了使用用户名密码登录方式之外，已经多了一个登录选项，这就是使用 Keycloak b 登录：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617022349248-b98ba6de-3870-4b3e-b455-b631a6d2d253.png#align=left&#x26;display=inline&#x26;height=260&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=520&#x26;originWidth=1608&#x26;size=114583&#x26;status=done&#x26;style=none&#x26;width=804\" alt=\"image.png\"><br /><a href=\"https://lemur-2.cloud-iam.com/auth/admin/uniheart/console/#/realms/uniheart/identity-provider-settings/provider/keycloak-oidc/uniheart-jiwai-win\">https://lemur-2.cloud-iam.com/auth/admin/uniheart/console/#/realms/uniheart/identity-provider-settings/provider/keycloak-oidc/uniheart-jiwai-win</a>，这个链接，就是使用 Keycloak b 登录 Keycloak a 的完整链接。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1617022405326-b48ecaa4-9cda-4e45-bf81-ffd738b483ee.png#align=left&#x26;display=inline&#x26;height=713&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1426&#x26;originWidth=1468&#x26;size=291986&#x26;status=done&#x26;style=none&#x26;width=734\" alt=\"image.png\"></p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}