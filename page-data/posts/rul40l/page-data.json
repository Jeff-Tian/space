{"componentChunkName":"component---src-templates-post-js","path":"/posts/rul40l","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/rul40l","relativePath":"posts/rul40l","frontmatter":{"title":"在小程序里接入 GraphQL","stackbit_url_path":"posts/rul40l","date":"2021-10-03T12:09:46","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=CNqB0></a></p>\n<h1>背景</h1>\n<p>在前几篇文章里，一直在讲 GraphQL。分别是：</p>\n<ul>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/412196725\">一顿操作猛如虎，部署一个万能 BFF</a>》，利用 Gatsjs 开发用的 GraphQL 服务器，结合其丰富的数据源插件，部署了一个几乎万能的 BFF 层。</li>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/415577362\">使用万能 BFF，将语雀文章 GraphQL 服务化</a>》，万能 BFF 层的实例，利用现有插件，直接把语雀的服务 GraphQL 化了。</li>\n</ul>\n<p>BFF 是 Backend For Frontend 的简称，是为前端服务的后端。要发挥真正的用处，还得通过前端体现。现在就给个实例，讲解如何在小程序里集成万能 BFF。</p>\n<p>前端主要有 Web、小程序以及 Native App 等。要在前端集成 GraphQL，一般采用 Apollo Client。为什么本文选择小程序作为例子呢？因为小程序是中国特色，国外没有。对于如何在 Web 端或者 Native App 端集成 GraphQL，只需要按照 <a href=\"https://www.apollographql.com/docs/\">https://www.apollographql.com/docs/</a> 官方文档的指导去做即可。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1633257522698-d87487fc-eb23-4fa5-8db7-6a4bbf88f02a.png#clientId=ue47c55fb-1388-4&#x26;from=paste&#x26;height=555&#x26;id=u4ba1cf20&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1110&#x26;originWidth=2052&#x26;originalType=binary%E2%88%B6=1&#x26;size=266427&#x26;status=done&#x26;style=none&#x26;taskId=u186d0027-8bd8-43a2-a5dc-d76454b02f2&#x26;width=1026\" alt=\"image.png\"></p>\n<p>采用小程序作为例子，不仅弥补了官方文档的空白，而且由于小程序的一些限制，在集成 GraphQL 的过程中，还面临一些额外的挑战。因为更困难，所以更加符合本专栏（哈德韦，即 Hard Way 的音译）的初衷。</p>\n<p><a name=rvtHw></a></p>\n<h1>最终成果演示</h1>\n<ul>\n<li>Web 版： <a href=\"https://taro.pa-ca.me/\">https://taro.pa-ca.me/</a></li>\n<li>微信小程序（体验版）： <br /><img src=\"https://cdn.nlark.com/yuque/0/2021/jpeg/221736/1633264280024-9d767294-7d06-49e6-83bc-1f101f827c4b.jpeg#clientId=ucd8e30da-b77a-4&#x26;from=ui&#x26;id=u19bb7dec&#x26;margin=%5Bobject%20Object%5D&#x26;name=basicprofile.jpeg&#x26;originHeight=472&#x26;originWidth=472&#x26;originalType=binary%E2%88%B6=1&#x26;size=5715&#x26;status=done&#x26;style=none&#x26;taskId=u6273ad49-2a0c-4eae-ba5d-65e881351e8\" alt=\"basicprofile.jpeg\"><br />可以微信扫码打开小程序体验版（由于还没有发布，因此只能以体验的形式），申请体验。我看到申请请求后会第一时间通过，有 100 名的限制哦，如果因为人数超限不能体验，那么请等待我的下一篇文章，如果哈德韦微信小程序正式发布上线，我会再发文通知大家。</li>\n</ul>\n<p><a name=CAFR0></a></p>\n<h1>项目源代码</h1>\n<ul>\n<li><a href=\"https://github.com/Jeff-Tian/weapp\">https://github.com/Jeff-Tian/weapp</a></li>\n</ul>\n<p><a name=uWdZq></a></p>\n<h1>Taro Js</h1>\n<p>尽管这里只做了微信小程序，但是采用了多端统一开发框架 Taro Js，从而可以打包到不同的平台。</p>\n<p><a name=Klsy5></a></p>\n<h1>挑战一：在小程序里生成 Apollo Client 实例</h1>\n<p>基本可以参考官方文档的 React 示例，但是对于小程序，却不能照搬。如果只做 Web 端，可以完全参考官网文档的 React 示例，只需要传入一个 GraphQL 服务的 url 即可。但是对于小程序，只穿 url 会报错，原因是，对于小程序，缺少默认的全局 fetch 函数，因此在生成 GraphQL 客户端实例时，要额外传递自定义的 fetch。当然，对于使用了 Taro js 的项目，只需要将 Taro.request 封装一下就好。</p>\n<p>从而最终的 GraphQL 客户端实例的生成是这样的：</p>\n<p>typescript\nimport {ApolloClient, HttpLink, InMemoryCache} from @apollo/client\nimport Taro from @tarojs/taro</p>\n<p>export const client = new ApolloClient({</p>\n<p>link: new HttpLink({\nuri: <a href=\"https://uniheart.pa-ca.me/proxy?url=$%7BencodeURIComponent(https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql)%7D\">https://uniheart.pa-ca.me/proxy?url=${encodeURIComponent(https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql)}</a>,</p>\n<pre><code>async fetch(url, options) {\n  const res = await Taro.request({\n    url: url.toString(),\n    method: POST,\n    header: {\n      content-type: application/json\n    },\n    data: options?.body,\n    success: console.log\n  })\n\n  return {text: async () => JSON.stringify(res.data)} as any\n}\n</code></pre>\n<p>}),\ncache: new InMemoryCache()\n})</p>\n<p><a name=wTsRo></a></p>\n<h1>挑战二： 允许小程序访问 GraphQL 服务</h1>\n<p>从上面的代码中可以看到这个 URL： <a href=\"https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql\">https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql</a>，这就是上一篇文章《<a href=\"https://zhuanlan.zhihu.com/p/415577362\">使用万能 BFF，将语雀文章 GraphQL 服务化</a><br />》的最终成果，它将语雀博客作为数据源，通过 AWS lambda 暴露成为一个 GraphQL 服务。而这个长长的 URL <br /><a href=\"https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql\">https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql</a> 就是利用 serverless 自动创建的 AWS API Gateway 的默认 URL。</p>\n<p>直接使用 Taro.request 访问它，在打包成为小程序后，执行到这里就会报错，原因是没有把这个域名配置在白名单里。</p>\n<p>这可以尝试通过小程序后台配置 request 合法域名解决：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1633260950771-8a09d7fe-c8e7-4ab8-9dec-6c90b17e3a82.png#clientId=ue47c55fb-1388-4&#x26;from=paste&#x26;id=uf1b50a18&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=948&#x26;originWidth=854&#x26;originalType=binary%E2%88%B6=1&#x26;size=105406&#x26;status=done&#x26;style=none&#x26;taskId=u20da5003-4739-40d1-8749-744c318b709\" alt=\"image.png\"></p>\n<p><a name=Hn6dG></a></p>\n<h1>挑战三： 域名备案</h1>\n<p>一个偷懒的做法，就是将 AWS API Gateway 的默认域名填进去，结果发现通不过域名备案检查！</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1633261047344-092fc182-3987-4c11-b33a-fcf5ae391468.png#clientId=ue47c55fb-1388-4&#x26;from=paste&#x26;height=733&#x26;id=u70d39df4&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1466&#x26;originWidth=1922&#x26;originalType=binary%E2%88%B6=1&#x26;size=197100&#x26;status=done&#x26;style=none&#x26;taskId=u49c0c570-fe03-44bf-8421-b453ec8392b&#x26;width=961\" alt=\"image.png\"></p>\n<p><a name=Okwvg></a></p>\n<h1>挑战四： Serverless 自定义域名</h1>\n<p>当然没有办法给 AWS 生成的域名去备案，但是可以不要用 AWS API Gateway 自动生成的域名，而是指定一个自定义域名，将这个自定义域名备案。</p>\n<p>由于我们的 lambda 使用了 serverless 框架自动化，要使用自定义域名，可以简单地通过增加一个 serverless 插件：serverless-domain-manager 来帮助我们自动关联这个自定义域名。利用这个插件，可以自动生成 AWS Route 53，以及关联相应的 Gateway。</p>\n<p>然而，真要这样做，需要去 AWS 上购买域名，或者将自己的域名过户到 AWS 的控制台。这……</p>\n<p>总之看起来要使用自定义域名，不那么友好，可能还需要产生额外的费用，那这个就没意思了。</p>\n<p><a name=Bl1Wn></a></p>\n<h1>挑战五： 转发 GraphQL 请求</h1>\n<p>出于节省成本的考虑，以及尽可能最大化复用已有服务，决定使用转发 GraqphQL 请求的方式。这里介绍下前情提要，我早些年备案了一个域名： pa-ca.me，并且在这上面部署了一个服务： <a href=\"https://uniheart.pa-ca.me\">https://uniheart.pa-ca.me</a> ，该项目源代码在这里： <a href=\"https://github.com/Jeff-Tian/alpha\">https://github.com/Jeff-Tian/alpha</a>。</p>\n<p>听说有的大神，可以盲写代码直接上线一次过，没有 BUG。这真令人羡慕，不过我今天也感受了一次一把过，即给已有项目 <a href=\"https://github.com/Jeff-Tian/alpha\">https://github.com/Jeff-Tian/alpha</a> 添加了一个转发 GraqphQL 请求的新功能，一次提交，自动发布后就可以使用了，效率实在令自己满意： <a href=\"https://github.com/Jeff-Tian/alpha/commit/e58dcf0e7f80643b192561e795bbb3cf050993fd\">https://github.com/Jeff-Tian/alpha/commit/e58dcf0e7f80643b192561e795bbb3cf050993fd</a>。至今没有发现 BUG，是真的很神吗？其实不是，只是有一个好习惯而已：</p>\n<p><a name=mVHJM></a></p>\n<h2>测试先行</h2>\n<p>这个已有项目是基于 eggjs 的，eggjs 其实还是有些坑的，即在发送请求时，有一个 contentType 选项，对于发送 POST 请求（GraphQL 查询本质上是一个 HTTP Post 请求），我相信多数开发都会自然设置 contentType = application/json，但是在 eggjs 生态里，这样设置是没有效果的，会导致 GraphQL 服务收不到请求 body。只一次新功能的添加，之所以一次部署就能过，其实是因为在改代码前，先写好了自动化测试。即先写好了一个期待的转发功能的正确表现，然后运行，让测试失败。然后写实现代码，再次运行测试，直到测试通过。这其中并没有想象中的那么顺利，需要尝试各种请求选项的设置，知道找到一个（或者几个）能够工作的设置组合。自动化测试的好处是让我的尝试可以很快得到验证。</p>\n<p><a name=qdawB></a></p>\n<h2>测试用例</h2>\n<p>typescript</p>\n<p>const graphql = async () => {\nconst res = await app.httpRequest()\n.post(/proxy?url=${encodeURIComponent(<a href=\"https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql)%7D\">https://jqp5j170i6.execute-api.us-east-1.amazonaws.com/dev/gatsby/graphql)}</a>)\n.type(application/json)\n.send({ query: { n  yuque(id: 53296538) {n    idn    titlen    descriptionn    n  }n  n  allYuque {n    nodes {n      idn      titlen    }n  }n}, variables: null })\n.expect(200);</p>\n<pre><code>assert.strictEqual(res.body.errors, undefined);\nassert(res.body.data.yuque.title === 快速下载 GitHub 上项目下的子目录);\n</code></pre>\n<p>};</p>\n<p>it(should proxy graphql, graphql);</p>\n<p><a name=O6H3E></a></p>\n<h2>最终实现</h2>\n<p>typescript\nsubRouter.post(/, controller.proxy.proxy.post);</p>\n<p>public async post() {\nconst { ctx } = this;</p>\n<pre><code>const { data } = (await ctx.curl(ctx.query.url, {\n  streaming: false,\n  retry: 3,\n  timeout: [ 3000, 30000 ],\n  method: POST,\n  type: POST,\n  contentType: json,\n  data: ctx.request.body,\n  dataType: json,\n}));\n\nctx.body = data;\n</code></pre>\n<p>}</p>\n<p>可见这个 contentType 必须设置成 json，才能触发 ctx.curl 以及其底层的 urlib 自动将 header 中的 content-type 设置成 application/json ！</p>\n<p>至此，就解释清楚了挑战一中，为什么生成 apollo 客户端实例时，会有一个 proxy 的 url 出现了。这一切弯弯绕绕都是因为小程序的限制，如果你足够有钱，可以接受在 AWS Route 53 里再申请一个域名，那么这一切可以得到一些简化。</p>\n<p><a name=loTkE></a></p>\n<h1>总结</h1>\n<p>本文给万能 BFF 最终在前端的使用举了一个例子，详解了如何在小程序中接入 GraphQL。因为利用了 TaroJs，所以同步部署了一个 Web 端： <a href=\"https://taro.pa-ca.me\">https://taro.pa-ca.me</a>。Web 端的集成只需要参考 Apollo 官方文档，因此没有赘述其实现，而是找了一个相对更难的实现方案：微信小程序。这不仅弥补了官方示例的空白，而且体现了中国特色。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}