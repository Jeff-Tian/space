{"componentChunkName":"component---src-templates-post-js","path":"/posts/no2vne/","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/no2vne","relativePath":"posts/no2vne","frontmatter":{"title":"幂等 —— 让函数再次纯洁","stackbit_url_path":"posts/no2vne","date":"2022-10-26T04:05:01","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<blockquote>\n<p>纯洁地做人，是一种美德。写纯函数，是程序员的美德。</p>\n</blockquote>\n<p><a name=l5SXi></a></p>\n<h1>纯函数</h1>\n<p>纯函数的美德就是，对于同样的输入，总是给予相同的输出，不改变系统的状态，不产生非预期的行为。非纯函数会导致各种意想不到的后果，并且很难排查原因。曾经遇到过一个奇葩的偶现问题，就是由于非纯函数导致的，后面花费了很长时间才定位到问题，详见： <a href=\"https://zhuanlan.zhihu.com/p/351300690\">https://zhuanlan.zhihu.com/p/351300690</a> 一文中的血淋淋的例子。</p>\n<p>虽然总是呼吁大家写纯函数，但现实总是会接触到不纯的函数代码。上文中提到的例子，最后的修复办法也是改写了不纯的部分代码，让原来的不纯的函数成为一个纯函数。那个问题虽然难以重现和排查，但好在修改起来的代码量非常小，改写是容易的。除这种情况之外，本文又提供了一个案例，不仅排查困难，而且改写也麻烦。在这种情况下，又提供了另一种方式，只需要在不纯的函数头部添加一个<strong>幂等修饰符</strong>，就让它再次纯洁起来，这样完全可以不用改写。</p>\n<p>一般我们说幂等，是从系统外部视角，针对的是用户做的某些操作，映射为后端服务中的某些 API。比如我们常说某某接口是幂等的，特别是 GET 请求的接口，只要输入参数一样，返回结果永远一样。本文实现的幂等修饰符，是方法级别的，粒度更细。当然，如果这个方法本来就是纯函数，自然不需要这个幂等修饰符了。如果某个方法有副作用，它就派上了用场，可以在不改变方法实现的前提下，让它的行为和纯函数一样，完全不需要了解函数到底做了啥。</p>\n<p>本文将从实际问题引入，并以 TDD （非教条主义的）的开发方式，以及渐进增强的思想，逐步实现这个“幂等修饰符”。具体编程语言是该实际项目用到的 TypeScript。</p>\n<p><a name=M9xgo></a></p>\n<h1>非纯函数惹的祸</h1>\n<p>但是，如果维护一个屎山项目时，你不要期待迎接你的全是纯函数。我最近遇到一个情况，对于系统中的消息通知呀，有时候有用户反映，一模一样的通知，会收到两条甚至更多条。<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/68da5529db112f303f537886638a62e1/d9199/1666695815384-554d33af-1ff8-4eda-941d-fd383ed70363.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 167.56756756756758%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAACE4AAAhOAFFljFgAAAC6klEQVR42s2WWU9qUQyFeTcmgAyCDIIDoIDMsxMBAkRjfDDEmPj//0Vvvt70ZHM4OCT34T403WPParv2gtDR0ZHss0wmI6enp5LL5XScz+clm83KV3dC4XBYIpFIoEWjUe8gY7N954kVisfjkkwmJRaLeUaA4+NjXQ8y9syYWwx8iACFQkFqtZpcX1/Lzc2NNJtNSaVSegG/z9hPp9Nyfn6upSFWiBQqlYosFguZz+fy8vIir6+vetACuojM3IDVak0uLi7+BgSmm14ikVALQueuuUG3UraAFsiCYXyRfTzrLtqgkmzVsF6vaw2pH3OoMplMZDAYyP39vTQajb2obd1DCMfOzs6kWCyqZ35yciJXV1daXz5E4X8UEIR0iMvlclkvgw4Cg4r1Xq+nga0JWFDXvYC8gFKppJ3iIh8AYbVa1TllwMNP46nLWxqylTJouABCUiYYBjepLYFBCmJ42u12dcweZwBg3faaQlqtVksPWMq3t7famPF4LP1+X41gj4+POuZ8p9PR+hrlPNoYRfy0CbJvU/Z3y2/WiH221RR7eqPRSD0pLZdLTRU/m812Xoif3NAM2+oyHcbDRTqO5wOXl5eBb9k1Q+ohNI3z6x36hn0lqK5xd0cPbfM7VK7t6CHcg7xwixryfl35+koP8dynXBoQNNRsOp3Kw8ODrFYreXp6+jd6aPJlVPq/9JA3ypvlOZke3t3dKR8pB+u/0kN4RyC86aEpEKLB+o/10P+rh3ogDjx81kGJ/67rXkDSAwkoeBnMQchLASXBrItcMnFgbA3ZCWgICWgpt9ttRQlHMSSOOYhtHe6S4ZYekiKbpAsq0iUoASC6CSr72HA41CYhsMwh9o4eGvwgPbQ9M1J25zt6uO9Hx9Z/rYfUjt9ePNL+/PysHFyv16qHfpRG8kA9NB4aVXjkFJnuWtEZm8FJ9i1No5Knh6722fjg4EAL//HxIW9vb/L+/q622Wzk8/NT1f3w8DDwf+Mfi4+UMqFWrcEAAAAASUVORK5CYII='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/68da5529db112f303f537886638a62e1/fcda8/1666695815384-554d33af-1ff8-4eda-941d-fd383ed70363.png\"\n        srcset=\"/static/68da5529db112f303f537886638a62e1/12f09/1666695815384-554d33af-1ff8-4eda-941d-fd383ed70363.png 148w,\n/static/68da5529db112f303f537886638a62e1/e4a3f/1666695815384-554d33af-1ff8-4eda-941d-fd383ed70363.png 295w,\n/static/68da5529db112f303f537886638a62e1/fcda8/1666695815384-554d33af-1ff8-4eda-941d-fd383ed70363.png 590w,\n/static/68da5529db112f303f537886638a62e1/efc66/1666695815384-554d33af-1ff8-4eda-941d-fd383ed70363.png 885w,\n/static/68da5529db112f303f537886638a62e1/d9199/1666695815384-554d33af-1ff8-4eda-941d-fd383ed70363.png 960w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><a name=vLCGt></a></p>\n<h1>简要分析和修复想法</h1>\n<p>我看了一下代码，发送消息是由一个长长的函数进行处理的，而这个函数有很多触发路径，比如接口触发、定时触发、消息队列触发等等，所以要从源头找出原因并不容易。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8a9358355071594dab5589ce9f647477/4b2cc/1666696174946-1801fdd4-e216-461c-adcd-d9408d1b6a90.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 166.2162162162162%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAhCAYAAADZPosTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEaklEQVR42oWWyXLkRgxE9TNjNVn7Xlya6pE08sEOX+yDj/7/n3iOKvY6UtgHBCPIKnQCmQn00zSv+JgwxlC84n3SvCyF99eNjx8nXr+vHNeZXCdqydSSmGqhBkuKFh8c1ji81VireQqp4GJCSMkoBNuSKDmhtEG1Q14h1Yi2mhI1c1LUZLE+IrXE+UDymRo1JWieUpnwMSOlQknBaU5s399p74MRROvxJjElR8oZbyPBJrwNjOPAOI4PcUuoFGIcCVbx8bpwWgshBIw1uGhxQeNCS1oIPWnEu4iUEjEKhNijJ3Qd4V6yVpLqxh7OyH5ISoE4h9K6VyOFRAl1RdbOdYS5zleEUoyUFJmnSg6ZmCoxF8o8E2OixBlnPVIopFYIK5BW9buXpDeE55dWS95mzVY9y5RYJsd2jORaKC8zcSuEkijLRNgybgooo28J413CYRzxVvH728SxBmqJlGwoxRFSwGWHnz0uW2IOhOAJyeGzRWnZOXiKuXbZtL6MY+uhYs6eaARKjByGkWE4szjcRWd4eOjfmeX5Kpv2QTVyhgHZyLg72C+eL/9X3LG8k1KDokyVMk3kWillokZDTYWcZrwJ1KbJFIgx4r1HW4X1uj+vTrkkTE7seiu5CzmmRKkTxlqkvjX/53gQdkPYrNec8jpHjtuJ728fTMtKTJkUdjH7ENHNOSEQ/C7uLqPWpnHsLbqxLGUX8BQdubSSZ5z33RkNqXOeVGpH2nr8s+Wuwv7Zeta0fgSM8xgXEErzfBg4HIaHy59jfHSKUjvLTdjHZeJlnfj+cuT1tLAURw4GIeSXiS7odmHf6XD/IBDDgRQc0VmclmRv8UYzDENHe0E89NJv6D7J5jII2sHm4ePLqVtunmeCt4ToWGpgLY657CRdEPakLeG9bG5lSJRW2GDwybGtkW22nNbE8biwHRfmeUJr80k6nxBe+ujUiNcCLdvBNtokh17yocfhcDiXfGF6QGv9mZSWeImK306BrU2UGPs+aT+szoh2icmr1KTc0TXXnEk5y6bBPqPMyfeeuWhI2ZCTo5bSrdeQtB0zZcdaDMfJ90XXJvwnlq8SkJKQPdMycdpmfryuXULex+6eEFN/9hUgdiKdc48T+5KwHdLGnEtSiOZzZZBK99a0bx3lHSnXhPGBlPFKSpuH0Yx9Jl6afk/A/fNLhBdSeuPHoU8eeWnB/8zAh4T3W68hNKqVa9FKdG9/5d+v/HyX8NbDVt7Ud3DCtz61Noy70NuFi+7u59/9jzRQD6S0l21MLevGnApbzizrC+s6MZXQmf2vssfbkrokFH3rvcyBUhLWGowzWKexWvXZqJQ+I93RDudldd0pDwiF7P/AtmqpNVKKZ6qWqXpMSLgQCW1+hkxwGe08wSWCi4/Txp9JaXs5iYFf1Tfe1Tc2+cwinnmTz3zIZ6IcyUoQpSA0N4kBLeR1BTwMhyZUaR1/e8E/+hf+0gf+NCN/GMFRjlghcFLwJp5ZxcAkB97FM7b/59kN0OJfEscFHzcOEWIAAAAASUVORK5CYII='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/8a9358355071594dab5589ce9f647477/fcda8/1666696174946-1801fdd4-e216-461c-adcd-d9408d1b6a90.png\"\n        srcset=\"/static/8a9358355071594dab5589ce9f647477/12f09/1666696174946-1801fdd4-e216-461c-adcd-d9408d1b6a90.png 148w,\n/static/8a9358355071594dab5589ce9f647477/e4a3f/1666696174946-1801fdd4-e216-461c-adcd-d9408d1b6a90.png 295w,\n/static/8a9358355071594dab5589ce9f647477/fcda8/1666696174946-1801fdd4-e216-461c-adcd-d9408d1b6a90.png 590w,\n/static/8a9358355071594dab5589ce9f647477/efc66/1666696174946-1801fdd4-e216-461c-adcd-d9408d1b6a90.png 885w,\n/static/8a9358355071594dab5589ce9f647477/4b2cc/1666696174946-1801fdd4-e216-461c-adcd-d9408d1b6a90.png 1013w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>可以看到，它的输入参数是一个名为 post 的 PostRecord 对象，好在它有一个的 postId 键值，同一个消息推送通知，拥有一个唯一的 postId 键值：\ntypescript</p>\n<p>export class PostRecord {\n...\n@Expose()\npostId: string\n...\n}</p>\n<p>它的问题在于，对于同一个 postId 的消息推送通知对象，被不同的调用路径分别处理了多次，所以很自然的想法是，使用 postId 作为缓存键，将发送结果（布尔值）作为缓存值，将第一次执行的结果保存下来，后面的执行直接短路返回第一次执行的结果值。而且，通过修饰符来添加这个功能，似乎是最优雅的，因为对原有代码没有任何修改，只在方法头部增加一行而已：</p>\n<p>diff</p>\n<ul>\n<li>@idempotent()</li>\n</ul>\n<p>public async handlePost(post: PostRecord): Promise<boolean> {\n...</p>\n<p><a name=DZcvk></a></p>\n<h1>版本一：一个幼稚的实现</h1>\n<p>只考虑一个服务实例的情况，也就是一个进程。那么只需要使用一个内存变量来做这个缓存存储就行了。\n<a name=zGzK3></a></p>\n<h2>先写测试</h2>\n<p>有了这个想法，为了文档、以及保证后面的扩展过程顺利，先写测试来构建安全屏障。尽管测试也是一个一个实现的，但为了行文不啰嗦，这里直接贴出主要测试用例代码：\ntypescript\nimport { idempotent } from @/utils/idempotent</p>\n<p>let count = 0</p>\n<p>class TestingClass {\n@idempotent()\ntestMethod() {\nconsole.log(adding count = , count)\nreturn count++\n}\n}</p>\n<p>describe(idempotent, () => {\nit(a function without idempotent annotation would be called multiple times, async () => {\nlet c = 0\nconst testFunction = jest.fn().mockImplementation(() => c++)\ntestFunction()\ntestFunction()</p>\n<pre><code>    expect(testFunction).toHaveBeenCalledTimes(2)\n    expect(c).toEqual(2)\n})\n\nit(a function with idempotent annotation would only be called once, async () => {\n    const sut = new TestingClass()\n\n    sut.testMethod()\n    sut.testMethod()\n\n    expect(count).toEqual(1)\n})\n</code></pre>\n<p>})</p>\n<p>其实，主要的测试意图就是，多次调用一个方法，如果该方法没有幂等修饰符，那么该方法带来的影响是多次执行；而如果这个方法有幂等修饰符呢，其效果是只有第一次是真正执行了，后续的执行被短路了。于是写了这样的一个幼稚实现版本：\n<a name=ep2w5></a></p>\n<h2>实现</h2>\n<p>typescript\nconst cache = {}</p>\n<p>export function idempotent() {\nconsole.log(making ,  idempotent)\nreturn function (target, propertyKey, descriptor) {\nconsole.log(idempotent called: , target, propertyKey, descriptor)\nconsole.log(target.propertyKey = , target[propertyKey].toString())</p>\n<pre><code>    const originalMethod = descriptor.value\n\n    descriptor.value = () => {\n        console.log(cache = , cache)\n        if (typeof cache[propertyKey] === undefined) {\n            cache[propertyKey] = originalMethod()\n        }\n\n        return cache[propertyKey]\n    }\n\n    console.log(target.propertyKey  now = , target[propertyKey].toString())\n}\n</code></pre>\n<p>}</p>\n<p>提交代码。\n<a name=SbCT7></a></p>\n<h1>增强版本</h1>\n<p>然后再回头审视代码，这个缓存键用了方法名，但没有类信息，会导致不同类的同一方法名，出现混淆情况。我们将类的信息也编码到缓存键里去：\ndiff\nconst cache = {}</p>\n<p>export function idempotent() {</p>\n<ul>\n<li>console.log(making ,  idempotent)</li>\n</ul>\n<pre><code>return function (target, propertyKey, descriptor) {\n</code></pre>\n<ul>\n<li>\n<pre><code>   console.log(idempotent called: , target, propertyKey, descriptor)\n</code></pre>\n</li>\n<li>\n<pre><code>   console.log(target.propertyKey = , target[propertyKey].toString())\n</code></pre>\n</li>\n<li></li>\n</ul>\n<ul>\n<li>\n<pre><code>  const cacheKey = ${target.constructor}.${propertyKey}\n  const originalMethod = descriptor.value\n\n  descriptor.value = () => {\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>\n<pre><code>       console.log(cache = , cache)\n</code></pre>\n</li>\n<li>\n<pre><code>       if (typeof cache[propertyKey] === undefined) {\n</code></pre>\n</li>\n<li>\n<pre><code>           cache[propertyKey] = originalMethod()\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>\n<pre><code>       if (typeof cache[cacheKey] === undefined) {\n</code></pre>\n</li>\n<li>\n<pre><code>           cache[cacheKey] = originalMethod()\n      }\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>\n<pre><code>       return cache[propertyKey]\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>\n<pre><code>       return cache[cacheKey]\n  }\n</code></pre>\n</li>\n</ul>\n<ul>\n<li></li>\n<li>\n<pre><code>   console.log(target.propertyKey  now = , target[propertyKey].toString())\n</code></pre>\n}</li>\n</ul>\n<p>}</p>\n<p>测试通过，提交代码。</p>\n<p>再次审视，我们需要将对象的信息编码进入缓存键中，不然，同一个类下的不同对象之间也会出现混淆，这是一个后面的优化点。</p>\n<p><a name=CrGzB></a></p>\n<h1>继续增强——支持参数</h1>\n<p>以上的实现版本，幂等装饰器是一个不带参数的函数。这次再增强一下，允许传入一个函数作为幂等装饰器的参数，该函数接收装饰目标方法的参数为参数，并返回一个键值，成为缓存键的一部分。整个过程就不啰嗦了，为了测试这些场景，新的测试文件内容如下：</p>\n<p>typescript\nimport { idempotent } from @/utils/idempotent/idempotent</p>\n<p>describe(idempotent, () => {\ndescribe(idempotent without key, () => {\nlet count = 0</p>\n<pre><code>    class TestingClass {\n        @idempotent()\n        async testMethod() {\n            return count++\n        }\n    }\n\n    it(a function without idempotent annotation would be called multiple times, async () => {\n        let c = 0\n        const testFunction = jest.fn().mockImplementation(() => c++)\n        testFunction()\n        testFunction()\n\n        expect(testFunction).toHaveBeenCalledTimes(2)\n        expect(c).toEqual(2)\n    })\n\n    it(a function with idempotent annotation would only be called once, async () => {\n        const sut = new TestingClass()\n\n        await Promise.all([sut.testMethod(), sut.testMethod()])\n\n        expect(count).toEqual(1)\n    })\n})\n\ndescribe(idempotent with key, () => {\n    class TestingClass {\n        @idempotent((obj) => obj.id)\n        testMethod(obj: { id: string; count: number }) {\n            obj.count++\n            return obj.count\n        }\n    }\n\n    it(calls testMethod multiple times, only the 1st one takes effect, async () => {\n        const sut = new TestingClass()\n        const obj1 = { id: 1, count: 0 }\n        const obj2 = { id: 2, count: 0 }\n\n        sut.testMethod(obj1)\n        sut.testMethod(obj1)\n        sut.testMethod(obj2)\n\n        expect(obj1.count).toEqual(1)\n        expect(obj2.count).toEqual(1)\n    })\n})\n</code></pre>\n<p>})</p>\n<p>其实，主要的测试意图就是，多次调用一个方法，如果该方法没有幂等修饰符，那么该方法带来的影响是多次执行；而如果这个方法有幂等修饰符呢，其效果是只有第一次是真正执行了，后续的执行被短路了。然后，分别考虑这个方法接收参数与不接收参数的场景，不接收参数，该方法至多只会被执行一次；接收参数，对“同样的”参数至多只执行一次。但是这个“同样”的涵义，是在写修饰符时定义的。也就是说，这个修饰符自己也接受一个参数，用来定义这个“同样”。比如根据参数的某个唯一属性决定，或者自行实现一个哈希值进行比对，都可以。</p>\n<p>满足这样的测试的装饰器实现如下：</p>\n<p>typescript\nimport * as crypto from crypto\nimport { sleep } from @/common</p>\n<p>const inMemoryStorage = {\nexecutedMethods: {},\nreturnValues: {},\n}</p>\n<p>export enum MethodStatus {\npending = 0,\ndone = 1,\nerror = 2,\n}</p>\n<p>export interface IIdempotentStorage<T> {\nget: (hash: string) => Promise<T>\nsaveReturnValuesIfNotExecuted: (hash: string, valueEvaluator: () => Promise<T>) => Promise<void>\n}</p>\n<p>export class HashDuplicationError extends Error {}\nexport class OriginalMethodError extends Error {\nconstructor(readonly originalError: Error) {\nsuper()\n}\n}</p>\n<p>export class InMemoryIdempotentStorage<T> implements IIdempotentStorage<T> {\nasync saveReturnValuesIfNotExecuted(hash: string, valueEvaluator: () => Promise<T>) {\nif (inMemoryStorage.executedMethods[hash] === undefined) {\ninMemoryStorage.executedMethods[hash] = MethodStatus.pending</p>\n<pre><code>        try {\n            inMemoryStorage.returnValues[hash] = await valueEvaluator()\n        } catch (ex) {\n            inMemoryStorage.executedMethods[hash] = MethodStatus.error\n            inMemoryStorage.returnValues[hash] = ex\n\n            throw new OriginalMethodError(ex)\n        }\n\n        inMemoryStorage.executedMethods[hash] = MethodStatus.done\n    }\n}\n\nasync get(hash) {\n    if (inMemoryStorage.executedMethods[hash] === MethodStatus.error) {\n        throw new OriginalMethodError(inMemoryStorage.returnValues[hash])\n    }\n\n    if (inMemoryStorage.executedMethods[hash] !== MethodStatus.done) {\n        await sleep(500)\n\n        return await this.get(hash)\n    }\n\n    return inMemoryStorage.returnValues[hash]\n}\n</code></pre>\n<p>}</p>\n<p>export function idempotent<T>(hashFunc?, idempotentStorage: IIdempotentStorage<T> = new InMemoryIdempotentStorage()) {\nreturn function (target, propertyKey, descriptor) {\nconst cachePrefix = ${crypto\n.createHash(md5)\n.update(target.constructor.toString())\n.digest(hex)}.${propertyKey}\nconst originalMethod = descriptor.value</p>\n<pre><code>    descriptor.value = async function (...args) {\n        const hash = hashFunc ? hashFunc(...args) : \n        const cacheKey = ${cachePrefix}:${hash}\n        const fallback = async () => await originalMethod.call(this, ...args)\n\n        const idempotentOrFallback = async () =>\n            await Promise.race([\n                idempotentStorage.get(cacheKey),\n                new Promise((resolve, reject) => setTimeout(reject, 30000)),\n            ]).catch(fallback)\n\n        try {\n            await idempotentStorage.saveReturnValuesIfNotExecuted(cacheKey, fallback)\n        } catch (ex) {\n            // if its duplicate error, wait for done and then get\n            if (ex instanceof HashDuplicationError) {\n                return await idempotentOrFallback()\n            } else if (ex instanceof OriginalMethodError) {\n                throw ex.originalError\n            } else {\n                console.error(ex)\n                return await fallback()\n            }\n        }\n\n        return await idempotentOrFallback()\n    }\n}\n</code></pre>\n<p>}</p>\n<p>这中间跳跃比较大了，实际情况并不是一步到位的。有一个改动比较明显，即装饰器函数变复杂了。其中 descriptor.value 不再用箭头表达式，而是用了 function。这是为了利用 this，保证如果目标方法依赖类中的其他属性或者成员，在被装饰器改写后，仍然可以照常使用，而不会报 某某方法、成员、或者属性在 undefined 中不存在等之类的错误。</p>\n<p>还可以看到，内存缓存不再是一个对象，而是包括了两个对象的对象。这是由于考虑到异步函数，存在方法正在执行但是返回结果还没有拿到的情况，所以增加了executedMethods做为了一个互斥锁。并且将装饰器的依赖，显式使用接口 IIdempotentStorage 说明，不再隐式依赖内存缓存。同时，使用 class 方式实现了使用内存缓存的幂等存储接口 IIdempotentStorage 。</p>\n<p>这个接口设计上只有两个方法，即 saveReturnValuesIfNotExecuted 和 get。get 显然就是用来获取缓存值的，并且保证获取到值，如果装饰目标函数正在运行，值还没有拿到，这个 get 不会返回，也不会返回空，而是会等待一段时间，再去获取，直到获取到值。若因为某种原因一直拿不到返回值，最终这个装饰目标方法会报超时错误，这个逻辑见装饰器的代码。</p>\n<p>这个接口的另一方法，叫 saveReturnValuesIfNotExecuted，会被装饰后的方法首先执行。这个方法名很长，正如这个名字暗示的，只会在第一次执行原方法时保存返回值到存储中。这个方法，在执行原方法时，需要先检查是不是已经有一个实例在执行中了，即需要先拿到一个互斥锁。所以会在 InMemoryIdempotentStorage看到对之前说的 executedMethods进行检查。由于是内存存储，通过这个锁来防止对原方法的重复调用是简单且有效的，在后面增加非内存存储时，就需要利用别的机制了，会更复杂一些。\n<a name=aZEf4></a></p>\n<h1>版本二：支持多个服务实例</h1>\n<p>在版本一实现后，非常清楚这个方式解决问题的关键在于需要一个缓存存储。内存版本只能支持一个服务实例，<strong>要支持多个服务实例，我们必须找到一个外部存储</strong>，这个外部存储可以是 Redis、也可以是其他数据库。本文采用了 DynamoDb 作为缓存存储，因为该项目已经引用了 AWS 的 DynamoDb，并且没有使用 Redis，所以继续沿用不需要增加依赖。如果使用 Redis 的话，可以考虑使用 RedLock 这个库，它应该是利用了 Redis 的分布式锁功能。据说 DynamoDb 也有分布式锁方案，但是本文没有采用分布式锁，而且利用了数据库的唯一约束，完成了幂等功能，详见后面的叙述。\n<a name=CcqOQ></a></p>\n<h2>测试先行</h2>\n<p>既然决定了使用 DynamoDb，那么有个挑战就是如果在测试时，排除 DynamoDb 这个外部依赖。好在之前有文章《扫清 Cloud Native 开发时的 TDD 障碍 - Jeff Tian的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/555302858%E3%80%8B%E5%B7%B2%E7%BB%8F%E9%83%A8%E5%88%86%E8%A7%A3%E5%86%B3%E4%BA%86%E8%BF%99%E4%B8%AA%E6%8C%91%E6%88%98%EF%BC%8C%E5%8D%B3%E9%80%9A%E8%BF%87\">https://zhuanlan.zhihu.com/p/555302858》已经部分解决了这个挑战，即通过</a> Mockery 将 AWS SDK 中的方法用 jest.fn() 去模拟掉了，但是，本篇文章的需求，要使用更多的 AWS SDK 中的方法，所以需要在那篇文章的基础上，增加更多的模拟。</p>\n<p>主要是，在实现接口的 saveReturnValuesIfNotExecuted方法时，需要利用数据库的唯一约束，在多次写入同一键值时，能够让数据库报错。这里使用了 AWS DynamoDb 的 transactWriteItems方法，在测试中，需要将它模拟掉：</p>\n<p>diff\nexport const mockDynamoDB = {</p>\n<ul>\n<li>transactWriteItems: jest.fn().mockImplementation((params: DynamoDB.Types.TransactWriteItemsInput) => {</li>\n<li>\n<pre><code>   return {\n</code></pre>\n</li>\n<li>\n<pre><code>       promise: () => {\n</code></pre>\n</li>\n<li>\n<pre><code>           const hash = params.TransactItems[0].Put?.Item[hash].S\n</code></pre>\n</li>\n<li></li>\n<li>\n<pre><code>           if (!hash) {\n</code></pre>\n</li>\n<li>\n<pre><code>               return Promise.reject(hash empty!)\n</code></pre>\n</li>\n<li>\n<pre><code>           }\n</code></pre>\n</li>\n<li></li>\n<li>\n<pre><code>           if (!db[hash]) {\n</code></pre>\n</li>\n<li>\n<pre><code>               db[hash] = params.TransactItems[0].Put?.Item\n</code></pre>\n</li>\n<li>\n<pre><code>               return Promise.resolve()\n</code></pre>\n</li>\n<li>\n<pre><code>           } else {\n</code></pre>\n</li>\n<li>\n<pre><code>               return Promise.reject(duplicated!)\n</code></pre>\n</li>\n<li>\n<pre><code>           }\n</code></pre>\n</li>\n<li>\n<pre><code>       },\n</code></pre>\n</li>\n<li>\n<pre><code>   }\n</code></pre>\n</li>\n<li>}),</li>\n<li>describeTable: jest.fn().mockImplementation(({ TableName }) => {</li>\n<li>\n<pre><code>   return {\n</code></pre>\n</li>\n<li>\n<pre><code>       promise: () => {\n</code></pre>\n</li>\n<li>\n<pre><code>           return Promise.resolve({ TableName })\n</code></pre>\n</li>\n<li>\n<pre><code>       },\n</code></pre>\n</li>\n<li>\n<pre><code>   }\n</code></pre>\n</li>\n<li>}),</li>\n</ul>\n<pre><code>createTable: jest.fn().mockImplementation(() => {\n    return {\n</code></pre>\n<p>打通了这个自动化测试障碍，就可以写测试用例了。主要的测试目的，就是验证当我们实现了基于 DynamoDb 的幂等存储后，如果尝试多次调用 saveReturnValuesIfNotExecuted方法，只有第一次的调用能够成功，而重复的调用应该抛错，并且 get只会取到第一次存储的值。</p>\n<p>typescript\nimport { mockAwsSdk } from ../../../test/mocks/aws\njest.mock(aws-sdk, () => mockAwsSdk)</p>\n<p>import { DynamodbIdempotentStorage } from @/utils/idempotent/dynamodb.idempotent.storage\nimport { AWSAdapterService } from @/common/adapters/aws\nimport { HashDuplicationError } from @/utils/idempotent/idempotent</p>\n<p>describe(dynamodb.idempotent.storage, () => {\nit(throws HashDuplicationError when saving duplicate hash record, async () => {\nconst dynamodbStorage = new DynamodbIdempotentStorage(new AWSAdapterService())\nawait dynamodbStorage.saveReturnValuesIfNotExecuted(1234, async () => {\nreturn hello\n})</p>\n<pre><code>    await expect(async () => {\n        await dynamodbStorage.saveReturnValuesIfNotExecuted(1234, async () => {\n            return world2\n        })\n    }).rejects.toThrow(HashDuplicationError)\n\n    const res = await dynamodbStorage.get(1234)\n    expect(res).toStrictEqual(hello)\n})\n</code></pre>\n<p>})</p>\n<p><a name=aIR1S></a></p>\n<h2>基于 DynamoDb 的幂等存储</h2>\n<p>也不啰嗦，最后的实现大致是这样的:\ntypescript\nimport {\nHashDuplicationError,\nIIdempotentStorage,\nMethodStatus,\nOriginalMethodError,\n} from @/utils/idempotent/idempotent\nimport { BaseDynamoService } from @/common/base\nimport { Expose, plainToClass } from class-transformer\nimport { DynamoDB } from aws-sdk\nimport { sleep } from @/common</p>\n<p>export class IdempotentCache {\n@Expose()\nhash: string</p>\n<pre><code>@Expose()\nstatus: MethodStatus\n\n@Expose()\nreturnValue: string\n\n@Expose()\nttl: number\n</code></pre>\n<p>}</p>\n<p>const getTtl = () => Math.floor(new Date().getTime() / 1000 + 3600 * 24)</p>\n<p>export class DynamodbIdempotentStorage<T> extends BaseDynamoService<IdempotentCache> implements IIdempotentStorage<T> {\nasync get(hash: string): Promise<T> {\nconst record = await this.getItem({\nTableName: this.table,\nKey: {\nhash: { S: hash },\n},\n})</p>\n<pre><code>    if (record &#x26;&#x26; record.status.toString() === MethodStatus.error.toString()) {\n        throw new OriginalMethodError(new Error(record.returnValue))\n    }\n\n    if (!record || record.status.toString() !== MethodStatus.done.toString()) {\n        console.log(record of , hash,  = , record)\n\n        await sleep(500)\n        return await this.get(hash)\n    }\n\n    return record?.returnValue ? JSON.parse(record?.returnValue) : undefined\n}\n\nasync saveReturnValuesIfNotExecuted(hash: string, valueEvaluator: () => Promise&#x3C;T>): Promise&#x3C;void> {\n    await this.ensureTable(this.table)\n    try {\n        await this.transactionalWriteItems({\n            TransactItems: [\n                {\n                    Put: {\n                        TableName: this.table,\n                        ConditionExpression: attribute_not_exists(#hsh),\n                        ExpressionAttributeNames: { #hsh: hash },\n                        Item: this.toAttributeMap({\n                            hash,\n                            status: MethodStatus.pending,\n                            returnValue: ,\n                            ttl: getTtl(),\n                        }),\n                    },\n                },\n            ],\n        })\n    } catch (ex) {\n        console.error(ex)\n        throw new HashDuplicationError(ex.message)\n    }\n\n    let returnValue\n    try {\n        returnValue = await valueEvaluator()\n    } catch (ex) {\n        const item = this.toAttributeMap({\n            hash,\n            status: MethodStatus.error,\n            returnValue: ex.message,\n            ttl: getTtl(),\n        })\n        await this.putItem({\n            TableName: this.table,\n            Item: item,\n        })\n\n        throw new OriginalMethodError(ex)\n    }\n\n    const item = this.toAttributeMap({\n        hash,\n        status: MethodStatus.done,\n        returnValue: JSON.stringify(returnValue),\n        ttl: getTtl(),\n    })\n\n    await this.putItem({\n        TableName: this.table,\n        Item: item,\n    })\n}\n\nprotected getTableConfig(): Partial&#x3C;DynamoDB.CreateTableInput> {\n    return {\n        TableName: this.table,\n        AttributeDefinitions: [\n            {\n                AttributeName: hash,\n                AttributeType: S,\n            },\n        ],\n        KeySchema: [\n            {\n                AttributeName: hash,\n                KeyType: HASH,\n            },\n        ],\n    }\n}\n\nprotected toAttributeMap(record: IdempotentCache): DynamoDB.AttributeMap {\n    return {\n        hash: this.toS(record.hash),\n        status: this.toS(record.status),\n        returnValue: this.toS(record.returnValue),\n        ttl: this.toN(record.ttl),\n    }\n}\n\nprotected toInstance(item: DynamoDB.AttributeMap): IdempotentCache {\n    return plainToClass(IdempotentCache, {\n        hash: this.toValue(item.hash),\n        status: this.toValue(item.status),\n        returnValue: this.toValue(item.returnValue),\n        ttl: this.toValue(item.ttl),\n    })\n}\n\nprotected getTTLConfig(): Partial&#x3C;DynamoDB.UpdateTimeToLiveInput> | null {\n    return {\n        TimeToLiveSpecification: {\n            Enabled: true,\n            AttributeName: ttl,\n        },\n    }\n}\n</code></pre>\n<p>}</p>\n<p>这个实现，依赖了一个 BaseDynamoService，关于它的更多信息，见之前的《强行在 TypeScript 里应用 C# 的 partial class - Jeff Tian的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/561384584%E3%80%8B%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E5%AF%B9\">https://zhuanlan.zhihu.com/p/561384584》，其实就是对</a> Aws Sdk 中的 DynamoDb 做了一些封装。</p>\n<p>另外，利用了 DynamoDb 的 ttl 机制，只缓存一天的数据。</p>\n<p>关于前面和这里反复用到的 sleep 函数，相信你分分钟就能写一个吧，不做赘述。</p>\n<p>测试通过，提交代码。\n<a name=ve0Nu></a></p>\n<h2>在真实的 AWS 环境里测试</h2>\n<p>尽管测试愉快地通过了，但那都是基于我们模拟的环境。如果放在真实的 AWS 环境，它真的会如期工作吗？真的会！<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c66872aacc5e9a186b0c8af4dab5c382/bc3ae/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.78378378378378%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABYUlEQVR42qWT226DMAyGef8n2ivsejdT10JHD5RSKCSEHOGfbKDd1u4gNdInJ475Exsnkm0LKVuk6QZxkuB1scAqTrB4e0O63YL2GyG+IKREWQu873PkeY7skCPdbFE3DaKyLBHHCaqqgrUWXdfBGAOt9WV+D20MVNdxDMUSrVKITqcSy1WMsqwQQmBRrQ3bvu/ZF8jeEHi//+TrtEZUFCck6zWn7ZzjE4UQfPr8wc8MV9EwCTbKQCgNGmHaHIYB/TCMt7uDD+ESN0ODyhCpQwxdZQj96HxksGD78oR2+QypHdftEahMUW0U6k6hrhtuEaqj/Sfu25wF99kO6SaFMZad3vs/Cd5zLPVj0wimOJWjoFKK/6yzJGhHO2Ht7ZqYe7Gb+lBKCeoWyjDSxsJYB0P9Z37HsDV8o1mMU1WKX0lLgsVZID9L5ki2uq5n33GaV5xecxGiSzjvOfXdPsO5rvEBfRCjxI1pXq4AAAAASUVORK5CYII='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"WX20221020-113819.png\"\n        title=\"WX20221020-113819.png\"\n        src=\"/static/c66872aacc5e9a186b0c8af4dab5c382/fcda8/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png\"\n        srcset=\"/static/c66872aacc5e9a186b0c8af4dab5c382/12f09/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png 148w,\n/static/c66872aacc5e9a186b0c8af4dab5c382/e4a3f/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png 295w,\n/static/c66872aacc5e9a186b0c8af4dab5c382/fcda8/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png 590w,\n/static/c66872aacc5e9a186b0c8af4dab5c382/efc66/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png 885w,\n/static/c66872aacc5e9a186b0c8af4dab5c382/c83ae/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png 1180w,\n/static/c66872aacc5e9a186b0c8af4dab5c382/bc3ae/1666756109984-549f815d-345f-429d-addf-1736e87dc06b.png 1268w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>这里分享一下从本地连接真实的 AWS 环境进行测试的技巧。首先，需要安装 aws 命令行，登录之后，你可以 cat ~/.aws/config 看到一些关键信息，如：</p>\n<p>shell\n[default]\naws_access_key_id = xxxx\naws_secret_access_key = yyy\naws_session_token = zzz\noutput = json\nregion = cn-northwest-1</p>\n<p>要在跑测试时，通过以上信息连接到真实的 AWS 环境，需要将环境变量 AWS_SDK_LOAD_CONFIG�设置为 1，于是要么：\nshell\nAWS_SDK_LOAD_CONFIG=1 yarn test</p>\n<p>要么，在测试文件顶部加入：\nshell\nprocess.env[AWS_SDK_LOAD_CONFIG] = 1</p>\n<p>并且删除之前的对 mock 的执行：\ndiff</p>\n<ul>\n<li>process.env[AWS_SDK_LOAD_CONFIG] = 1</li>\n</ul>\n<ul>\n<li>import { mockAwsSdk } from ../../../test/mocks/aws</li>\n<li>jest.mock(aws-sdk, () => mockAwsSdk)</li>\n</ul>\n<p><a name=zrHYi></a></p>\n<h2>ADFS？</h2>\n<p>如果你的 AWS 登录采用了 adfs，那么推荐使用 <a href=\"https://github.com/Jeff-Tian/aws-adfs-auth\">https://github.com/Jeff-Tian/aws-adfs-auth</a> ，让你可以在命令行里直接登录 AWS。详见使用教程见其 README。</p>\n<p><a name=sESMt></a></p>\n<h2>使用基于 DynamoDb 的幂等存储</h2>\n<p>到了这一步，我们已经走了很远。现在回头来解决最初的问题。在简要分析与修复想法中，我们希望只通过添加一个幂等修饰符，不改其他代码，就修复掉重复发消息的问题。于是最终的代码改动如下：\ndiff</p>\n<ul>\n<li>@idempotent((post) => post.postId, new DynamodbIdempotentStorage())</li>\n</ul>\n<p>public async handlePost(post: PostRecord): Promise<boolean> {</p>\n<p>上线后，再也没有出现用户收到重复消息的问题了。\n<a name=prdas></a></p>\n<h1>思考与总结</h1>\n<p><a name=nmdgJ></a></p>\n<h2>为什么没有使用 memoize 模式？</h2>\n<p>memoize 是我很喜欢的一个模式，它不仅也让不纯的函数变得纯洁，而且实现起来非常简洁。在之前的文章中我一再提到它：</p>\n<ul>\n<li>闭包的妙用 —— memoize - Jeff Tian的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/353365352\">https://zhuanlan.zhihu.com/p/353365352</a></li>\n<li>闭包的妙用，再次以 memoize 举例 - Jeff Tian的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/439222057\">https://zhuanlan.zhihu.com/p/439222057</a></li>\n<li>屡试不爽的 memoize - Jeff Tian的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/553902109\">https://zhuanlan.zhihu.com/p/553902109</a></li>\n</ul>\n<p>但是这次没有采用，因为它也是利用内存做为缓存，更适合只有一个实例的场景，比如用在前端就很好。但是基于要用到数据库的原因，就没有采用它。</p>\n<p><a name=cNy9g></a></p>\n<h2>发布 npm 包</h2>\n<p>如果后面再发现其它项目中也需要用它，或者本文点赞数过千，那说明这个装饰器很有复用价值，到那时再发布成一个 npm 包。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[],"slicesMap":{}}