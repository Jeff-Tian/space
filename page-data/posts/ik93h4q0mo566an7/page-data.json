{"componentChunkName":"component---src-templates-post-js","path":"/posts/ik93h4q0mo566an7/","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/ik93h4q0mo566an7","relativePath":"posts/ik93h4q0mo566an7","frontmatter":{"title":"使用 vuex-oidc 在 Vue 项目中对接 Duende IdentityServer","stackbit_url_path":"posts/ik93h4q0mo566an7","date":"2023-03-14T11:29:41","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=k6NJe></a></p>\n<h1>前情提要</h1>\n<p>上次，在《<a href=\"https://zhuanlan.zhihu.com/p/591563537\">使用 IdentityServer 保护 Vue 前端 - Jeff Tian的文章 - 知乎 </a> 》中记录了直接在 Vue 项目里，不使用任何状态管理包，直接使用 oidc-client js 来对接 Duende IdentityServer，并且使用了 OAuth 2.0 的隐式许可模式。<br />今天，继续记录一下在 Vue 项目中对接 Duende IdentityServer （或者任何的其他的 OAuth 2.0 服务器。这次，我们使用 vuex 状态管理包，以及对应的 vuex-oidc 来对接 Duende IdentityServer，并且尝试一下 OAuth 2.0 的授权码许可模式。</p>\n<p><a name=eECRp></a></p>\n<h1>警告⚠️</h1>\n<p>相比隐式许可，授权码许可在流程上更加安全。但前提是使用 BFF （《<a href=\"https://zhuanlan.zhihu.com/p/571585321\">BFF 进化 - Jeff Tian的文章 - 知乎 </a> 》） 来与授权服务器进行授权码许可模式的对接。只有这样，才能充分享受到授权码许可模式带来的更高安全性。然而，本文并不讨论 BFF 对接方案，而是从前端直接和 Duende IdentityServer 进行授权码许可的对接。尽管这是完全可行的，但由于这样做，事实上会暴露 client id 和 client secret，所以说，这样做后的效果并不能让该方案比隐式许可更安全。</p>\n<p><a name=I0TUC></a></p>\n<h1>步骤 0: 授权服务器端的配置工作</h1>\n<p>首先，需要在 Duende IdentityServer 中为该 Vue 项目配置好客户端。需要注意的是，<strong>不能</strong>直接复用在《<a href=\"https://zhuanlan.zhihu.com/p/591563537\">使用 IdentityServer 保护 Vue 前端 - Jeff Tian的文章 - 知乎 </a> 》中使用的那个客户端。那个客户端已经配置了隐式许可。<br />尽管在授权服务器端可以直接为客户端添加一个授权码许可，并保存成功，然而，在实际对接过程中会碰到麻烦，即在从前端页面跳转到 Duende IdentityServer 页面后，会得到一个 invalid request 页面。<br />所以，需要为这个 Vue 项目专门配置一个使用授权码许可模式的客户端。</p>\n<p><a name=hQEya></a></p>\n<h1>步骤 1: Vue 项目添加相关的依赖</h1>\n<p>这一次，我们不直接使用 oidc-client js，而是使用 oidc-client-ts 这个使用 TypeScript 的包，并且引入 vuex 和 vuex-oidc：\njson\noidc-client-ts: ^2.0.6,\nvuex: ^3.0.1,\nvuex-oidc: ^4.0.0</p>\n<p><a name=FS0qc></a></p>\n<h1>步骤 2: 为 Vue 项目添加多环境支持</h1>\n<p>如果有多个对接环境，可以再引入 dotenv，并且在项目中可以添加多个不同的 .env 文件。比如用 .env.local 和 .env.live 来分别存储本地和线上环境的配置，那么，可以同步为这两个环境准备两套不同的启动命令，用来加载对应的配置：\njson\nserve:local: dotenv -e .env.local vue-cli-service serve,\nserve:live: dotenv -e .env.live vue-cli-service serve,</p>\n<p><a name=QmpoV></a></p>\n<h1>步骤 3: 配置 OIDC 信息</h1>\n<p>以 env.local 为例：\njson\nVUE_APP_BASE_API=<a href=\"http://localhost:3000\">http://localhost:3000</a>\nVUE_APP_OIDC_CONFIG={accessTokenExpiringNotificationTime:30,authority:<a href=\"https://id6.azurewebsites.net/,clientId:xxx,clientSecret\">https://id6.azurewebsites.net/,clientId:xxx,clientSecret</a>: yyy, redirectUri:<a href=\"http://localhost:3000/oidc-callback,responseType:code\">http://localhost:3000/oidc-callback,responseType:code</a>, scope:openid email profile,automaticSilentRenew:true,automaticSilentSignin:false,silentRedirectUri:<a href=\"http://localhost:3000/silent-renew-oidc.html%7D\">http://localhost:3000/silent-renew-oidc.html}</a></p>\n<p>为了从项目中读取配置好的 OIDC 信息，添加一个 src/oidc/oidc_config.js文件：\njavascript\nexport const oidcSettings = JSON.parse(process.env.VUE_APP_OIDC_CONFIG)</p>\n<p><a name=EL5Cz></a></p>\n<h1>步骤 4: 添加 silent renew 页面</h1>\n<p>前文《<a href=\"https://zhuanlan.zhihu.com/p/591563537\">使用 IdentityServer 保护 Vue 前端 - Jeff Tian的文章 - 知乎 </a> 》中使用了拷贝 oidc-client js 的方式，这一次我们不用这么做了。添加一个 src/oidc/silent-renew.js 文件：\njavascript\nimport core-js/fn/promise\nimport { vuexOidcProcessSilentSignInCallback } from vuex-oidc</p>\n<p>import { oidcSettings } from ./oidc_config</p>\n<p>vuexOidcProcessSilentSignInCallback(oidcSettings)</p>\n<p><a name=XOaif></a></p>\n<h1>步骤 5: main.js、App.vue 等文件的改造</h1>\n<p>上一次，我们没有使用状态管理工具，于是引入了一个 security js，并且通过 globalMethods 的方式注入了 OIDC 相关的方法，这一次，不再需要 security js，在实例化 Vue 时，也不再传递 data 和 methods，而是传递 store（因为用了 vuex 状态管理工具）：\njavascript\n...\nimport App from ./App.vue\nimport store from ./oidc/store\nimport router from @/router;</p>\n<p>new Vue({\nrouter,\nstore,\nrender: h => h(App)\n}).$mount(#app);</p>\n<p>其中，src/oidc/store.js文件如下：\njavascript\nimport Vue from vue\nimport Vuex from vuex\nimport { vuexOidcCreateStoreModule } from vuex-oidc\nimport { oidcSettings } from ./oidc_config</p>\n<p>Vue.use(Vuex)</p>\n<p>export default new Vuex.Store({\nmodules: {\noidcStore: vuexOidcCreateStoreModule(\noidcSettings,\n{\nnamespaced: true,\ndispatchEventsOnWindow: true\n},\n// Optional OIDC event listeners\n{\nuserLoaded: (user) => console.log(OIDC user is loaded:, user),\nuserUnloaded: () => console.log(OIDC user is unloaded),\naccessTokenExpiring: () => console.log(Access token will expire),\naccessTokenExpired: () => console.log(Access token did expire),\nsilentRenewError: () => console.log(OIDC user is unloaded),\nuserSignedOut: () => console.log(OIDC user is signed out),\noidcError: (payload) => console.log(OIDC error, payload),\nautomaticSilentRenewError: (payload) => console.log(OIDC automaticSilentRenewError, payload)\n}\n)\n}\n})</p>\n<p>这一次，我们使用了 vuex 做状态管理，在实例化 Vue 时，可以将 oidc 相关的方法直接映射过去（src/App.vue）：\njavascript\nimport {mapGetters} from vuex;</p>\n<p>export default {\nname: App,\ncomputed: {\n...mapGetters(oidcStore, [\noidcAccessToken,\noidcIsAuthenticated,\noidcAuthenticationIsChecked,\noidcUser,\noidcIdToken,\noidcIdTokenExp\n]),\nuserDisplay: function () {\nreturn this.oidcUser?.email ?? User\n}\n},\ncomponents: {\n},\ndata() {\n...</p>\n<p><a name=A8FqM></a></p>\n<h1>步骤 6: 改造 router</h1>\n<p>上一次，我们给私有路由添加了 meta 属性，并用 requiresAuth 来标记需要登录。这一次，我们使用 vuex-oidc 提供的 vuexOidcCreateRouterMiddleware 来达到同样的效果。src/router/index.js：\njavascript\nimport Vue from vue\nimport OidcCallback from @/views/OidcCallback.vue;\nimport Router from vue-router;\nimport {vuexOidcCreateRouterMiddleware} from vuex-oidc;\nimport store from @/oidc/store;</p>\n<p>Vue.use(Router)\nonst router = new Router({\nmode: history,\nbase: /ars-notification-dashboard,\nroutes:  [\n{\npath: /,\n},\n{\npath: /private,\nname: private page,\ncomponent: resolve => require([@/pages/private.vue], resolve)\n},\n{\npath: /oidc-callback,\nname: oidcCallback,\ncomponent: OidcCallback,\nmeta: {\nisPublic: true\n}\n}\n]\n});</p>\n<p>router.beforeEach(vuexOidcCreateRouterMiddleware(store, oidcStore))\nexport default router;</p>\n<p>注意，这一次我们首先假定所有页面都需要登录，而对于登录回调页面，通过 meta 中的 isPublic 来标记允许匿名访问。对于登录回调页面，其代码如下。src/views/OidcCallback.vue：\njavascript\n<template></p>\n  <div>\n  </div>\n</template>\n<script>\nimport { mapActions } from vuex\n\nexport default {\n  name: OidcCallback,\n  methods: {\n    ...mapActions(oidcStore, [\n      oidcSignInCallback\n    ])\n  },\n  created () {\n    this.oidcSignInCallback()\n      .then((redirectPath) => {\n        this.$router.push(redirectPath)\n      })\n      .catch((err) => {\n        console.error(err)\n        this.$router.push(/signin-oidc-error) // Handle errors any way you want\n      })\n  }\n}\n</script>\n<p><a name=GVZLx></a></p>\n<h1>步骤 7: 给 API 请求添加认证头</h1>\n<p>这一步其实是与前文《<a href=\"https://zhuanlan.zhihu.com/p/591563537\">使用 IdentityServer 保护 Vue 前端 - Jeff Tian的文章 - 知乎 </a> 》一致的，只是取 token 的写法略有调整。src/api/request.js：\njavascript\nimport store from @/oidc/store</p>\n<p>service.interceptors.request.use(config => {\nconst accessToken = store.state.oidcStore.access_token\nif(accessToken){\nconfig.headers.Authorization = Bearer ${accessToken};\n}\nreturn config\n})</p>\n<p>通过依赖 store，而不再需要实例化一个 Vue，并读取其 $root.user。</p>\n<p><a name=LliGl></a></p>\n<h1>完成</h1>\n<p>大功告成！</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[],"slicesMap":{}}