{"componentChunkName":"component---src-templates-post-js","path":"/posts/gx48bf","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/gx48bf","relativePath":"posts/gx48bf","frontmatter":{"title":"后端工程圣殿形象的崩塌以及重建","stackbit_url_path":"posts/gx48bf","date":"2021-05-31T12:39:17","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>作为一个前端，似乎一直有点抬不起头。总是在圈子里被鄙视，什么：前端也是程序员？什么：JavaScript 工程太乱等等等等。我一直对后端工程心存敬畏，总之后端在我眼中一直是高大上的形象，但是最近我近距离深入接触了某公司的后端 Java 工程，三观彻底被毁了：一直鄙视我们前端的后端工程师们，搭出来的后端工程就这？心中一万匹马奔腾而过。在我原来的观念里，<strong>后端工程一直就像是圣殿般的存在，如今真正一看，却如同废墟。</strong></p>\n<p>自己一直想往全栈方向发展，于是决定在废墟中重建，虽然不能立即达到圣殿的级别，但是力求达到常见的前端工程水准。</p>\n<p><a name=dSVNE></a></p>\n<h2>缘起</h2>\n<p>后端接口一直调不通，后端同学总是说他那里是好的。我说开发环境调不通，他发来一堆 SQL 给我：你得在本地环境建数据呀。为了节省时间，我干脆在本地克隆了后端工程，开始近距离接触。一看，三观尽毁：</p>\n<p><a name=otbN7></a></p>\n<h2>项目不能在本地一键启动</h2>\n<p>我接触过的所有前端项目，都会有一个 README，写清楚如何本地运行，尽管都是差不多的，尽管很简单，但都会注明。一般都会支持 yarn dev 或者 yarn start 等等一键运行命令。但是我打开的 java 工程，什么都没有。当然，能看出是基于 SpringBoot 的一个 maven 工程，于是 Googl 了一下 maven 工程的启动方式，试了一下 mvn bootRun 果然是各种报错。</p>\n<p><a name=OYMB4></a></p>\n<h3>重建方案</h3>\n<p>于是我通过各种错误提示，了解到了项目的依赖：mysql、redis 等等，就补充了一个 docker-compose.yaml 文件，在执行 mvn bootRun 之前，docker-compose up -d 一下，启动相关的依赖项。当然没有那么顺利，仍然有很多错误，详细的就不说了，心里窝火。最后的解决办法：</p>\n<ul>\n<li><strong>写一个初始数据库的脚本，并配置在 <strong><strong>docker-compose.yaml</strong></strong> 文件中，使得在 <strong><strong>docker-compose up -d</strong></strong> 时自动创建好需要的数据库<br />init.sql</strong></li>\n</ul>\n<p>sql\nCREATE DATABASE IF NOT EXISTS dbname;\nUSE dbname;</p>\n<p><strong>docker-compose.yaml</strong>\nyaml\nversion: 3.3\nservices:\nadminer:\nimage: adminer:4.8.0\nrestart: always\nports:\n- 7777:8080\ndb:\nimage: mysql:5.7\nrestart: always\nenvironment:\nMYSQL_DATABASE: dbname\nMYSQL_USER: root\nMYSQL_ROOT_PASSWORD: password\nports:\n- 3306:3306\ncommand: --init-file /data/application/init.sql\nexpose:\n- 3306\nvolumes:\n- my-db:/var/lib/mysql\n- ./init.sql:/data/application/init.sql\nredis:\nimage: redis\ncommand: redis-server --requirepass 123456\nrestart: always\nports:\n- 6379:6379</p>\n<h1>Names our volume</h1>\n<p>volumes:\nmy-db:</p>\n<ul>\n<li><strong>新建一个 local profile 文件，并配置好相关的本地环境变量</strong>\n<ul>\n<li>对于本地数据库连接配置，新建src/main/resources/db/datasource-local.yml文件，配置如下：</li>\n</ul>\n</li>\n</ul>\n<p>yaml\nspring:\ndatasource:\ndriver-class-name: com.mysql.cj.jdbc.Driver\nhikari:\nmax-lifetime: 1800000\nmaximum-pool-size: 10\ntype: com.zaxxer.hikari.HikariDataSource\nurl: jdbc:mysql://localhost:3306/dbname?useUnicode=true&#x26;rewriteBatchedStatements=true&#x26;autoReconnect=true&#x26;failOverReadOnly=false&#x26;characterEncoding=UTF-8&#x26;useSSL=false&#x26;allowPublicKeyRetrieval=true&#x26;serverTimezone=Asia/Shanghai\nusername: root\npassword: password</p>\n<ul>\n<li>对于本地 Redis 配置，新建 src/main/resources/redis/redis-local.yml 文件，配置如下：</li>\n</ul>\n<p>yaml\nspring:\nredis:\nhost: localhost\nlettuce:\npool:\nmax-active: 100\nmax-idle: 100\nmax-wait: 6000\nmin-idle: 50\nlock:\nhost: localhost\npassword: 123456\nport: 6379\npassword: 123456\nport: 6379\ntimeout: 5000</p>\n<ul>\n<li>在 pom.xml 里新增一个 local profile：</li>\n</ul>\n<p>xml\n...\n<profiles>\n<profile>\n<id>local</id>\n<properties>\n&#x3C;package.environment>local&#x3C;/package.environment>\n</properties>\n<activation>\n<activeByDefault>true</activeByDefault>\n</activation>\n</profile>\n...\n</profiles>\n...</p>\n<ul>\n<li>增加 application-local.properties 文件：</li>\n</ul>\n<p>xml\nenv=local\nserver.port=8080\nserver.http2.enabled=true</p>\n<ul>\n<li><strong>新建一个 start.sh 文件，无非就是启动相关依赖，再利用 <strong><strong>mvn bootRun</strong></strong> 启动项目。总之封装成一个脚本文件，方便后续本地一键启动项目。</strong></li>\n</ul>\n<p>shell\nmvn clean install\ndocker-compose up -d\nmvn bootRun</p>\n<p><a name=iLAx9></a></p>\n<h2>完全没有任何测试代码</h2>\n<p>这真是日了狗了。</p>\n<p>我所见过的前端工程，测试占比并不多，由于前端 UI 测试代价比较大，变化多，所以很少会去写详细的自动化测试，但是会做好 file watch，一旦代码变化，界面也随之更新，所以也还好。但是对于公共逻辑，或者重要的组件，一般都是一个实现文件对应着一个测试文件，每个文件用来干什么，只要看下对应的测试文件就一目了然：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622355446000-5eae8033-c041-4f6e-88f4-2f5af0b512ea.png#clientId=u8d7fa753-272e-4&#x26;from=paste&#x26;height=248&#x26;id=u4e0a0f95&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=465&#x26;originWidth=815&#x26;originalType=binary&#x26;size=43855&#x26;status=done&#x26;style=none&#x26;taskId=u10f26eb2-5a99-457b-924d-3f3e99dc526&#x26;width=434.66668701171875\" alt=\"image.png\"><br />但是我打开的 java 工程，看似很专业，分层分得很细，遵照了《领域驱动设计》的层次结构：<img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622355968608-bb1ef753-8d79-4305-9dcc-07b4c5bc40fe.png#clientId=u8d7fa753-272e-4&#x26;from=paste&#x26;height=873&#x26;id=ua4186f0b&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=2620&#x26;originWidth=2970&#x26;originalType=binary&#x26;size=541444&#x26;status=done&#x26;style=none&#x26;taskId=ua2bd916b-7dac-428c-bf19-f678ea3ed07&#x26;width=990\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622356121139-ad443f97-c81b-475d-9194-cd727b61ae89.png#clientId=u8d7fa753-272e-4&#x26;from=paste&#x26;height=322&#x26;id=ub9ac226d&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=656&#x26;originWidth=1007&#x26;originalType=binary&#x26;size=98138&#x26;status=done&#x26;style=none&#x26;taskId=u6c8fa508-b761-4859-95b9-e21d1c7c8de&#x26;width=493.66668701171875\" alt=\"image.png\"><br />但是《领域驱动设计》中引入这个分层架构是为了方便自动化测试，并且让程序本身更加简单明了。显然这个项目工程，只是生硬照搬了分层结构，并没有实现《领域驱动设计》中引入这个结构的目的。</p>\n<p><a name=UZ9Xa></a></p>\n<h3>部分重建方案</h3>\n<p>对于新加的代码，必须添加测试。这对我来说很艰难，不太会用 java 写测试，但最终把测试加入了，每次把改动推到远程仓库前，会自动运行项目中的测试。对于这个我还没有形成一个通用的方案，只能记录一些零碎的新得。</p>\n<p><strong>@MockBean 可以解决测试实例的替换</strong><br />对于一些依赖，在运行测试时需要控制住，这时候可以采用 @MockBean 将实际依赖替换成一个假的对象实例。前提是实现代码做到了依赖一个抽象，而不是具体的实例。</p>\n<p><strong>对于没有依赖接口，而是依赖特定实例实现的代码，可以增加一些 setter 以方便测试</strong><br />比如这样的代码：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622356992948-d3be2176-5030-4b95-814b-b4fd63f709fc.png#clientId=u8d7fa753-272e-4&#x26;from=paste&#x26;height=298&#x26;id=uc006b883&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=298&#x26;originWidth=508&#x26;originalType=binary&#x26;size=117006&#x26;status=done&#x26;style=none&#x26;taskId=u24d7f28b-13ea-4312-81fc-057dc21c97d&#x26;width=508\" alt=\"image.png\"><br />显然它对 HttpClient 的依赖没有使用依赖注入。应该有办法改造一下，但我还不会，于是给这个类增加了一个 setter 方法：\njava\npublic void setHttpClient(HttpClient client) {\nthis.httpClient = client;\n}</p>\n<p>然后在测试代码中，通过 @BeforeEach 对其内部 httpClient 进行替换：\njava\n@BeforeEach\nvoid initialize() {\nmpService.setHttpClient(new MockHttpClient());\n}</p>\n<p>当然，还可以在测试中不更改 HttpClient，而是更改对应的 HttpClient 要调用的远程端点，使用 MockServer 的方式，防止在测试中调用真正的远程端点。\njava\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.None)\npublic class XXXTest {\npublic static MockWebServer mockBackEnd;</p>\n<pre><code>@BeforeAll\nstatic void setUp() throws IOException {\n    mockBackEnd = new MockWebServer();\n    mockBackEnd.start();\n}\n\n@AfterAll\nstatic void tearDown() throws IOException {\n    mockBackEnd.shutdown();\n}\n\n@BeforeEach\nvoid initialize() {\n    String baseUrl = String.format(http://localhost:%s,\n            mockBackEnd.getPort());\n\n    mpService.setQrCodeCreateUrl(baseUrl + /test);\n}\n\n@Autowired\nprivate MpService mpService;\n\n@Test\nvoid XXXTest() {\n    MockResponse mockResponse = new MockResponse();\n    mockResponse.setBody({ticket:gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmmn +\n            3sUw==,expire_seconds:60,url:http://weixin.qq.com/q/kZgfwMTm72WWPkovabbI});\n    mockResponse.addHeader(Content-Type, application/json);\n\n    mockBackEnd.enqueue(mockResponse);\n    ...\n    assertThat(...);\n}\n</code></pre>\n<p><strong>总之，不要让测试产生真正的远程调用，要么 mock 自己使用的 HttpClient，对 sendRequest 方法进行打桩；要么 mock 这个远程 server，固定返回期待的 Response。</strong></p>\n<p><a name=GXnRN></a></p>\n<h2>设计瑕疵</h2>\n<p>后端系统中所有的日期字段类型，全部设置成为了 Long 型，存储一个时间的秒数。这个让我非常不解，问下来的原因是时间的时区会带来问题……</p>\n<p>我想不出日期时间格式会带来什么时区问题，就算有，采用 UTC 时间会怎样呢？总之目前的设计，导致编码不便，数据库查询不便，以及造测试数据时非常不方便（比如 Adminer 界面不会弹出日期时间选择框，而是一个数字输入框……）。</p>\n<p>更加讽刺的是，这个设计号称能避免时区问题，结果偏偏带来了不应该有的时区问题：比如，我在调用后端接口创建某些资源时，由于业务逻辑限制开始时间和结束时间必须在同一天，我的前端明明传了同一天的时间给到后端，但后端就是一直报开始时间和结束时间不在同一天的错误！<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622357986780-0d090bf0-c2fd-4589-b79a-bc9309e88163.png#clientId=u8d7fa753-272e-4&#x26;from=paste&#x26;height=467&#x26;id=u5ab044be&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=467&#x26;originWidth=546&#x26;originalType=binary&#x26;size=31620&#x26;status=done&#x26;style=none&#x26;taskId=ue59dc185-cc52-427d-bfce-3d9beaf88df&#x26;width=546\" alt=\"image.png\"><br />最后查看后端代码，是这样写的：\njava\nLocalDate eventStartDate = eventStartTime == null ? null : Instant.ofEpochSecond(eventStartTime).atZone(ZoneId.systemDefault()).toLocalDate();\nLocalDate eventEndDate = eventEndTime == null ? null : Instant.ofEpochSecond(eventEndTime).atZone(ZoneId.systemDefault()).toLocalDate();</p>\n<p>显然当前的 BUG 证明了系统的默认时区和用户真正使用的时区并不相同。为什么我倾向于直接采用日期时间类型，是因为日期时间类型在序列化时可以带上时区信息，比如 2021-05-31 00:00:00+8 代表了在东八区下 5 月 31 日的最开始时刻，但是它在 UTC 时间下，就是 5 月 30 日。</p>\n<p><a name=V2J7h></a></p>\n<h3>暂时的解决方案</h3>\n<p>由于直接将整个系统的时间设计从长整型改成日期时间型，工作量较大，我只能先修复了这个问题。修复可以通过把服务器的时区设置改成和用户的时区（东八区）相同，但是由于服务器的配置并没有代码话，我没有采用修改服务器设置。理想情况是一切基础设施也代码化，将一切系统知识采用文本记录并由 git 跟踪。</p>\n<p>由于现在增加时区信息让前端传递不太合适（而且后期如果改成日期时间格式，并不需要前端单独传递时区信息），以及考虑到产品只面向中国用户，因此暂时在代码中将时区从默认改成了东八区, 不过，任何代码的改动，都添加了测试代码，以保证重构的安全。\ndiff</p>\n<ul>\n<li>\n<pre><code>       LocalDate eventStartDate = eventStartTime == null ? null : Instant.ofEpochSecond(eventStartTime).atZone(ZoneId.systemDefault()).toLocalDate();\n</code></pre>\n</li>\n<li>\n<pre><code>       LocalDate eventEndDate = eventEndTime == null ? null : Instant.ofEpochSecond(eventEndTime).atZone(ZoneId.systemDefault()).toLocalDate();\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>\n<pre><code>       LocalDate eventStartDate = eventStartTime == null ? null : Instant.ofEpochSecond(eventStartTime).atZone(ZoneId.of(Asia/Shanghai)).toLocalDate();\n</code></pre>\n</li>\n<li>\n<pre><code>       LocalDate eventEndDate = eventEndTime == null ? null : Instant.ofEpochSecond(eventEndTime).atZone(ZoneId.of(Asia/Shanghai)).toLocalDate();\n  \t\t\t\tif (eventEndDate != null &#x26;&#x26; eventStartDate != null &#x26;&#x26; !eventStartDate.equals(eventEndDate)) {\n          return 场次开始时间和结束时间需要在同一天！;\n      }\n</code></pre>\n</li>\n</ul>\n<p>java\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;</p>\n<p>import java.time.ZoneId;\nimport java.util.TimeZone;</p>\n<p>import static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.*;</p>\n<p>class CampaignEventValidationUseCaseImplTest {\nprivate CampaignEventValidationUseCaseImpl sut;</p>\n<pre><code>@BeforeEach\nvoid setUp() {\n    sut = new CampaignEventValidationUseCaseImpl();\n}\n\n/**\n * BUG：开始时间选择 2021-05-20 00:05，结束时间选择 2021-05-20 23:55，校验报错说：场次开始时间和结束时间需要在同一天\n */\n@Test\nvoid validate场次开始时间和结束时间需要在同一天() {\n    TimeZone.setDefault(TimeZone.getTimeZone(Europe/Kiev)); // 模拟服务器时区没有设置在东八区\n    \n    sut = new CampaignEventValidationUseCaseImpl();\n\n    EventTime4Check event = new EventTime4Check();\n    event.setEventEndTime(1621526100L);\n    event.setEventStartTime(1621440300L);\n\n    CampaignDto campaignDto = new CampaignDto();\n    campaignDto.setCampaignId(12345);\n    campaignDto.setStartTime(1621483200L);\n    campaignDto.setEndTime(1622188000L);\n\n    assertNotNull(sut);\n\n    assertThat(sut.validate(event, campaignDto)).isNotEqualTo(场次开始时间和结束时间需要在同一天！);\n}\n</code></pre>\n<p>}</p>\n<p><a name=kEl0O></a></p>\n<h2></h2>\n<p><a name=Ieq6s></a></p>\n<h2>长篇没有测试又满是 BUG 的函数</h2>\n<p>这个工程里充斥着长篇函数，状态变量特别多，而且往往在函数开头就定义一堆。如前所述，有没有测试，而且实际联调下来又有 BUG。</p>\n<p><a name=uHKmB></a></p>\n<h3>部分重建方案</h3>\n<p><a name=XimNW></a></p>\n<h4>内联只被用到一次的变量，对于被引用多次的变量，将其定义挪到第一次引用之前；</h4>\n<p><a name=Rdb5U></a></p>\n<h4>对于已知有 BUG 的分支，使用提前退出，并在单独的小函数中进行自动化测试并修复：</h4>\n<p>java\n@Override\npublic Boolean queryCampaignHasReservableEvent(String campaignId, CampaignType campaignType) throws Exception {\n// 新增代码\nif (campaignType == CampaignType.CAMPAIGN) {\n// 联调发现这个分支有 BUG，提前返回新的函数，并对其进行充分的自动化测试\nreturn queryCampaignHasReservableEventForCampaign(campaignId);\n}</p>\n<pre><code>    // 原有代码\n    EventQueryCondition queryCondition = new EventQueryCondition();\n    queryCondition.setCampaignId(campaignId);\n    // 此处省略原有的几十行漏洞代码\n    ...\n    PageInfo&#x3C;EventDto> pageInfo = getOnlyEvents(queryCondition);\n    return pageInfo.getTotal() != 0;\n}\n</code></pre>\n<p><a name=hnyrc></a></p>\n<h2>其他重复代码等等问题</h2>\n<p>项目中居然有很多整段整段的代码重复，以及格式不规整的问题，这些问题都可以被自动扫描出来，于是搭建一个 SonarQube，以方便快速定位这些问题（扫描结果不堪入目🙈，这还只是新建没多久的项目啊……）：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622464119723-b9350125-e10e-4be6-b175-4033e9f59c1f.png#clientId=u8d50202b-7c2c-4&#x26;from=paste&#x26;height=1117&#x26;id=udc24a279&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1117&#x26;originWidth=1293&#x26;originalType=binary&#x26;size=137528&#x26;status=done&#x26;style=none&#x26;taskId=u4105fe18-ae93-4986-9f43-285055e99c7&#x26;width=1293\" alt=\"image.png\"><br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1622464170293-832de223-f13d-451a-84d1-b621b8d737e3.png#clientId=u8d50202b-7c2c-4&#x26;from=paste&#x26;height=664&#x26;id=u2f803133&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=664&#x26;originWidth=846&#x26;originalType=binary&#x26;size=40661&#x26;status=done&#x26;style=none&#x26;taskId=ub7769d2e-84a5-4c6d-9fc4-c7ddf4abf39&#x26;width=846\" alt=\"image.png\"></p>\n<p>可以看出，重建很艰难，也是个长期工程，今天就记录到这里。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"Full Stack Developer, good at OAuth 2.0","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}