{"componentChunkName":"component---src-templates-post-js","path":"/posts/fxnsuw","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/fxnsuw","relativePath":"posts/fxnsuw","frontmatter":{"title":"屡试不爽的 memoize","stackbit_url_path":"posts/fxnsuw","date":"2022-08-15T03:48:04","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>为什么今天突然又想起它？因为公众号一篇冷门文章收到了评论，又激发了我对于它的热情：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/353365352\">https://zhuanlan.zhihu.com/p/353365352</a></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1660531559139-b8c1b809-1374-4786-80c9-3c71e0754b88.png#clientId=u1fdd0636-3fe6-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=1040&#x26;id=u2d9502d7&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=2079&#x26;originWidth=960&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=607380&#x26;status=done&#x26;style=none&#x26;taskId=u399448f7-6a07-41dd-b0fb-2f69210efb0&#x26;title=&#x26;width=480\" alt=\"image.png\"></p>\n<p><a name=FkEAd></a></p>\n<h1>服务器端的 memoize 故事</h1>\n<p>好几年前，学习了 memoize 这个函数，并且在实现工作中应用了它，起到了很好的效果。具体来说，是在一个 nodejs 服务器端，有一些操作特别耗时（有一些复杂的上下文，总之，不应该有这种耗时操作，但是已经难以优化），于是通过 memoize 包装了这个耗时的操作，在多次调用中，仅第一次比较耗时，后续的调用就是秒返回。</p>\n<p>当然，除了使用了它，你也可以使用静态变量来存储第一次执行的结果，然后在调用中对这个变量判空即可。但是这样涉及到的代码改动比较多，远不如添加一个 memoize 来得优雅。通过使用 memoize，不用修改原有代码逻辑流，只是通过新增代码改变了系统的行为，符合开闭原则。</p>\n<p>当时是在一个国际化团队中（某知名跨国品牌），这个提交其实改动很小，不过增加了好几个测试用例以证明它能工作。在提交后，很快被纳入主干，并顺利上线。后来我离职了，不清楚后面的情况，如果没有太大的变化，它已经在分布于全世界的服务器中运行了快三年了。在离职前夕，我总结自己的工作，发现对 memoize 的运用效果非常好，还可以说明一下闭包的妙用，所以写了那篇专栏。</p>\n<p><a name=e8b6g></a></p>\n<h1>前端的 memoize 故事</h1>\n<p>有意思的是，我加入到一个新团队后，立即又把这个 memoize 模式，在前端又应用了一次，同样起到了非常好的效果。目前运行在前端上，也有快一年的时间了，由于这次没有离职，所以很确定地知道，这段 memoize 代码日均运行了 8 万多次。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1660536787939-ca6e8134-83ec-44f8-9a47-a1af9adb93fe.png#clientId=u7794d33a-1294-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=425&#x26;id=u5c4db687&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=850&#x26;originWidth=1364&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=103898&#x26;status=done&#x26;style=none&#x26;taskId=u7f273d8f-2d8c-4059-a819-ce9728a3882&#x26;title=&#x26;width=682\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1660532856622-cdede6a7-74aa-45ae-93bb-bfd1e68c46b6.png#clientId=u1fdd0636-3fe6-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=502&#x26;id=ua5af1573&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1004&#x26;originWidth=2348&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=162523&#x26;status=done&#x26;style=none&#x26;taskId=ubf3a1e9f-2c90-4d86-b31c-ac498163c71&#x26;title=&#x26;width=1174\" alt=\"image.png\"></p>\n<p>这个故事起源于前端页面体验较差，在分析过程中，发现会重复性地调用某些接口（短时间发出多个同样的接口请求，第一个请求的响应回来之前，又发出了同样的请求），比如其中一个是使用 code 换取微信 session，并再次使用微信的 sessionKey 换取自己服务器端的令牌。在拿到这个令牌前，页面一直牌加载中状态。总之，这是一个在此前端项目中被称为登录的动作，它的重复执行，是页面体验不佳的原因之一，至于为什么重复调用，原因又特别复杂。好在，使用 memoize 可以不去管这些繁杂的原因。</p>\n<p><a name=xxkQp></a></p>\n<h2>等等？为什么不用 mutex？</h2>\n<p>有同事提出 mutex 方案，大致是将 login 封装为：\njavascript\nconst loginx = (() => {\nlet mutex = false</p>\n<p>return () => {\nif (mutex) return\nmutex = true\nlogin().finally(() => mutex = false)\n}\n})()</p>\n<p>这个改动量虽然也不算大，但实际上还是破坏了某些场景。比如，第一个登录请求发出后，第二个登录请求会被强行中止，拿不到正常的结果（undefined），导致后续逻辑不可预测，风险较大。</p>\n<p><a name=dKvzF></a></p>\n<h2>memoizeAsync</h2>\n<p>这里的登录操作，实际上是一个异步函数，由于项目没有引入 lodash，所以手写了一个简化的 memoizeAsync 函数，虽然很简单，但是运行了快一年时间，没有出现故障。</p>\n<p><a name=IJn6x></a></p>\n<h3>测试先行</h3>\n<p>这个 memoizeAsync，其使用效果如以下测试代码所示。即在第一个调用 resolve 之前，如果又有同样的调用，不会发出 http 请求。\ntypescript</p>\n<p>describe(memoize, () => {\nit(executes only once before underlying promise gets done, async () => {\nconst originalExecute = jest.fn().mockImplementation(async () => {\nconsole.log(executing...)\n})\n// Given an async function memoized\nconst memoizedExecute = memoizeAsync(originalExecute)</p>\n<pre><code>  const sut = {\n    execute: memoizedExecute,\n  }\n\n  // When call it multiple times\n  await Promise.all([sut.execute(), sut.execute(), sut.execute()])\n\n  // Then the underlying method will be run only once\n  expect(originalExecute).toHaveBeenCalledTimes(1)\n\n  // Because now the sut.execute gets resolved, so new calls will trigger underlying method fire again\n  await sut.execute()\n  expect(originalExecute).toHaveBeenCalledTimes(2)\n})\n</code></pre>\n<p>})</p>\n<p><a name=CLZOL></a></p>\n<h3>简单的实现</h3>\n<p>实现到底多简单呢？其实就是用函数的参数作为缓存键，并且在 promise resolve 或者 reject 后都清空一下缓存即可：</p>\n<p>typescript</p>\n<p>export const memoizeAsync = <T>(func: (...args) => Promise<T>) => {\nconst cache = {}</p>\n<p>return async (...args) => {\nconst cacheKey = JSON.stringify(args)</p>\n<pre><code>if (cache[cacheKey] === undefined) {\n  cache[cacheKey] = func(...args).finally(() => (cache[cacheKey] = undefined))\n}\n\nreturn cache[cacheKey]\n</code></pre>\n<p>}\n}</p>\n<p><a name=ZSsqc></a></p>\n<h2>对 login 的改动</h2>\n<p><a name=wbL4c></a></p>\n<h3>测试先行</h3>\n<p>期待对登录的代码做完改动后，多个上层登录调用，只触发一次底层操作，并且本地会存储更新后的令牌信息：</p>\n<p>typescript</p>\n<p>describe(login, () => {\nbeforeEach(() => {\njest.clearAllMocks()\n})</p>\n<p>it(should login wechat once without duplicate requests, async () => {\nconst mockLoginResult = { jwt: 1234, sessionId: 5678 }</p>\n<pre><code>client.loginMutate.mockImplementation(async () => mockLoginResult)\n\nawait Promise.all([auth.handleLogin(), auth.handleLogin()])\n\nexpect(storageSync.getStorageSync(StorageSyncKeys.TOKEN)).toStrictEqual(mockLoginResult.jwt)\n\nexpect(client.loginMutate).toHaveBeenCalledTimes(1)\n</code></pre>\n<p>})\n})</p>\n<p><a name=BBn9A></a></p>\n<h3>实现的改动仅两行</h3>\n<p>即将原有 login 方法重命名为 loginWithNewCode，并新增一个 login 方法，是对 loginWithNewCode 的 memoize 调用：</p>\n<p>diff</p>\n<ul>\n<li>export const login = (): Promise<boolean> => {</li>\n</ul>\n<ul>\n<li>export const loginWithNewCode = (): Promise<boolean> => {</li>\n</ul>\n<p>...</p>\n<ul>\n<li>export const login = memoizeAsync(loginWithNewCode)</li>\n</ul>\n<p><a name=k56rY></a></p>\n<h1>后续</h1>\n<p>其实，页面体验不佳，原因是多方面的，但归根结底，就是做了大量不必要做的事情。用 memoize ，可以做一个兜底，确保重复的请求，只触发底层一次操作。但这种不必要做的事情，从代码层面就应该删除。</p>\n<p>下次分享一个实战案例，仅仅通过删除代码，就修复了问题，还提升了性能。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}