{"componentChunkName":"component---src-templates-post-js","path":"/posts/sgyok5","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/sgyok5","relativePath":"posts/sgyok5","frontmatter":{"title":"Free Arch: 使用 OAM 摆脱厂商锁定","stackbit_url_path":"posts/sgyok5","date":"2022-10-06T08:05:21","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=MBhP6></a></p>\n<h1>前言</h1>\n<p>如今是一个云计算与数字化如火如荼的时代，云计算与数字化相得益彰，几乎所有企业都要数字化，都要上云。然而，上云容易下云难、换云也难，企业都害怕在上云的同时，被云厂商给锁定。</p>\n<p>所谓厂商锁定，就是明知道有更适合自己的其他云产品，企业并不能自由使用，因为云迁移成本太高，以至于继续使用已经使用的云，哪怕不划算。其实，何止企业，个人也面临同样的问题。Free Arch 一直为个人开发者服务，提供免费架构、自由架构的具体实例，很早以前就提出了狡兔三窟的多云策略。个人也要使用多云策略，以免被厂商绑定，既不自由，也不免费（一旦习惯的云开始收费，只能被割韭菜）。</p>\n<p><a name=ctpmZ></a></p>\n<h1>Serverless 的多云策略</h1>\n<p>Free 不仅有自由和免费的意思，还有随意的意思。这也是 Free Arch 系列文章比较随意的原因，Free Arch 面向具体的实际问题而随意架构，虽然不系统，不全面，但是每一次都有一个可以运行的案例，非常具体和实在。在进入今天的正题前，先总结（列举）一下以前的 Serverless 系列文章：\n<a name=UvFvj></a></p>\n<h2>薅 AWS Lambda 羊毛</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/412196725\">一顿操作猛如虎，部署一个万能 BFF</a>\n<a name=idG6Z></a></p>\n<h2>薅 Azure 羊毛</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/482103322\">身份验证哪家强？IdentityServer 初体验</a>\n<a name=ZpUjJ></a></p>\n<h2>薅 Heroku 羊毛</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/554534245\">FreeArch: 一键拥有你自己的身份认证平台 Keycloak，完全免费</a>\n<a name=CHnF8></a></p>\n<h2>薅 Vercel 羊毛</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/542130945\">Free Arch：将 Koa 服务部署到 Vercel</a></p>\n<p><a name=sEm1g></a></p>\n<h1>今天的正题：在多个 Kubernetes 集群间自由免费地切换</h1>\n<p>今天再聊一下个人开发者如何通过使用 OAM（开放应用模型），实现将应用自由免费地在各个 Kubernetes 集群之间迁移。这个例子的源代码是： <a href=\"https://github.com/Jeff-Tian/uni-orders\">https://github.com/Jeff-Tian/uni-orders</a>，它是一个使用 NestJs 开发的一个微服务，其  Swagger API 见： <a href=\"https://uni-orders-cctsq03nniljeo1bj0ng.apps.playground.napptive.dev/api/static/index.html\">https://uni-orders-cctsq03nniljeo1bj0ng.apps.playground.napptive.dev/api/static/index.html</a>。</p>\n<p>它已经完成了容器化，并随时可以部署在一个 Kubernetest 集群中。要部署，只需要执行 kubectl apply -k k8s即可，使用了 Kustomization，其定义在 <a href=\"https://github.com/Jeff-Tian/uni-orders/blob/main/k8s/kustomization.yaml\">https://github.com/Jeff-Tian/uni-orders/blob/main/k8s/kustomization.yaml</a>。</p>\n<p><a name=IiOSh></a></p>\n<h2>Okteto</h2>\n<p>Okteto 提供免费的 Kubernetes 集群供个人开发者使用，当然在 24 小时闲置后会被休眠，但你只需要每 24 小时部署一下就能激活。\n<a name=yk1sL></a></p>\n<h3>ingress</h3>\n<p>使用 Okteto，可以定义 deployment 和 service，但是 ingress 不能免费地自定义，而只能使用 Okteto 提供的自动 ingress。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665037381101-55fa00b2-1648-4b97-92d5-17b0494718ab.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=594&#x26;id=uab66e2ea&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1188&#x26;originWidth=1850&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=268143&#x26;status=done&#x26;style=none&#x26;taskId=u39fcc99a-cf0b-4778-a979-ed92b10cc4d&#x26;title=&#x26;width=925\" alt=\"image.png\"></p>\n<p>这样虽然让 ingress 自动化了，但是却只能使用 Okteto 的免费域名，形如 uni-orders-jeff-tian.cloud.okteto.net 。\n<a name=kbDl9></a></p>\n<h3>secrets</h3>\n<p>对于一些保密信息，可以通过 secrets 提供，这通常是一个 yaml 文件，然后通过 kubectl apply -f secrets.yaml即可。要将这些 secrets 以环境变量形式灌入应用运行时，需要在 deployment.yaml 中进行如下格式的 env 定义：</p>\n<p>yaml\n...\nspec:\ncontainers:\n- image: jefftian/uni-orders:latest\nimagePullPolicy: Always\nname: uni-orders\nenv:\n- name: GET_HOSTS_FROM\nvalue: dns\n- name: pgHost\nvalueFrom:\nsecretKeyRef:\nkey: pgHost\nname: uni-orders-secrets\n- name: pgPort\nvalueFrom:\nsecretKeyRef:\nkey: pgPort\nname: uni-orders-secrets\n- name: pgUsername\nvalueFrom:\nsecretKeyRef:\nkey: pgUsername\nname: uni-orders-secrets\n- name: pgPassword\nvalueFrom:\nsecretKeyRef:\nkey: pgPassword\nname: uni-orders-secrets\n- name: POSTGRES_URL\nvalueFrom:\nsecretKeyRef:\nkey: POSTGRES_URL\nname: uni-orders-secrets\n- name: pgDatabase\nvalueFrom:\nsecretKeyRef:\nkey: pgDatabase\nname: uni-orders-secrets</p>\n<p><a name=L3nmG></a></p>\n<h2>Napptive</h2>\n<p>虽然 Okteto 对开发者非常友好，但仍然需要有备胎，并且从第一天开始就要考虑好备胎，以保持随时切换的自由。Okteto 的备胎，就是 Napptive，它提供的服务和 Okteto 类似，所以你要每 24 小时就更新一下应用，以保持激活状态。</p>\n<p>Napptive 还允许你绑定自定义域名，这一点比 Okteto 更友好。</p>\n<p>Napptive 不只提供一个裸的 Kubernetes 服务，还在上面包了一层，以 OAM 的形式对开发者提供服务，对于应用，需要使用 OAM 的形式定义一个 yaml。\n<a name=YlMjD></a></p>\n<h3>ingress</h3>\n<p>要使用 Napptive 的 ingress，需要在应用的 yaml 文件中以 napptive-ingress�的 traits结点进行定义：\nyaml\n...\ntraits:</p>\n<ul>\n<li>type: napptive-ingress\nproperties:\nname: uni-orders\nport: 3000\npath: /</li>\n</ul>\n<p><a name=ytHZ7></a></p>\n<h3>secrets</h3>\n<p>secrets 仍然可以通过 yaml 文件的形式，使用 kubectl apply -f secrets.yaml的形式部署进入 Napptive 的 Kubernetes 集群中：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665038507916-86998d36-8a81-4937-a795-e1753ae30687.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=630&#x26;id=ud213f441&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1260&#x26;originWidth=3032&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=391843&#x26;status=done&#x26;style=none&#x26;taskId=u321025f4-9011-426d-8c69-e1cc19c195f&#x26;title=&#x26;width=1516\" alt=\"image.png\"></p>\n<p>但是要将定义好的 secrets 灌入应用运行时，方式和在普通的 Kubernetest 集群中的操作不一样，不通过 deployment.yaml 文件，而是和 ingress 类似，使用 service-binding的 traits结点进入声明：\nyaml\n...</p>\n<p>spec:\ncomponents:\n- name: uni-orders\ntype: webservice\ntraits:\n...\n- type: service-binding\nproperties:\nenvMappings:\npgHost:\nsecret: uni-orders-secrets\nkey: pgHost\npgPort:\nsecret: uni-orders-secrets\nkey: pgPort\npgUsername:\nsecret: uni-orders-secrets\nkey: pgUsername\npgPassword:\nsecret: uni-orders-secrets\nkey: pgPassword\nPOSTGRES_URL:\nsecret: uni-orders-secrets\nkey: POSTGRES_URL\npgDatabase:\nsecret: uni-orders-secrets\nkey: pgDatabase</p>\n<p><a name=IOXhI></a></p>\n<h1>自动化</h1>\n<p>以上以 Okteto 和 Napptive 为例，免费地验证了在多个 Kubernetes 集群间自由切换应用的可行性，后面就要将这一切自动化了。因为代码托管在 GitHub 上，自然地使用了 GitHub Actions 来将 CICD 的步骤自动化，一次代码提交，自动运行测试、构建，打包容器镜像，然后将打包好的应用同时部署在两个云上。</p>\n<p><a name=NFaeU></a></p>\n<h3>secrets CD 流水线</h3>\n<p>但是，应用的保密信息，应该首先完成自动化的 CICD。目前，建议将 secrets 单独放在一个私有仓库中，毕竟 GitHub 的私有仓库也是对个人永久免费的。<img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665041506607-c4da14e7-5439-4874-a58c-e8e3f2cb6ca9.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=687&#x26;id=ucf42ec17&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1374&#x26;originWidth=1652&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=241837&#x26;status=done&#x26;style=none&#x26;taskId=ub499beaa-ed72-4fd1-8b8d-a2724ba9a52&#x26;title=&#x26;width=826\" alt=\"image.png\"></p>\n<p>最终实现的效果如上图所示，一次代码提交会同时触发向两朵云部署 secrets，其 workflow 定义如下：\nyaml\nname: secrets CICD</p>\n<p>on:\npush:\nbranches: [ main ]\npull_request:\nbranches: [ main ]</p>\n<p>jobs:\ndeploy-napptive:\nruns-on: ubuntu-latest\nenv:\nPLAYGROUND_PAT: ${{ secrets.PLAYGROUND_PAT }}\nsteps:\n- uses: actions/checkout@v2\n- run: echo Downloading NAPPTIVE Playground CLI\n- run: curl -O <a href=\"https://storage.googleapis.com/artifacts.playground.napptive.dev/installer.sh\">https://storage.googleapis.com/artifacts.playground.napptive.dev/installer.sh</a> &#x26;&#x26; bash installer.sh</p>\n<pre><code>  - run: echo Downloading Kubectl\n  - run: curl -LO https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\n  - run: chmod +x kubectl\n  - run: echo Login into NAPPTIVE Playground\n  - run: playground login --pat\n  - run: playground get-kubeconfig\n  - run: ls ~/.napptive/default/napptive-kubeconfig\n  - name: update\n    run: |\n      export PATH=$PATH:$(pwd)\n      kubectl --kubeconfig ~/.napptive/default/napptive-kubeconfig apply -f secrets.yml\n</code></pre>\n<p>deploy-okteto:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v3\n- run: curl -LO <a href=\"https://storage.googleapis.com/kubernetes-release/release/$(curl\">https://storage.googleapis.com/kubernetes-release/release/$(curl</a> -s <a href=\"https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\">https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</a>\n- run: chmod +x ./kubectl\n- run: sudo mv ./kubectl /usr/local/bin/kubectl\n- run: mkdir ${HOME}/.kube\n- run: npm i -g k8ss\n- run: echo -e machine github.comn  login ${{secrets.GH_TOKEN}} > ~/.netrc\n- run: git clone <a href=\"https://github.com/Jeff-Tian/k8s-config.git\">https://github.com/Jeff-Tian/k8s-config.git</a> ${HOME}/k8s-config\n- run: k8ss switch --cluster=okteto --namespace=jeff-tian\n- run: kubectl apply -f secrets.yml</p>\n<p>对于 Napptive 的流水线，需要一个 PLAYGROUND_PAT 环境变量，对于 okteto 流水线，需要 okteto 的 kubeconfig 文件。<img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665041748577-6dc9eb55-b2f3-44eb-8378-d0c8357321f0.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=647&#x26;id=u6d6145ac&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1294&#x26;originWidth=1912&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=262395&#x26;status=done&#x26;style=none&#x26;taskId=ud14f03cf-18ea-4a71-91f7-2020bbd5c2a&#x26;title=&#x26;width=956\" alt=\"image.png\"></p>\n<p>PLAYGROUND_PAT 可以按照其官网文档获取，然后在 GitHub Actions 中存储其值即可。它的值其实是一个 jwt，并且永不过期，所以一定要安全保存：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665041841441-aa709a3e-5b24-433c-b07a-b0a9599c7750.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=687&#x26;id=ub3f2b42b&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1374&#x26;originWidth=2140&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=327077&#x26;status=done&#x26;style=none&#x26;taskId=u93b2a8ad-546b-4029-b151-f332b77c8d2&#x26;title=&#x26;width=1070\" alt=\"image.png\"></p>\n<p>对于 okteto 的配置文件，我用了另一个私有仓库 k8s-config 来保存，并且使用自己开发的 k8ss 工具进行管理。这样很方便，但是需要一个额外的 GH_TOKEN 来进行访问（因为 k8s-config 也是私有仓库）。所以最后的 GitHub Action 需要两个 secrets：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665041955763-5ac3ada1-1f03-4e23-b12e-2e173b7aded7.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=613&#x26;id=uf6f38b1f&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1226&#x26;originWidth=2418&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=302090&#x26;status=done&#x26;style=none&#x26;taskId=u4d8b8cbc-af4a-40e7-8322-b7c69b5dc43&#x26;title=&#x26;width=1209\" alt=\"image.png\">\n<a name=TnZuH></a></p>\n<h3>构建应用本身的 CICD 流水线</h3>\n<p>应用本身的 CICD 流水线，对于 CI 部分也没什么特别。关键在于 CD 部分，如同 secrets 的 CD 一样，需要同时更新两朵云。具体的流水线定义见文件： <a href=\"https://github.com/Jeff-Tian/uni-orders/blob/main/.github/workflows/node.js.yml\">https://github.com/Jeff-Tian/uni-orders/blob/main/.github/workflows/node.js.yml</a> 。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665043378700-639eb109-fbd2-466b-a386-cd7ce7ac5d43.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=710&#x26;id=u907e18e9&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1420&#x26;originWidth=2206&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=310923&#x26;status=done&#x26;style=none&#x26;taskId=u463e6ddd-ad20-44f5-830b-896c07ef65e&#x26;title=&#x26;width=1103\" alt=\"image.png\"><br />对于 playground apps create方式，只能在第一次使用（应用部署上 napptive 之前）。一旦部署好，再次 create会报应用已存在的错误。所以对于应用的更新，不能再次使用 create命令。希望以后 napptive cli 再提供一个 apps update命令吧。由于 napptive 底层仍然是 Kubernetes，所以在  apps update之前，可以使用 kubectl patch deploy的形式去更新镜像的版本号。</p>\n<p>建议先执行 kubectl get deploy uni-orders -o yaml的方式查看一下当前的 deploy 文件，然后找到需要 patch 的内容。比如对如下的 deploy<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665043279670-2b660a0c-f1b9-4495-acc3-0be53e77bad1.png#clientId=u1d53d6a7-016f-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=849&#x26;id=u682e1a90&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1698&#x26;originWidth=2070&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=303892&#x26;status=done&#x26;style=none&#x26;taskId=uba4d70c5-2246-4c67-a9f0-82d5b908961&#x26;title=&#x26;width=1035\" alt=\"image.png\"></p>\n<p>对应的 patch 命令是这样的：\nshell\nkubectl --kubeconfig ~/.napptive/default/napptive-kubeconfig patch deploy uni-orders --patch {spec:{template:{spec:{containers:[{image:jefftian/uni-orders,name:uni-orders}]}}}} --type=merge</p>\n<p><a name=nYqcP></a></p>\n<h1>总结</h1>\n<p>通过 Serverless 框架，可以自由地在各大云厂商提供的 lambda, function, 函数计算间切换。而使用 OAM，则可以自由地在各 Kubernetes 集群间切换。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}