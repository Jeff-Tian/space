{"componentChunkName":"component---src-templates-post-js","path":"/posts/zb1gdu","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/zb1gdu","relativePath":"posts/zb1gdu","frontmatter":{"title":"加密 Kubernetes 集群中的敏感信息","stackbit_url_path":"posts/zb1gdu","date":"2021-02-19T12:08:40","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<blockquote>\n<p>使用 Mozilla SOPS 来加密 Kubernetes 集群中的敏感信息</p>\n</blockquote>\n<p>Kubernetes 已经成为运行容器工作负载的事实标准，在很多大型企业的数字开放平台也处于中心地位。然而，和 Kubernetes 相关的工作非常有挑战性，这其中之一就是如何处理工作负载正常运行所需要的一些敏感信息。这些敏感信息包括但不限于密码，API 密钥，令牌等等。</p>\n<p>任何不小心的敏感信息泄漏将对这种大型企业的声誉以及收入带来严重威胁，所以必须使用一种安全的方式来存储这些数据。关于这个问题有许多不同的解决方案，本文将分享如何使用 Mozilla SOPS 来存储敏感数据的方案，这个方案不需要太多的修改和适配。</p>\n<hr>\n<p><a name=NDISA></a></p>\n<h2>Kubernetes 中的敏感信息长什么样？</h2>\n<p>对于 Kubernetes 的新手，可以快速看一下如下截图，了解敏感信息在 Kubernetes 中是怎样定义的：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1613733491296-d518ca74-d468-4b35-a204-6c109063fafc.png#align=left&#x26;display=inline&#x26;height=346&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=346&#x26;originWidth=424&#x26;size=34590&#x26;status=done&#x26;style=none&#x26;width=424\" alt=\"image.png\">\n一个典型的 Kubernetes 集群中的敏感数据</p>\n<p>如上图所示，这是 Kubernetes 中敏感信息的默认类型，所有信息都以键值对的形式保存在一个 YAML 文件中， data 区域的值必须使用 base64 编码。这个文件一旦创建出来，你就可以使用以下命令将敏感数据部署到你的命名空间中：</p>\n<p>shell\nkubectl apply -f mysecret.yml</p>\n<p>现在我们知道敏感数据长什么样了，如果我们希望保持它们的安全，就需要回答两个问题：</p>\n<ul>\n<li>我要将这个 YAML 文件放置在哪里？以什么方式保存？</li>\n<li>当敏感信息被部署到命名空间中后，如何放置泄漏？</li>\n</ul>\n<hr>\n<p><a name=n0HHG></a></p>\n<h2>使用 Mozilla SOPS 存储敏感信息</h2>\n<p>Mozilla SOPS 是一个加密文件编辑器，支持 YAML、JSON、ENV、INI 以及二进制文件，也支持各种不同的加密提供商诸如 AWS KMS、GCP KMS、Azure Key Vault、Hashicorp Vault 以及 PGP。保存敏感数据可以有很多选项，但是对于 Kubernetes 来说，SOPS 尤其适合，主要有以下这些原因：</p>\n<ul>\n<li><strong>易于使用</strong>：你只需要解密、编辑、然后加密即可，不需要学习新的工具，也不需要使用 Restful API 和第三方服务打交道而导致的学习曲线陡峭。</li>\n<li><strong>可以将代码和敏感数据放在一起</strong>：将敏感信息加密可以让你将它们随代码一起提交到版本管理系统（如 git）中，相比其他方案，这将大大简化持续集成/持续部署流程。</li>\n<li><strong>跟踪变化特别简单</strong>：和上一个优点相关：将敏感信息提交到版本管理系统中，跟踪变化就非常简单了。而且还可以看出是谁做了什么改变。</li>\n<li><strong>不需要额外的基础设施支持</strong>：其他方案比如 Hashicorp 就需要额外的工具链，甚至需要为其部署额外的存储设施（Consul、DynamoDB 等等）。这些额外的工具增加了架构中的复杂性，但是并没有为你的产品带来额外的价值。</li>\n<li><strong>没有扩展问题</strong>：再一次和前一个优点相关，由于不需要额外的基础设施，也就不需要为其做额外的运维和扩展工作，对某些大项目来说这些工作可能是很大的一个问题。</li>\n</ul>\n<p>接下来让我们看一下如何使用它来加密敏感数据。</p>\n<hr>\n<p><a name=EQtME></a></p>\n<h2>使用 SOPS 来加解密</h2>\n<p>SOPS 的官方文档中已经有一个使用 PGP 密钥的基本用法，但是其强大之处在于 **.sops.yaml **文件，所有的魔法都在这个文件里。来看一下它长什么样：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1613734900519-93c3726d-76bd-4a92-bd49-3303c1443ac7.png#align=left&#x26;display=inline&#x26;height=426&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=426&#x26;originWidth=1400&#x26;size=149005&#x26;status=done&#x26;style=none&#x26;width=1400\" alt=\"image.png\">\n.sops.yaml 的样例文件</p>\n<p>.sops.yaml 文件包含了对代码仓库中的文件进行加解密的所有规则。以上面的文件为例，对于加解密有两个不同的规则。这些规则的优先级是从上到下的，第一个出现的规则被优先应用。详细地说：</p>\n<ul>\n<li>第一个是说所有匹配正则表达式的文件将使用 AWS KMS 进行加解密。结合 SOPS 和 AWS KMS 的主要优势在于你可以给 SOPS 在不同的区域提供多个不同的密钥，从而避免了加解密过程中的单点故障。</li>\n<li>第二个是说文件将使用给定的 PGP 密钥进行加解密。对于不匹配前一个规则中的文件，这个规则将被应用。</li>\n</ul>\n<p>一旦你写好了你的 .sops.yaml 文件，就可以用如下命令进行加密：</p>\n<p>shell\nsops -e <filename> -p &#x3C;your_key_here></p>\n<p>这会产生类似如下的输出：</p>\n<p><strong><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1613735384145-a4ff0b0b-cd51-40b9-a5bb-4e6cf32b21db.png#align=left&#x26;display=inline&#x26;height=1435&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1435&#x26;originWidth=1400&#x26;size=575761&#x26;status=done&#x26;style=none&#x26;width=1400\" alt=\"image.png\"></strong>\n使用 SOPS 加密的结果示意图</p>\n<p>正如你所看到的，文件中所有相关数据都已经被加密。SOPS 并不会加密键，所以你不必关心具体的值，就能很容易看到什么值被修改了。</p>\n<p>SOPS 也支持密钥轮换，假设你的密钥泄漏了，那么你可以将它们从 .sops.yaml 文件中移除，然后重新加密，这很简单，只需要：</p>\n<p>shell\nsops -r -i --rm-pgp &#x3C;your_key_here> filename</p>\n<p>如果需要更高级的用法和示例，可以参考 SOPS 的文档。</p>\n<p>好，现在敏感数据已经被安全地存储在版本管理系统中了，但还有一个问题待解决：如何保证敏感数据在集群中的安全？</p>\n<p><a name=RUAbQ></a></p>\n<h2>在集群中加密敏感数据： RBAC</h2>\n<p>敏感数据已经安全地保存在版本管理系统中了，是时候保证只让授权过的用户访问它们了。</p>\n<p>通常，在集群中我们使用命名空间隔离不同项目，并且默认授予在这些命名空间中的所有权限。这是一个很糟糕的实践，得不惜一切代价摒弃这种做法。幸运的是 Kubernetes 提供了一个非常强大的角色系统可供使用。</p>\n<p>先创建一个新的角色：</p>\n<h2>yaml</h2>\n<p>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nnamespace: your_namespace\nname: read-only-role\nrules:</p>\n<ul>\n<li>apiGroups: []\nresources: [pods, configmaps, services, pods/log]\nverbs: [get, watch, list]</li>\n</ul>\n<p>这是一个很基本的角色，它允许所有人在你的命名空间 your_namespace 中执行如下几个操作：</p>\n<ul>\n<li>查询/列出/观察 pod, configmap 和 services</li>\n<li>从 pod 中查询日志</li>\n</ul>\n<p>现在该绑定这个角色了，这需要一个 rolebinding，正如其名，它将角色绑定到一个主题上。主题可以是用户、组或者服务账号。可以使用如下示例将角色绑定到一个用户：</p>\n<p>yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: read-only\nnamespace: your_namespace\nsubjects:</p>\n<ul>\n<li>kind: User\nname: Jeff # Name is case sensitive, so be careful with that!\napiGroup: rbac.authorization.k8s.io</li>\n</ul>\n<p>roleRef:\nkind: Role\nname: read-only-role\napiGroup: rbac.authorization.k8s.io</p>\n<p>一旦应用，就算凭据被泄漏（最好不要），恶意攻击者将只能做前面列出的仅有的几个操作，不会对基础设施造成威胁。</p>\n<hr>\n<p><a name=8Wrwt></a></p>\n<h2>总结</h2>\n<p>SOPS 是加密的强大工具，但是必须记住仍然需要应用更多的和集群相关的策略（比如本文建议的一个）才能是你的秘密信息真的被保密。</p>\n<p>以上是某大型企业的生产实践，欢迎留言分享你在 Kubernetes 集群中处理敏感信息的策略。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"本站源码","url":"https://github.com/Jeff-Tian/space","style":"link","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}