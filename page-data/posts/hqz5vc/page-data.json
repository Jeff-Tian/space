{"componentChunkName":"component---src-templates-post-js","path":"/posts/hqz5vc","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/hqz5vc","relativePath":"posts/hqz5vc","frontmatter":{"title":"10 年前老博客以 JAM Stack 方式满血复活！","stackbit_url_path":"posts/hqz5vc","date":"2021-03-25T07:59:46","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>我是从 2009 年开始写博客的，当时出于对技术的无知和对 .NET 的痴迷，采用了 BlogEngine.NET 作为博客站，并且部署到了国外的托管虚拟主机。后来穷得越来越支付不起虚拟主机的月租费，最终在 2014 年将其迁移到了 Azure 的免费托管平台：<a href=\"https://be-net.azurewebsites.net/\">https://be-net.azurewebsites.net/</a>，似乎不错，然而它在中国的访问速度并不理想，于是放弃了维护，不再在该平台上更新博文。</p>\n<p>不是不再写博文，只是换到其他免费平台上了。当然想过将自己的 BlogEngine.NET 迁移到其他平台，但是很不顺利，于是将其归档，准备等自己技术更加成熟后再重启它。</p>\n<p>直到今天，觉得自己的技术已经足够成熟，开始着手重启它，过程可以说是相当顺利和高效，最后的效果是 10 年前的自己想像不到的：<a href=\"https://jeff-tian.jiwai.win/\">https://jeff-tian.jiwai.win/</a> 。</p>\n<ul>\n<li>免费</li>\n<li>全静态</li>\n<li>有强大的 CDN 支持</li>\n<li>https</li>\n<li>和 git 无缝集成</li>\n</ul>\n<p><a name=0Gn5S></a></p>\n<h2>总结</h2>\n<p>10 年前的基于 SQLite 数据库和 .NET 服务端的单站点动态博客系统，被改造成了 JAMStack 技术栈的全静态拥有 CDN 和 https 支持的单页应用。</p>\n<p><a name=TLYW7></a></p>\n<h2>JAMStack</h2>\n<p>JAMStack 是一种让网站更快、更安全、并且更易于伸缩的架构。它构建在开发者热爱的众多工具链和工作流基础之上，使得生产力最大化。</p>\n<p>其核心原则是预渲染和解耦，从而让站点和应用的发布拥有前所未有的信心和弹性。</p>\n<p>JAM 最早可能是 JavaScript、API 和 Markup 的缩写，即使用标记语言写好站点视图，数据和交互通过 JavaScript 和 API 技术进行增强。但是现在成为了一个架构范式。</p>\n<p><a name=4bOsP></a></p>\n<h3>特性</h3>\n<p><a name=a4sDW></a></p>\n<h4>预渲染</h4>\n<p>在 JAMStack 中，整个前端都是在构建过程中预生成为高度优化过的静态页面和资源。这个预渲染的过程使得站点可以直接从 CDN 加载，节省了成本、减少了复杂度和风险，不再依赖关键的基础设施和动态服务器。</p>\n<p>因为有很多流行的工具用来生成站点，像 Gatsby，Hugo，Jekyll，Eleventy，NextJs 等等，很多网页开发者已经熟悉了所需要的这些工具，所有转变成更有生产力的 JAMStack 开发者是很容易的。\n<a name=vfn75></a></p>\n<h4>利用 JavaScript 增强</h4>\n<p>通过标记语言和直接从 CDN 加载的 JAMStack 站点中的其他用户接口资源，这些站点可以很快并且安全的发布。在这个基础上，JAMStack 站点可以使用 JavaScript 和 API 和后端服务沟通，从而允许增强和个性化用户体验。\n<a name=n1lLE></a></p>\n<h4>利用服务更进一步增强</h4>\n<p>丰富的 API 生态成为了 JAMStack 站点的显著赋能者。由于拥有利用域名专家的能力，这些专家可以通过 API 来提供产品和服务，从而团队可以构建出更加复杂的应用，相比自己实现这样的能力需要承担更多的风险和额外的负担。现在我们可以将诸如身份认证、支付、内容管理、数据服务、搜索以及更多的事情外包出去了。</p>\n<p>JAMStack 站点可以在构建时利用这些服务，并且在运行时直接通过 JavaScript 在浏览器里直接利用这些服务。清晰解耦的这些服务带来了更大的可移植性和灵活性，同时还显著降低了风险。</p>\n<p><a name=OohZ3></a></p>\n<h3>好处</h3>\n<p>采用 JAMStack 架构的站点和项目工作流拥有各种好处，其中的关键是：\n<a name=EY1Aq></a></p>\n<h4>安全</h4>\n<p>JAMStack 从托管基础设施中移除了变动的部分和系统，从而只需要更少的服务器和系统，减少了攻击面。<br />页面和资源都是预生成的文件，从而支持只读托管，这更进一步减少了可能的攻击向量。同时支持由提供商提供动态的工具和服务，这些专业提供商有专门的团队来对其专业的产品做安全加固，并且提供高标准的服务。</p>\n<p><a name=q3dHW></a></p>\n<h4>可扩展</h4>\n<p>流行的处理高流量负载的架构是通过额外添加缓存热门视图和资源的逻辑来实现的，而在 JAMStack 架构中，这是<br />默认提供的：它不再需要额外的复杂逻辑和工作流来决定哪些资源何时需要缓存，因为整个站点是完全通过 CDN 来提供服务的。</p>\n<p>采用 JAMStack 的站点，所有的一切都被缓存在内容分发网络中。拥有更简单的部署，天然内置的冗余，以及难以置信的高负载能力等特性。</p>\n<p><a name=5iEXm></a></p>\n<h4>高性能</h4>\n<p>页面加载速度对用户的体验和交互影响非常大。 JAMStack 站点不再需要服务器在请求时生成页面视图，而是在构建时提前生成页面。</p>\n<p>因为所有的页面已经在离用户最近的 CDN 节点中可获取，所以没有昂贵和复杂的基础设施，也能达到极高的性能。</p>\n<p><a name=r96D2></a></p>\n<h4>可维护</h4>\n<p>托管复杂性降低后，维护性任务也减少了。一个预生成的站点，无论直接从单主机还是直接从 CDN 加载都不再需要专家团队来护航。</p>\n<p>这些维护工作都在构建时完成了，所以现在是一个生成好的站点，它非常稳定并且可以无服务器托管，从而不存在打补丁、升级或者运维的工作。</p>\n<p><a name=FjxFt></a></p>\n<h4>可移植</h4>\n<p>JAMStack 站点是预生成的。这意味着你可以使用各种托管服务来托管它们，并且可以在你喜欢的托管服务中自由转移。任何简单的静态托管方案就足够了。</p>\n<p>基础设施绑定，再见。</p>\n<p><a name=XBzif></a></p>\n<h4>开发体验</h4>\n<p>JAMStack 站点可以使用各种工具构建。它们不依赖特定技术或者奇怪的小众框架。相反，它们构建在被广泛使用的工具之上并且遵守被广泛使用的约定。这样的结果就是，寻找具有激情和天赋的开发者就没那么困难了。</p>\n<p>效率和效益相得益彰。</p>\n<p><a name=CYuaB></a></p>\n<h3>最佳实践</h3>\n<p>如果你坚持使用一点点最佳实践，那么在构建 JAMStack 项目时，你就可以真的从这个技术栈里得到最大的收益。</p>\n<p><a name=yipmU></a></p>\n<h4>将整个站点部署在 CDN</h4>\n<p>因为 JAMStack 项目不依赖服务端代码，所以可以分布式部署而不是存活在单台服务器上。直接将整站托管在 CDN  解锁了无可匹敌的速度和性能。你的应用推到边缘的东西越多，用户体验就越好。\n<a name=wwTRL></a></p>\n<h4>现代化的构建工具链</h4>\n<p>充分利用现代化的构建工具。浏览器的世界变化太快就像一片难以适应的丛林，但是你仍然希望不必等到明天的浏览器问世而在今天就用上明天的网页标准。那么目前这意味着你要使用 Babel、PostCSS、Webpack 以及相关的工具。\n<a name=aast2></a></p>\n<h4>自动化构建</h4>\n<p>因为 JAMStack 标记是预生成的，所以改变内容后只有在下一次构建才可能发不到生产环境。自动化这个过程将节省你很多精力。你可以利用 webhooks，或者使用一个包含自动化服务的发布平台。\n<a name=I8qtw></a></p>\n<h4>原子化部署</h4>\n<p>由于 JAMStack 项目增长得非常之大，新的改变可能需要重新部署成百上千的文件。一个一个的文件上传方式会导致在这个过程结束前系统处于一个不一致的状态。你可以利用让你实现“原子化部署”的系统来避免这个情况的发生，这种平台只在所有改变的文件全部更新后才会发布到生产环境。\n<a name=wf1Cd></a></p>\n<h4>即时缓存失效方案</h4>\n<p>当构建-部署的循环变成一个常规行为后，你需要确保当一个部署上线后，它就真的上线了。通过确保你的 CDN 能够处理即时缓存清空来打消你的任何疑虑。\n<a name=FFfMA></a></p>\n<h4>将所有东西都放在 Git 里</h4>\n<p>在 JAMStack 项目中，任何人都能够通过 git 克隆，然后使用标准流程安装需要的依赖（比如 npm install）之后在本地运行整个项目。不需要数据库克隆，不需要复杂的安装。这减少了贡献者的难题，也简化了 staging 和 testing 工作流。</p>\n<p><a name=RlmFi></a></p>\n<h2>复活过程</h2>\n<p>在了解到了 JAMStack 架构后，我感觉自己的技术储备准备好了。其实博客文章一旦写好，就应该是一份静态文件，毕竟没有什么太多的动态信息。静态文件的好处是没有服务器端性能损耗，并且可以缓存到 CDN 的终端节点。所以完全没有必要去使用 .NET 之类的服务器端程序。整个复活过程如下：</p>\n<p><a name=sYP15></a></p>\n<h3>静态站点生成工具的选择</h3>\n<h2>这样的工具非常多，我最终选择了 Stackbit。通过创建一个 Stackbit 站点，就能看到项目目录结构，这个项目其实是一个典型的 Gatsby JS 项目加上一个 Stackbit 工具链。博客文章主要在 src/pages/posts 目录下，并且每篇博客都是一个如下结构的 markdown 文件：\nmarkdown</h2>\n<p>stackbit_url_path: posts/url\ntitle: 标题\ndate: 时间\nexcerpt: >-\n摘要...\nthumb_img_path: >-\n头图URL\ncomments_count: 评论数\npositive_reactions_count: 点赞数\ntags:</p>\n<ul>\n<li>标签1</li>\n<li>标签2</li>\n</ul>\n<h2>canonical_url: >-\n原文链接\ntemplate: post</h2>\n<p>正文部分</p>\n<p>因此在后续就需要将数据导出成上面的结构\n<a name=hKdmI></a></p>\n<h3>数据导出</h3>\n<p>之前的 BlogEngine.NET，我使用了 SQLite 作为数据库，现在需要将里面的结构化数据导出成为一个 JSON 文件。\n<a name=pzcFx></a></p>\n<h4>工具</h4>\n<p>以前用过 SQLite Browser、DBeaver 等等桌面软件，这些 GUI 工具都支持 SQLite。但是今天隆重推荐使用 Metabase，自从我使用了它，就爱不释手，再也不想用以前的那些桌面软件了。它是一个 Web 应用，启动非常简单：<br />先去官网下载一个 jar 包文件 metabase.jar。然后在命令行输入： java -jar metabase.jar 。这样就在本定环境启动了 metabase，打开浏览器，输入 <a href=\"http://localhost:3000\">http://localhost:3000</a> 即可打开 metabase，输入 SQLite 文件路径，就进入到主页面。<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616653088932-4ec7e8f4-1816-4a0a-97a7-80399ea2ec36.png#align=left&#x26;display=inline&#x26;height=370&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=740&#x26;originWidth=1612&#x26;size=80133&#x26;status=done&#x26;style=none&#x26;width=806\" alt=\"image.png\"><br />点击打开 BlogEngine.NET，可以看到表结构，对于迁移博文来说，比较关注 Be Posts 和 Be Post Tag：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616653259820-a2102261-366e-4244-8f42-4023376acd85.png#align=left&#x26;display=inline&#x26;height=877&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1754&#x26;originWidth=1860&#x26;size=304082&#x26;status=done&#x26;style=none&#x26;width=930\" alt=\"image.png\"><br />你可以很方便地浏览一下自己发布博文的频率情况，只需要点击进入 Be Posts 然后选择 Date Created 字段并且点击分布：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616653416214-98ea0e96-5ffe-4b9e-9c63-782c603388ca.png#align=left&#x26;display=inline&#x26;height=392&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=784&#x26;originWidth=1372&#x26;size=104958&#x26;status=done&#x26;style=none&#x26;width=686\" alt=\"image.png\"><br />就能立即得到曲线图：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616653470226-a0d98a4d-a902-4576-a721-037e24aa3319.png#align=left&#x26;display=inline&#x26;height=794&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1588&#x26;originWidth=2000&#x26;size=186843&#x26;status=done&#x26;style=none&#x26;width=1000\" alt=\"image.png\">\n<a name=pftEL></a></p>\n<h4>SQL 查询</h4>\n<p>我们需要将数据导出成在前面分析过的数据结构，最终的 SQL 查询如下：\nsql\nSELECT PostId, src/pages/posts/ ||  (case when ltrim(Slug) &#x3C;>  then Slug else PostId end) || .md as filePath, posts/ || (case when ltrim(Slug) &#x3C;>  then Slug else PostId end)  as urlPath, ---\n||\nstackbit_url_path: >-\n||   posts/  || (case when ltrim(Slug) &#x3C;>  then Slug else PostId end) ||</p>\n<p>title:  || replace(Title, , ) ||\n||\ndate:  || DateCreated ||\n||\nexcerpt: >-\n||\nreplace(Description,\n,\n) ||\n||\ncomments_count: 0\n||\npositive_reactions_count: 0\n||\ntags:</p>\n<ul>\n<li>||</li>\n</ul>\n<pre><code>ifNull((select tags from (select PostId, GROUP_CONCAT(tag, \n</code></pre>\n<ul>\n<li>) as tags</li>\n</ul>\n<p>FROM (select distinct PostId, tag from be_PostTag) as be_PostTag\nwhere be_PostTag.PostId = POST.PostId group by be_PostTag.PostId)), ) ||\n||\ncanonical_url: <a href=\"https://be-net.azurewebsites.net/post/\">https://be-net.azurewebsites.net/post/</a> || strftime(%Y, DateCreated) || / || strftime(%m, DateCreated) || / || strftime(%d, DateCreated) || / || (case when ltrim(Slug) &#x3C;>  then Slug else PostId end) ||\n||\ntemplate: post\n||\n---\n|| PostContent AS data\nFROM\n(\nSELECT be_Posts.PostRowID AS PostRowID, be_Posts.BlogID AS BlogID, be_Posts.PostID AS PostID, be_Posts.Title AS Title, be_Posts.Description AS Description, be_Posts.PostContent AS PostContent, be_Posts.DateCreated AS DateCreated, be_Posts.DateModified AS DateModified, be_Posts.Author AS Author, be_Posts.IsPublished AS IsPublished, be_Posts.IsCommentEnabled AS IsCommentEnabled, be_Posts.Raters AS Raters, be_Posts.Rating AS Rating, be_Posts.Views AS Views, be_Posts.Slug AS Slug, be_Posts.IsDeleted AS IsDeleted\nFROM be_Posts\nWHERE be_Posts.IsDeleted = 0\nLIMIT 1048576\n) as POST</p>\n<p>主要就是从 BePosts 和 BePostTag 两张表中，把数据组合成需要的样子。\n<a name=GtIoX></a></p>\n<h4>标签聚合</h4>\n<p>标签表结构如下：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616654311214-cf55ef49-be36-403f-a33f-5e8502b4ac87.png#align=left&#x26;display=inline&#x26;height=339&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=678&#x26;originWidth=1674&#x26;size=154921&#x26;status=done&#x26;style=none&#x26;width=837\" alt=\"image.png\"><br />首先需要将同一个 PostId 的 Tag 聚合到一行，然后将他们用 “【回车符】  -  ” 分割串联。可以这样做：\nsql\nifNull((select tags from (select PostId, GROUP_CONCAT(tag,</p>\n<ul>\n<li>) as tags</li>\n</ul>\n<p>FROM (select distinct PostId, tag from be_PostTag) as be_PostTag\nwhere be_PostTag.PostId = POST.PostId group by be_PostTag.PostId)), )</p>\n<p>以上考虑到了数据为空的情况，这样就组成了 markdown 文件中的 Tags 部分。\n<a name=JrAeg></a></p>\n<h4>URL 生成</h4>\n<p>博文 URL 的生成，优先使用 Slug，当 Slug 为空时，回退到使用 PostId：\nsql\nposts/ || (case when ltrim(Slug) &#x3C;>  then Slug else PostId end)  as urlPath</p>\n<p><a name=TLwpw></a></p>\n<h4>导出为 JSON</h4>\n<p>除了以上两个比较特殊的 SQL 处理，其他的 SQL 都是平凡的。将他们运行，得到结果后，选择导出为 JSON 文件：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616655400934-6c85976a-8e81-454b-a49e-8b944e0fac59.png#align=left&#x26;display=inline&#x26;height=863&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1726&#x26;originWidth=1776&#x26;size=347844&#x26;status=done&#x26;style=none&#x26;width=888\" alt=\"image.png\"><br />得到的 JSON 文件是这样的：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616655491959-c4b8f7d0-fb9e-4b24-80f9-419d003d2d15.png#align=left&#x26;display=inline&#x26;height=708&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1416&#x26;originWidth=3392&#x26;size=854775&#x26;status=done&#x26;style=none&#x26;width=1696\" alt=\"image.png\">\n<a name=XcETK></a></p>\n<h3>静态文件生成</h3>\n<p>如上所示，得到的 JSON 文件是一个数组，需要为其中每一个元素创建一个对应的文件。通过分析 Stackbit 官方的 stackbit-pull 库，可以发现我们只需要将其从远端服务拉取 JSON 响应的过程简化成直接从本地读取即可，剩下的创建文件的逻辑一模一样。所以，我对其稍加改造后，可以这样来运行：\nshell\nnpx -p @jeff-tian/stackbit-pull stackbit-pull-json --json-file=/path/to/json</p>\n<p>这时，项目的 src/pages/posts 目录下已经有了成百上千的文件。通过 npm run develop 本地运行起来，完美！\nshell\n➜ npm run develop</p>\n<blockquote>\n<p>@jeff-tian/space@0.0.1 develop /Users/tianjef/jeff-tian/unicms-copy-01\ngatsby develop</p>\n</blockquote>\n<p>success open and validate gatsby-configs - 0.088s\nYou can now view @jeff-tian/space in the browser.\n⠀\n<a href=\"http://localhost:8000/\">http://localhost:8000/</a>\n⠀\nView GraphiQL, an in-browser IDE, to explore your sites data and schema\n⠀\n<a href=\"http://localhost:8000/___graphql\">http://localhost:8000/___graphql</a>\n⠀\nNote that the development build is not optimized.\nTo create a production build, use gatsby build</p>\n<p>打开 <a href=\"http://localhost:8000\">http://localhost:8000</a> <br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616657619347-2f2de750-55a7-4b64-8c8e-b231a1ab88a0.png#align=left&#x26;display=inline&#x26;height=964&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1928&#x26;originWidth=2720&#x26;size=3226428&#x26;status=done&#x26;style=none&#x26;width=1360\" alt=\"image.png\">\n<a name=DKdC7></a></p>\n<h4>图片 URL 替换</h4>\n<p>其实没有那么完美，比如图片全部显示不了。原因是图片上传到 BlogEngine.NET 后，其 src 被设置成了一个需要动态处理的 URL：image.axd?picture=xxxx。通过 VSCode 或者 WebStorm 这样的 IDE 打开项目，使用正则表达式做一个替换，就可以解决问题。具体的正则表达式是这样的：\nbash\n查找：(href|src)=[^]+?zizhujy.com/blog/image.axd?picture=([^]+?)</p>\n<p>替换成：$1=<a href=\"https://raw.githubusercontent.com/Jeff-Tian/blogeng\">https://raw.githubusercontent.com/Jeff-Tian/blogeng</a>\nine.net/master/Source/BlogEngine/BlogEngine.NET/App_Data/files/$2</p>\n<p>以及：\nbash\n查找: (href|src)=[^]+?zizhujy.com/BlogEngine/BlogEngine/BlogEngine.NET/image.axd?picture=([^]+?)</p>\n<p>替换成： $1=<a href=\"https://raw.githubusercontent.com/Jeff-Tian/blogengine.net/master/Source/BlogEngine/BlogEngine.NET/App_Data/files/$2\">https://raw.githubusercontent.com/Jeff-Tian/blogengine.net/master/Source/BlogEngine/BlogEngine.NET/App_Data/files/$2</a></p>\n<p><a name=hpIEY></a></p>\n<h3>上传到 github</h3>\n<p>将整个项目推到 github\nshell\ngit commit -am sync blogengine.net\ngit push -u origin master</p>\n<p><a name=EjV9M></a></p>\n<h3>netlify 自动部署</h3>\n<p>使用 github 登录 netlify，同步 github 项目。当 GitHub 项目有新的推送时，netlify 会自动生成网站并且部署：<br /><img src=\"https://cdn.nlark.com/yuque/0/2021/png/221736/1616657735012-7298e081-02fa-4a04-bea6-28b007b0d585.png#align=left&#x26;display=inline&#x26;height=695&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1390&#x26;originWidth=2654&#x26;size=298401&#x26;status=done&#x26;style=none&#x26;width=1327\" alt=\"image.png\"><br />netlify 发布成功后，就可以访问生产站点了：<a href=\"https://jeff-tian.jiwai.win\">https://jeff-tian.jiwai.win</a> 。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}