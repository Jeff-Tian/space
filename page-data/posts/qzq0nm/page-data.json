{"componentChunkName":"component---src-templates-post-js","path":"/posts/qzq0nm/","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/qzq0nm","relativePath":"posts/qzq0nm","frontmatter":{"title":"解决 IdentityServer 在多个 pod 情况下的登录失败问题","stackbit_url_path":"posts/qzq0nm","date":"2022-10-09T10:12:53","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=EGNqM></a></p>\n<h1>背景</h1>\n<p>在《<a href=\"https://zhuanlan.zhihu.com/p/482103322\">https://zhuanlan.zhihu.com/p/482103322</a>》中，我将 IdentityServer demo 应用免费部署到了 Azure Apps：<a href=\"https://id6.azurewebsites.net/Account/Login\">https://id6.azurewebsites.net/Account/Login</a>。<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.486486486486484%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABKUlEQVR42oWRy47UMBBF8/8/w3pGsEFijTRLmhaDGKUnLztuv8uOD0oiQAgQVzq6tbBdt8rdmyfF+6vh3dXzeLG8/ewOHi6Oj33kOkcuU+RZy1/5ooWvWvjw7Hn4ZOmmaYZkAQEaSIYmUDPZW2pO1LzXjprS4SUlJPifTtv4oa4fF4wxOO+xNtB/W1h1YNWeZTIY7bBrIDoh+fLLQyUniHEjhEaMjRQq3ThppmlEpFBKQdvAPRb+py147GvP7TYzDgqnVqiVTqkzYa2VnIXVel6XFesjMcajyW9q7XzQO+79C8ttOLiPA5Iinbkbtu3cwX5Z2cjNJLRLiAilVOSgHPV+dqf9I3k3LIoicnatlUkZRm0JwZ8Jc2VePC/DjNIrIYRjmv0DW/uT787OHNNhdeNJAAAAAElFTkSuQmCC'); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/cab32710460b3b1452619f490c75fd62/fcda8/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png\"\n        srcset=\"/static/cab32710460b3b1452619f490c75fd62/12f09/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png 148w,\n/static/cab32710460b3b1452619f490c75fd62/e4a3f/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png 295w,\n/static/cab32710460b3b1452619f490c75fd62/fcda8/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png 590w,\n/static/cab32710460b3b1452619f490c75fd62/efc66/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png 885w,\n/static/cab32710460b3b1452619f490c75fd62/c83ae/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png 1180w,\n/static/cab32710460b3b1452619f490c75fd62/f29ed/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png 2948w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>它运行得非常好。后来又如法炮制，将它部署到了 Kubernetes 集群中，经过测试没有问题，就上线到了正式的 Kubernetes 集群里。有意思的事情来了，线上登录体验非常不稳定，一会儿成功，一会儿失败。</p>\n<p>shell</p>\n<p>[2022-07-21 09:36:52 Error] Microsoft.AspNetCore.Antiforgery.DefaultAntiforgery\nAn exception was thrown while deserializing the token.\nMicrosoft.AspNetCore.Antiforgery.AntiforgeryValidationException: The antiforgery token could not be decrypted.\n---> System.Security.Cryptography.CryptographicException: The key {bfd0404c-d5e6-46ea-8e9b-05fe8e75985a} was not found in the key ring. For more information go to <a href=\"http://aka.ms/dataprotectionwarning\">http://aka.ms/dataprotectionwarning</a>\nat Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtector.UnprotectCore(Byte[] protectedData, Boolean allowOperationsOnRevokedKeys, UnprotectStatus&#x26; status)\nat Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtector.Unprotect(Byte[] protectedData)\nat Microsoft.AspNetCore.Antiforgery.DefaultAntiforgeryTokenSerializer.Deserialize(String serializedToken)\n--- End of inner exception stack trace ---\nat Microsoft.AspNetCore.Antiforgery.DefaultAntiforgeryTokenSerializer.Deserialize(String serializedToken)\nat Microsoft.AspNetCore.Antiforgery.DefaultAntiforgery.GetCookieTokenDoesNotThrow(HttpContext httpContext)</p>\n<p>[2022-07-21 09:36:52 Information] Serilog.AspNetCore.RequestLoggingMiddleware\nHTTP GET /Account/Login?ReturnUrl=%2Fciba%2Fall responded 200 in 1.7119 ms</p>\n<p><a name=G32bk></a></p>\n<h1>分析</h1>\n<p>既然在多个测试环境都没问题，在线上环境有问题，那肯定是线上有什么特殊的地方。没错，线上的 pod 数量不只一个，而测试环境都只有一个应用实例在运行。很不幸的是，这个 IdentityServer Demo 是一个有状态的服务，如果第一次请求连接到了 pod 1 实例，而下一个请求（带有 cookie）却打到了 pod 2 实例，就会出错。</p>\n<p>从出错的日志上看，是 key ring 中找不到某个 key，而这个信息应该是保存在服务实例所在的进程的内存中的。不同的进程间的内存是不共享的，要解决这个问题，有三种方法。</p>\n<p><a name=uTZxz></a></p>\n<h1>解决</h1>\n<p><a name=u8B79></a></p>\n<h2>保持一个实例</h2>\n<p>这是最快的解决方法，只需要将副本数设置为 1 即可。这是在线上故障后立即采取的措施，先保证 Demo 正常进行。</p>\n<p><a name=QWyD4></a></p>\n<h2>Session Sticky</h2>\n<p>如果 Demo 有价值，还值得继续投入，可以先考虑 Session Sticky 方案。如果 Kuberetes 集群中使用了 Istio Ingress，那么可以参考 <a href=\"https://istio.io/latest/docs/reference/config/networking/destination-rule/#LocalityLoadBalancerSetting-Distribute\">https://istio.io/latest/docs/reference/config/networking/destination-rule/#LocalityLoadBalancerSetting-Distribute</a> 来设置一个 Session Sticky，让流量根据某个规则，保证同一个用户的请求总是打到同一个服务实例，从而可以从内存中找到相应的 key。</p>\n<p>可以通过 Chrome 的开发者工具观察请求响应头，如果带有 istio-envoy 等标志就知道的确是使用了 Istio Ingress 了：<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVR42n2SXU/CMBSG9/9/g//AK++94sIQoxGMgggDHPtwbGNsLWPt1j1mFYyGxCZvTpP2PDnv2zpaa7RuqKqKMIwIowjfDyiFoChLylLQ3/lvdV33s3eUUvRqmgbP2+AuV6xWH7b2mrtLdnnO63RGkmYsFkueRs9s/JB8X9hhfkMdfQZqTRzHeJ5na13XdrL6dC6Kklpp+jZzApz1F9hbNh3KdHhhxHa3J85yikOFrCqKokTKw7cf09K5UxgPQQoLvwCq+oheL9DuG97dgHT0QDZ+REzGdEWO6bCN3N7A9RU838PxcJHhWY5WNTqJaZJPtvMZweSFZPFOMp+RRiHpLidJUrLhgCwM6BPTreGcfdu2f+COspYNdWtY+wEzd8Vk7rLc+Kw3PkEY2dcuVEMpD0ghkFKefoGgOh5pW2PBvb4AvbAYGddmDr4AAAAASUVORK5CYII='); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/4a9b83f9e9ac1dec2caaaa239e9e95c5/fcda8/1665310876379-bd5fe568-5085-444f-8a62-de168f97fa62.png\"\n        srcset=\"/static/4a9b83f9e9ac1dec2caaaa239e9e95c5/12f09/1665310876379-bd5fe568-5085-444f-8a62-de168f97fa62.png 148w,\n/static/4a9b83f9e9ac1dec2caaaa239e9e95c5/e4a3f/1665310876379-bd5fe568-5085-444f-8a62-de168f97fa62.png 295w,\n/static/4a9b83f9e9ac1dec2caaaa239e9e95c5/fcda8/1665310876379-bd5fe568-5085-444f-8a62-de168f97fa62.png 590w,\n/static/4a9b83f9e9ac1dec2caaaa239e9e95c5/d0e73/1665310876379-bd5fe568-5085-444f-8a62-de168f97fa62.png 671w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\n<a name=vXW4M></a></p>\n<h3>ip 地址</h3>\n<p>根据请求中携带的来源 ip 地址，来映射到具体的服务实例，不推荐使用。一旦用户的出口 ip 地址是动态的，这个 Session Sticky 方案就会失效。</p>\n<p><a name=jWJdO></a></p>\n<h3>cookie</h3>\n<p>对于 IdentityServer Demo 应用，它会给每个用户（客户端）分配一个 idsrv的 cookie 值（参见上图的请求响应头中的 set-cookie），通过它来设置 Session Sticky 是有效的，推荐使用：</p>\n<p>yaml\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\nname: identity-server-demo\nspec:\nhost: id6.prod.svc.cluster.local\ntrafficPolicy:\nloadBalancer:\nconsistentHash:\nhttpCookie:\nname: idsrv\nttl: 0s</p>\n<p><a name=vDwOi></a></p>\n<h2>服务无状态化</h2>\n<p>这是最推荐的方案，但是需要改代码，工作量最大。假如 Demo 通过了，要真正开始投入开发，那就可以采用该方案了。\n<a name=rHc26></a></p>\n<h3>二次分析</h3>\n<p>之所以出现多服务实例下，应用表现不正常的情况，是因为应用有状态。具体到 IdentityServer Demo 应用，它使用了 ASP.NET Core 的分布式缓存。</p>\n<p><a name=QkwEh></a></p>\n<h4>分布式缓存</h4>\n<p>分布式缓存是用来给多服务实例共享的缓存，是外部化的，从应用剥离出来的。将缓存分布式存储有如下好处：</p>\n<ul>\n<li>在跨多个服务实例间的多个请求中保证数据的一致性</li>\n<li>不受服务器重启的影响</li>\n<li>不受应用发布的影响</li>\n<li>不使用本地存储</li>\n</ul>\n<p>既然如此，为什么 IdentityServer Demo 应用中使用的分布式缓存反而在多服务实例的情况下出了问题呢？原因是使用了假的分布式缓存！</p>\n<p>具体到 ASP.NET Core，这个分布式缓存表现为了一个接口： IDistributedCache，在 Program.cs 中需要注册一个该接口的实例。官方框架给这个接口写了 4 个实现：</p>\n<ul>\n<li>分布式内存缓存（假的，只是名字叫分布式）</li>\n<li>分布式 SQL Server 缓存</li>\n<li>分布式 Redis 缓存</li>\n<li>分布式 NCache 缓存</li>\n</ul>\n<p>从以上 4 个实现可以看出，除了第一个，其他的都有框架之外的依赖，显然是不适合 Demo 应用的。Demo 为了简单，采用了内存缓存，它只是实现了 IDistributedCache的接口，却并没有真正实现分布式的功能。它在开发和测试场景下是适用的，在生产环境，如果只有一个实例，并且内存足够的情况下也是适用的。</p>\n<p>但如果是多服务实例的情况下，就应该切换到真正的分布式缓存中。最推荐的是分布式 Redis 缓存，这当然需要引入 Redis。\ncsharp\nbuilder.Services.AddStackExchangeRedisCache(options =>\n{\noptions.Configuration = builder.Configuration.GetConnectionString(MyRedisConStr);\noptions.InstanceName = SampleInstance;\n});</p>\n<p>当然也可以使用其他的分布式缓存组件。除了官方的，还有一些其他开源的 ASP.NET Core 分布式缓存组件的实现，比如分布式 PostgreSQL 缓存： Community.Microsoft.Extensions.Caching.PostgreSql。\nxml\n<PackageReference Include=Community.Microsoft.Extensions.Caching.PostgreSql Version=3.1.2 /></p>\n<p>csharp\nusing Community.Microsoft.Extensions.Caching.PostgreSql;</p>\n<pre><code>    builder.Services.AddDistributedPostgreSqlCache(setup =>\n    {\n        setup.ConnectionString = connectionString;\n        setup.SchemaName = public;\n        setup.TableName = distcache; // 注意，这里要用小写！\n        setup.DisableRemoveExpired = true;\n        // Optional - DisableRemoveExpired default is FALSE\n        setup.CreateInfrastructure = true;\n        // CreateInfrastructure is optional, default is TRUE\n        // This means que every time starts the application the \n        // creation of table and database functions will be verified.\n        setup.ExpiredItemsDeletionInterval = TimeSpan.FromMinutes(30);\n        // ExpiredItemsDeletionInterval is optional\n        // This is the periodic interval to scan and delete expired items in the cache. Default is 30 minutes. \n        // Minimum allowed is 5 minutes. - If you need less than this please share your use case 😁, just for curiosity...\n    });\n</code></pre>\n<p>以上给出了使用这个开源的分布式 PostgreSQL 缓存的用法，尤其提醒，对于 TableName 一定要全部小写！以上代码配置了分布式 PostgreSQL 缓存，在应用启动时就去检查缓存表有没有建立好，如果没有的话，就会去创建缓存表。但我还不清楚什么原因，即使用了大写，最终也会创建出名字为小写的缓存表。但是在做缓存查询时，用大写的话就会出现 Relation DistCache 不存在这样的错误。</p>\n<p>总之，在分布式 PostgreSQL 缓存机制建立好后，应用就会保证创建缓存表，并且会往缓存表里读写数据：<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2cddc2968a41f1d4e3154c489ec46bff/302a4/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 95.27027027027027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAADBklEQVR42o2U2VLjOhRF/f//dOGl+wUyEEgIMZ6neFYwTux4WrckNw1dRde9rlp1jrYS+XjrSJrvl5hmThgWuG6JYcQ4Toxtp9i2j2FYiqIQuK7P5dIwjjAM07dod3cxP364/PwZcHtrsNmccByw7QnLAtMEw5g5HHoMY/pD+4rUtd0u4/k5wzRP6HqJbV/w/QHLGgiCjjQdybKJJOlVHsc9x2NHHHcqfkVq2n4veHkR2HZNHJ9VdWF4Zrs90TQjp1NBkhxp2wvn8zvj2AMTMH6LJv2QtC30I3Q91HVFVRV03ZUg8BBC0DQtLy8v1PUZ+UzT92hJ8kaWlYgyo8tT+jIjTVNEVdG2LWHYMwyot1+vLeM4/Krwe7TX1wbLHvC8AcccsI0B3x9xvVFpljXhujIf8X3wvEnN6/rIfj+q3PM+0XT9wm5XcDgINo85q3XKdpsqX123Iwgmjke5GTMfufyzaY4kyeecRPP9N1arJcvlPbq+x3UtbNukKBLyvMNxJqpqpCxnimLk7W2mruexEJ+aJpt6uVyxWq3YbnfK+P1+j+NYyJft9zXH4zu+/04QzDGK5vyrLjWJ5jiC1WrNw8MDh8MB27axLIs0PRJFDYbRq/6SPSnx/Y4wnEmSOcoejKI5aq77xtPTTlUoqzNNE9O0EEL2X4vn9ZRlR1XNCNGpcVn2vzmdevK8J8t62dgRNze33Nz8w2KxUJWu12teXw/oesZmI1ivSxYLwcNDqfK7O8HTU4llFZhmgW0Xv3PNsgSLxYr7+3uen59VhfLToyggTVu10x/VSd7fZ87njuv1StPMtO1VjZWHclOWyyWPj49qMbkpvu+Rphe1oPTQ82YP5Vj6JnPp2Yf+4atmmiWbzZNqHbmYrNBxXMoyx/NqDocLx2NNmsqzXhOGNUEwR6lLTc5F0axp8pzquk5dyx8GDMNAGIbkeU7TNOpz0nRQxsPw6xIYFNP0yYemCVFTFIU6t4ZhcD6fieOYLMsoy1Iter1OXK/jXy+EPy6HquJ/P9M0/Sf/AskFlRYVX53lAAAAAElFTkSuQmCC'); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/2cddc2968a41f1d4e3154c489ec46bff/fcda8/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png\"\n        srcset=\"/static/2cddc2968a41f1d4e3154c489ec46bff/12f09/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png 148w,\n/static/2cddc2968a41f1d4e3154c489ec46bff/e4a3f/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png 295w,\n/static/2cddc2968a41f1d4e3154c489ec46bff/fcda8/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png 590w,\n/static/2cddc2968a41f1d4e3154c489ec46bff/efc66/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png 885w,\n/static/2cddc2968a41f1d4e3154c489ec46bff/302a4/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png 1080w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>在将分布式缓存真的实现后，即使没有 Session Sticky，也不会出现登录时好时坏的问题了。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[],"slicesMap":{}}