{"componentChunkName":"component---src-templates-post-js","path":"/posts/qzq0nm","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/qzq0nm","relativePath":"posts/qzq0nm","frontmatter":{"title":"解决 IdentityServer 在多个 pod 情况下的登录失败问题","stackbit_url_path":"posts/qzq0nm","date":"2022-10-09T10:12:53","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p><a name=EGNqM></a></p>\n<h1>背景</h1>\n<p>在《<a href=\"https://zhuanlan.zhihu.com/p/482103322\">https://zhuanlan.zhihu.com/p/482103322</a>》中，我将 IdentityServer demo 应用免费部署到了 Azure Apps：<a href=\"https://id6.azurewebsites.net/Account/Login\">https://id6.azurewebsites.net/Account/Login</a>。<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665302459651-887ddc3a-192b-47ae-8ae1-585df34072d6.png#clientId=ubda7a3d8-3e17-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=540&#x26;id=u757fbb5a&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1080&#x26;originWidth=2948&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=341260&#x26;status=done&#x26;style=none&#x26;taskId=u1feb8ee8-62bd-4aec-9ac8-27af80bdd84&#x26;title=&#x26;width=1474\" alt=\"image.png\"></p>\n<p>它运行得非常好。后来又如法炮制，将它部署到了 Kubernetes 集群中，经过测试没有问题，就上线到了正式的 Kubernetes 集群里。有意思的事情来了，线上登录体验非常不稳定，一会儿成功，一会儿失败。</p>\n<p>shell</p>\n<p>[2022-07-21 09:36:52 Error] Microsoft.AspNetCore.Antiforgery.DefaultAntiforgery\nAn exception was thrown while deserializing the token.\nMicrosoft.AspNetCore.Antiforgery.AntiforgeryValidationException: The antiforgery token could not be decrypted.\n---> System.Security.Cryptography.CryptographicException: The key {bfd0404c-d5e6-46ea-8e9b-05fe8e75985a} was not found in the key ring. For more information go to <a href=\"http://aka.ms/dataprotectionwarning\">http://aka.ms/dataprotectionwarning</a>\nat Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtector.UnprotectCore(Byte[] protectedData, Boolean allowOperationsOnRevokedKeys, UnprotectStatus&#x26; status)\nat Microsoft.AspNetCore.DataProtection.KeyManagement.KeyRingBasedDataProtector.Unprotect(Byte[] protectedData)\nat Microsoft.AspNetCore.Antiforgery.DefaultAntiforgeryTokenSerializer.Deserialize(String serializedToken)\n--- End of inner exception stack trace ---\nat Microsoft.AspNetCore.Antiforgery.DefaultAntiforgeryTokenSerializer.Deserialize(String serializedToken)\nat Microsoft.AspNetCore.Antiforgery.DefaultAntiforgery.GetCookieTokenDoesNotThrow(HttpContext httpContext)</p>\n<p>[2022-07-21 09:36:52 Information] Serilog.AspNetCore.RequestLoggingMiddleware\nHTTP GET /Account/Login?ReturnUrl=%2Fciba%2Fall responded 200 in 1.7119 ms</p>\n<p><a name=G32bk></a></p>\n<h1>分析</h1>\n<p>既然在多个测试环境都没问题，在线上环境有问题，那肯定是线上有什么特殊的地方。没错，线上的 pod 数量不只一个，而测试环境都只有一个应用实例在运行。很不幸的是，这个 IdentityServer Demo 是一个有状态的服务，如果第一次请求连接到了 pod 1 实例，而下一个请求（带有 cookie）却打到了 pod 2 实例，就会出错。</p>\n<p>从出错的日志上看，是 key ring 中找不到某个 key，而这个信息应该是保存在服务实例所在的进程的内存中的。不同的进程间的内存是不共享的，要解决这个问题，有三种方法。</p>\n<p><a name=uTZxz></a></p>\n<h1>解决</h1>\n<p><a name=u8B79></a></p>\n<h2>保持一个实例</h2>\n<p>这是最快的解决方法，只需要将副本数设置为 1 即可。这是在线上故障后立即采取的措施，先保证 Demo 正常进行。</p>\n<p><a name=QWyD4></a></p>\n<h2>Session Sticky</h2>\n<p>如果 Demo 有价值，还值得继续投入，可以先考虑 Session Sticky 方案。如果 Kuberetes 集群中使用了 Istio Ingress，那么可以参考 <a href=\"https://istio.io/latest/docs/reference/config/networking/destination-rule/#LocalityLoadBalancerSetting-Distribute\">https://istio.io/latest/docs/reference/config/networking/destination-rule/#LocalityLoadBalancerSetting-Distribute</a> 来设置一个 Session Sticky，让流量根据某个规则，保证同一个用户的请求总是打到同一个服务实例，从而可以从内存中找到相应的 key。</p>\n<p>可以通过 Chrome 的开发者工具观察请求响应头，如果带有 istio-envoy 等标志就知道的确是使用了 Istio Ingress 了：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665310876379-bd5fe568-5085-444f-8a62-de168f97fa62.png#clientId=u9119dcd7-82d2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=ue6db8b56&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=250&#x26;originWidth=671&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=46150&#x26;status=done&#x26;style=none&#x26;taskId=ub3864427-4edd-48b2-be16-bedc4894892&#x26;title=\" alt=\"image.png\">\n<a name=vXW4M></a></p>\n<h3>ip 地址</h3>\n<p>根据请求中携带的来源 ip 地址，来映射到具体的服务实例，不推荐使用。一旦用户的出口 ip 地址是动态的，这个 Session Sticky 方案就会失效。</p>\n<p><a name=jWJdO></a></p>\n<h3>cookie</h3>\n<p>对于 IdentityServer Demo 应用，它会给每个用户（客户端）分配一个 idsrv的 cookie 值（参见上图的请求响应头中的 set-cookie），通过它来设置 Session Sticky 是有效的，推荐使用：</p>\n<p>yaml\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\nname: identity-server-demo\nspec:\nhost: id6.prod.svc.cluster.local\ntrafficPolicy:\nloadBalancer:\nconsistentHash:\nhttpCookie:\nname: idsrv\nttl: 0s</p>\n<p><a name=vDwOi></a></p>\n<h2>服务无状态化</h2>\n<p>这是最推荐的方案，但是需要改代码，工作量最大。假如 Demo 通过了，要真正开始投入开发，那就可以采用该方案了。\n<a name=rHc26></a></p>\n<h3>二次分析</h3>\n<p>之所以出现多服务实例下，应用表现不正常的情况，是因为应用有状态。具体到 IdentityServer Demo 应用，它使用了 ASP.NET Core 的分布式缓存。</p>\n<p><a name=QkwEh></a></p>\n<h4>分布式缓存</h4>\n<p>分布式缓存是用来给多服务实例共享的缓存，是外部化的，从应用剥离出来的。将缓存分布式存储有如下好处：</p>\n<ul>\n<li>在跨多个服务实例间的多个请求中保证数据的一致性</li>\n<li>不受服务器重启的影响</li>\n<li>不受应用发布的影响</li>\n<li>不使用本地存储</li>\n</ul>\n<p>既然如此，为什么 IdentityServer Demo 应用中使用的分布式缓存反而在多服务实例的情况下出了问题呢？原因是使用了假的分布式缓存！</p>\n<p>具体到 ASP.NET Core，这个分布式缓存表现为了一个接口： IDistributedCache，在 Program.cs 中需要注册一个该接口的实例。官方框架给这个接口写了 4 个实现：</p>\n<ul>\n<li>分布式内存缓存（假的，只是名字叫分布式）</li>\n<li>分布式 SQL Server 缓存</li>\n<li>分布式 Redis 缓存</li>\n<li>分布式 NCache 缓存</li>\n</ul>\n<p>从以上 4 个实现可以看出，除了第一个，其他的都有框架之外的依赖，显然是不适合 Demo 应用的。Demo 为了简单，采用了内存缓存，它只是实现了 IDistributedCache的接口，却并没有真正实现分布式的功能。它在开发和测试场景下是适用的，在生产环境，如果只有一个实例，并且内存足够的情况下也是适用的。</p>\n<p>但如果是多服务实例的情况下，就应该切换到真正的分布式缓存中。最推荐的是分布式 Redis 缓存，这当然需要引入 Redis。\ncsharp\nbuilder.Services.AddStackExchangeRedisCache(options =>\n{\noptions.Configuration = builder.Configuration.GetConnectionString(MyRedisConStr);\noptions.InstanceName = SampleInstance;\n});</p>\n<p>当然也可以使用其他的分布式缓存组件。除了官方的，还有一些其他开源的 ASP.NET Core 分布式缓存组件的实现，比如分布式 PostgreSQL 缓存： Community.Microsoft.Extensions.Caching.PostgreSql。\nxml\n<PackageReference Include=Community.Microsoft.Extensions.Caching.PostgreSql Version=3.1.2 /></p>\n<p>csharp\nusing Community.Microsoft.Extensions.Caching.PostgreSql;</p>\n<pre><code>    builder.Services.AddDistributedPostgreSqlCache(setup =>\n    {\n        setup.ConnectionString = connectionString;\n        setup.SchemaName = public;\n        setup.TableName = distcache; // 注意，这里要用小写！\n        setup.DisableRemoveExpired = true;\n        // Optional - DisableRemoveExpired default is FALSE\n        setup.CreateInfrastructure = true;\n        // CreateInfrastructure is optional, default is TRUE\n        // This means que every time starts the application the \n        // creation of table and database functions will be verified.\n        setup.ExpiredItemsDeletionInterval = TimeSpan.FromMinutes(30);\n        // ExpiredItemsDeletionInterval is optional\n        // This is the periodic interval to scan and delete expired items in the cache. Default is 30 minutes. \n        // Minimum allowed is 5 minutes. - If you need less than this please share your use case 😁, just for curiosity...\n    });\n</code></pre>\n<p>以上给出了使用这个开源的分布式 PostgreSQL 缓存的用法，尤其提醒，对于 TableName 一定要全部小写！以上代码配置了分布式 PostgreSQL 缓存，在应用启动时就去检查缓存表有没有建立好，如果没有的话，就会去创建缓存表。但我还不清楚什么原因，即使用了大写，最终也会创建出名字为小写的缓存表。但是在做缓存查询时，用大写的话就会出现 Relation DistCache 不存在这样的错误。</p>\n<p>总之，在分布式 PostgreSQL 缓存机制建立好后，应用就会保证创建缓存表，并且会往缓存表里读写数据：<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/221736/1665310225631-b7c4cfc4-088d-4bb5-bc95-b43da9e79732.png#clientId=u9119dcd7-82d2-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=u2067447d&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=1029&#x26;originWidth=1080&#x26;originalType=binary%E2%88%B6=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=237664&#x26;status=done&#x26;style=none&#x26;taskId=uc5e8822c-7536-4425-8020-adfac4759e6&#x26;title=\" alt=\"image.png\"></p>\n<p>在将分布式缓存真的实现后，即使没有 Session Sticky，也不会出现登录时好时坏的问题了。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[]}