{"componentChunkName":"component---src-templates-post-js","path":"/posts/prfyg64sbttmi8ea/","result":{"data":{"sitePage":null},"pageContext":{"url":"posts/prfyg64sbttmi8ea","relativePath":"posts/prfyg64sbttmi8ea","frontmatter":{"title":"对接微信登录的三种方式","stackbit_url_path":"posts/prfyg64sbttmi8ea","date":"2023-10-01T04:05:34","excerpt":"","tags":[],"categories":[],"template":"post"},"html":"<p>由于使用者的增加，特别是“答疑家”的使用，被提出了一些新的需求。于是最近又对 <a href=\"https://github.com/Jeff-Tian/keycloak-services-social-weixin\">https://github.com/Jeff-Tian/keycloak-services-social-weixin</a> 增加了普通的 PC 端扫码登录、和手机微信登录两种方式。如《<a href=\"https://zhuanlan.zhihu.com/p/652566471\">【继续更新】尝试在 Keycloak 里打通整个微信生态 - Jeff Tian的文章 - 知乎 </a> 》所述。总之，配置更复杂了，这是为什么呢？主要是因为对接微信登录的方式有多种，目前我借助这个项目，摸清了 3 种，这里再统一梳理一下。\n<a name=agBRo></a></p>\n<h1>登录原理概览</h1>\n<p>这里先对原理做个概述，后面会详细介绍。一般来说，要接入微信或者任何第三方登录，都是推荐 OAuth 2.0/OIDC 标准协议的。这样的标准协议本身内容很多，但局限在基于浏览器（无论是手机 Web 还是 PC Web）的开放登录来说，就很简单，固定了一个套路，即：</p>\n<ul>\n<li>先构建第三方网站的授权链接，让用户在浏览器里打开并确认授权</li>\n<li>通过用户的授权，第三方网站颁发一个授权码，通过浏览器重定向传递给接入方</li>\n<li>接入入凭借这个授权码，和自己在第三方平台上的备案凭据（appid + appsecret），通过后端服务器向第三方服务器换取用户的令牌</li>\n<li>后续通过令牌调用第三方服务，比如获取用户资料等</li>\n</ul>\n<p>更详细的流程可以参考：</p>\n<ul>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/488194876\">OAuth 2.0：对接 Keycloak 设备码授权流程 - Jeff Tian的文章 - 知乎 </a> 》</li>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/594742263\">OAuth 2.0：对接 IdentityServer 设备码授权流程 - Jeff Tian的文章 - 知乎 </a> 》</li>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/597052710\">Keycloak 使用授权码换取令牌过程详解 - Jeff Tian的文章 - 知乎 </a> 》</li>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/621445646\">OIDC （OAuth 2.0）授权码许可流程详解：纸上得来终觉浅，绝知此事得写个测试 - Jeff Tian的文章 - 知乎 </a> 》</li>\n</ul>\n<p><a name=nuADm></a></p>\n<h2>构建授权链接</h2>\n<p>对于微信生态，它有两套体系（严格来说是至少两套），分别是开放平台和公众平台。在构建授权链接这一步，取决于你接入的体系，会有对应的链接。PC Web 接入的是开放平台，而手机 Web 接入的是公众平台（当然，手机 Web 其实也可以接入开放平台，但是不推荐！）。<br />比如对于 PC 来说，一般来说，第三方网站的授权链接页面，会展示说哪个接入方想要获取你的什么数据，你同意吗？并展示一个同意或者拒绝的按钮在页面上。而对于微信，它在授权链接网页页面展示的却是一个二维码，用户是否同意，要通过手机扫完这个二维码后，在手机上才能看到。虽然比较特殊，但仍然是一个标准的 OAuth 2.0/OIDC。<br />对于 PC Web 来说，一个典型的授权链接是：\nshell\n<a href=\"https://open.weixin.qq.com/connect/qrconnect?scope=snsapi_login&#x26;state=d3Yvfou3pdgp-UNVZ-i7DTDEbv4rZTWx6Wh7lmxzyvk.98VO-haMdj4.c0L0bnybTEatKpqInU02nQ&#x26;response_type=code&#x26;appid=wxc09e145146844e43&#x26;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Frealms%2Fmaster%2Fbroker%2Fweixin%2Fendpoint\">https://open.weixin.qq.com/connect/qrconnect?scope=snsapi_login&#x26;state=d3Yvfou3pdgp-UNVZ-i7DTDEbv4rZTWx6Wh7lmxzyvk.98VO-haMdj4.c0L0bnybTEatKpqInU02nQ&#x26;response_type=code&#x26;appid=wxc09e145146844e43&#x26;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Frealms%2Fmaster%2Fbroker%2Fweixin%2Fendpoint</a></p>\n<p>前面为什么说，手机 Web 不能接入开放平台呢？因为在手机 Web 页上展示一个二维码，让用户来扫码确认，操作上不方便。因此手机端一般使用公众平台，对于这种情况，用户可以直接在微信里打开该链接，并进行授权（显式的或者隐式的），然后微信会颁发授权码再跳转到接入方，也是一个标准的 OAuth 2.0/OIDC 流程。一个典型的手机端授权链接是：\nshell\n<a href=\"https://open.weixin.qq.com/connect/oauth2/authorize?scope=...&#x26;state=...&#x26;response_type=code&#x26;appid=...&#x26;redirect_uri=\">https://open.weixin.qq.com/connect/oauth2/authorize?scope=...&#x26;state=...&#x26;response_type=code&#x26;appid=...&#x26;redirect_uri=</a>...</p>\n<p>注意这两个链接不太一样，因为是两套体系。不过，其主机名都是 open.weixin.qq.com，因为这都是微信的开放能力。\n<a name=Wre2N></a></p>\n<h2>授权码传递回接入方</h2>\n<p>这是为什么在第一步的构建授权链接里，需要传递一个 redirect_uri 的原因。\n<a name=BPBu5></a></p>\n<h2>使用授权码换取令牌</h2>\n<p>接入方在拿到了授权码之后，就可以通过授权码加上自己在微信的公众平台或者开放平台里备案凭据（appid + appsecret）换取用户的令牌了。\n<a name=HlFVX></a></p>\n<h2>使用用户令牌换取用户信息</h2>\n<p>接入方通过前一步拿到的用户令牌，就可以通过如下接口获取到用户信息了：\nshell\n<a href=\"https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&#x26;openid=OPENID%E2%9F%A8=zh_CN\">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&#x26;openid=OPENID⟨=zh_CN</a></p>\n<p>注意，这一步，不管你接入哪套体系，都建议你用上述 URL 获取用户信息。授权链接的不同，已经让人很头大了，在了换取用户信息环节，能统一就统一吧。<br />以上接口，还有一个好处，它只检验令牌是否有效，而不检验令牌的获取方式 ，然后只需要有 openid，就能获取该 openid 对应用户的信息。通过这一点，可以用来自定义登录方式，比如公众号关注即登录。\n<a name=wNl5Z></a></p>\n<h2>自定义微信登录方式（以关注即登录举例）</h2>\n<p>由于没有标准的束缚，所以可以自由发挥，但这也带来了开发量，详见后面的叙述。这里讨论一下和标准流程的区别。<br />最大的区别是没有了授权码传递环节，也没有构建授权链接的环节。总之它通过某种方式拿到了用户的 openid（即通过微信服务发来的扫码消息中解析到的 openid）。<br />另外，它通过在公众平台里备案的客户端凭据，换取到了客户端级别的令牌（注意，前面描述的标准 OAuth 2.0/OIDC 流程拿到的是用户级别的令牌）。<br />通过令牌和 openid，就足以获取到用户信息了，于是可以为其创建接入方的会话了：\nshell\n<a href=\"https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&#x26;openid=OPENID%E2%9F%A8=zh_CN\">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&#x26;openid=OPENID⟨=zh_CN</a></p>\n<p>下面来详述一下这三种登录方式。\n<a name=JZWDr></a></p>\n<h1>三种微信登录</h1>\n<p><a name=g9GmK></a></p>\n<h2>微信公众号关注即登录</h2>\n<p>这是 <a href=\"https://github.com/Jeff-Tian/keycloak-services-social-weixin\">https://github.com/Jeff-Tian/keycloak-services-social-weixin</a> 最早实现的一种登录方式，也是比较不常见的一种。第一次实现它时，只是为了好玩，因为那时候并不多见。不过很多年过去了，目前通过这个方案来登录的网站越来越多。<br />最早看到各大网站的 PC 端微信扫码登录，觉得有些别扭。因为我那时对微信生态完全陌生，就纯粹从用户的角度，在扫码登录时总感觉有些别扭。那时候，一般网站的右下角都会放置一个该网站的公众号二维码，而在登录时，也会被要求扫一个二维码。但是使用下来发现，即使登录了该网站，还是要单独再扫一次码才能关注该网站的公众号。不知道别人是什么感受，反正这种迷惑行为让我十分费解。<br />当时（2018 年）的直觉就是，应该将关注公众号和扫码登录结合起来，于是就开始了解微信开发相关的东西。并且，由于搜索了一下登录相关的开源库，才得知有 Keycloak，将 Keycloak 和微信接合起来搜索，就找到了 <a href=\"https://github.com/jyqq163/keycloak-services-social-weixin\">jyqq163/keycloak-services-social-weixin</a> 这个库。不过，试用下来发现该库也是那种普通的扫码登录，于是只能硬着头皮阅读微信的开发文档，并将该库 fork 下来，做了修改以实现了微信公众号关注即登录功能，详见《<a href=\"https://zhuanlan.zhihu.com/p/349504145\">基于 keycloak 的关注公众号即登录功能的设计与实现 - Jeff Tian的文章 - 知乎</a> 》。</p>\n<p><a name=fck25></a></p>\n<h3>原理</h3>\n<p>这样实现的微信登录，原理是利用了微信公众平台的带参二维码功能。这里的重点有两个：</p>\n<ul>\n<li>使用的微信公众号平台</li>\n<li>使用的带参二维码。<br />这意味着登录流程和 OAuth、OIDC 等完全没有关系了，因此是一个微信独有的，非标准登录流程。实现上也可以尽情发挥，现在各大平台都有自己的实现。我个人出于兴趣，除了利用 Keycloak 之外，还有一个基于 Spring Security 的实现，见《<a href=\"https://zhuanlan.zhihu.com/p/393360806\">基于 Java Spring Security 的关注微信公众号即登录的设计与实现 - Jeff Tian的文章 - 知乎 </a> 》。除此之外，还力荐 Authing.cn 所提供的方案：《<a href=\"https://zhuanlan.zhihu.com/p/611478727\">基于 Authing.cn 的关注微信公众号登录的实现方案，以及和其他方案的对比 - Jeff Tian的文章 - 知乎 </a> 》</li>\n</ul>\n<p><a name=LniHW></a></p>\n<h3>关键</h3>\n<p>由于要实现扫码感知，就需要一种机制接收微信服务发过来的 xml 消息。微信的公众号后台，有一个基本配置，在这里，有一个服务器配置，就是用来配置接收微信服务的消息用的：<br /><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNUlEQVR42m2SDW7DIAyFe//rbReo1HVrEkoIYPvZhmy0nfb79IRkic/G2AcWvcZUSQQGQFW9tZwLEZVKUFNVAGYKmEKZwSy997TlAzHCNVYSFm2t7fvee4cqMxOLmd/t/jjdm5n33teUD5UkXNctV6gT8bKEuCYD9keiHzbzWslVe7vBAnu7zGkrUAeQc8Z0octbLZmI3H3/ptaaDnLkDSEeWHSaQyUBTERKyXvzl/P56fn5eDwS8b2R7yn2W/iA5xhrJVhj5mmaBGCi0+k0z7OZUa2/6v+AX9ewnc/IBaolFzNj5tZaH/pT9hccllgqCwnUmEUELOI+8P/to+clxDGqJYxRQV1EQggxxpS28TGfejziKxxwXNOA01bGkoi6t0rMouaNGCw6RqDOMBb9Cm83P5bkHehoRh2oGhp7AAAAAElFTkSuQmCC'); background-size: cover; display: block; transition: opacity 0.5s 0.5s; pointer-events: none;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image.png\"\n        title=\"image.png\"\n        src=\"/static/5ce033c3fcf85e9b4c1c00b1191896ae/fcda8/1696126724135-b1047992-53b4-4722-a3f3-a228ed440f5a.png\"\n        srcset=\"/static/5ce033c3fcf85e9b4c1c00b1191896ae/12f09/1696126724135-b1047992-53b4-4722-a3f3-a228ed440f5a.png 148w,\n/static/5ce033c3fcf85e9b4c1c00b1191896ae/e4a3f/1696126724135-b1047992-53b4-4722-a3f3-a228ed440f5a.png 295w,\n/static/5ce033c3fcf85e9b4c1c00b1191896ae/fcda8/1696126724135-b1047992-53b4-4722-a3f3-a228ed440f5a.png 590w,\n/static/5ce033c3fcf85e9b4c1c00b1191896ae/efc66/1696126724135-b1047992-53b4-4722-a3f3-a228ed440f5a.png 885w,\n/static/5ce033c3fcf85e9b4c1c00b1191896ae/f32b7/1696126724135-b1047992-53b4-4722-a3f3-a228ed440f5a.png 1136w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;opacity:0;transition:opacity 0.5s;color:inherit;box-shadow:inset 0px 0px 0px 400px white;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span><br />比如你用了<a href=\"https://github.com/Jeff-Tian/keycloak-services-social-weixin\">https://github.com/Jeff-Tian/keycloak-services-social-weixin</a>，并部署到了 <a href=\"https://keycloak.jiwai.win%EF%BC%8C%E4%B8%BA%E4%BA%86%E8%AE%A9%E5%AE%83%E6%94%B6%E5%88%B0%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E5%B0%86%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E5%8F%91%E5%88%B0%E5%A6%82%E4%B8%8B\">https://keycloak.jiwai.win，为了让它收到微信消息，就需要将微信消息发到如下</a> URL：<br /><a href=\"https://keycloak.jiwai.win/realms/Brickverse/QrCodeResourceProviderFactory/mp-qr-status\">https://keycloak.jiwai.win/realms/Brickverse/QrCodeResourceProviderFactory/mp-qr-status</a><br />你当然可以直接在服务器地址 URL 里配置上述地址，但是不推荐。因为上述地址是用来接收所有微信服务通知的，而这些通知不仅仅包含带参二维码的扫码消息，所以推荐配置一个专门的服务，然后在该服务下可以配置二次转发地址，这样就更加灵活了。<br />一个具体的例子，答疑家使用了nginx 服务器统一接收所有的微信通知，将在 nginx 中通过设置将消息中带有“Ticket”的带参二维码消息二次转发到以上的 Keycloak URL，这里分享出来供大家参考：\nnginx\n#微擎server\nserver{\nlisten 50091;\n#server_name _\nindex index.html index.htm index.php default.html default.htm default.php;\nroot  /home/wwwroot/wx.example.com/pros;</p>\n<pre><code>include enable-php-pathinfo.conf;\n\nlocation ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n{\n    expires      30d;\n}\n\nlocation ~ .*.(js|css)?$\n{\n    expires      12h;\n}\n\nlocation ~ /.well-known {\n    allow all;\n}\n</code></pre>\n<p>}</p>\n<p>#路由server\nserver{\nlisten 50090;\nindex index.html index.htm index.php default.html default.htm default.php;</p>\n<pre><code>location ^~ /api.php {\n    set $backend ;\n    rewrite_by_lua_block {\n        ngx.req.read_body()\n        local body = ngx.req.get_body_data() -- 读取请求body\n        if string.find(body, Ticket) then\n            -- 找到Ticket字符串\n            ngx.var.backend = https://auth.example.com/realms/DaYiJia/QrCodeResourceProviderFactory/mp-qr-scan-status\n        else\n            ngx.var.backend = http://127.0.0.1:50091\n        end\n    }\n    proxy_pass         $backend;\n    proxy_set_header   X-Real-IP        $remote_addr;\n    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n    proxy_set_header   content-type     application/xml;  #必须加上，否则keycloak返回错误信息\n}\n\nlocation / {\n    proxy_pass http://127.0.0.1:50091/; #默认转发到微擎server\n    proxy_set_header   Host      $host;\n    proxy_set_header   X-Real-IP        $remote_addr;\n    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n}\n\nlocation /hello_lua {\n    # lua测试\n    default_type text/plain;\n    content_by_lua ngx.say(hello, lua);\n}\n\naccess_log /home/wwwlogs/wx.example.com.log main;\nerror_log  /home/wwwlogs/wx.example.com.error.log error;\n\nadd_header Content-Security-Policy upgrade-insecure-requests;\n</code></pre>\n<p>}</p>\n<p>同样地，如果使用 Authing.cn 的服务，那么需要对应地将微信消息转发给 authing.cn 的服务器。\n<a name=patrh></a></p>\n<h2>手机微信登录</h2>\n<p>即在手机端微信里，点开某网站链接后，进行的微信授权登录。\n<a name=hiQAM></a></p>\n<h3>原理</h3>\n<p>这种微信登录方式，仍然使用了微信的公众平台，不过这时使用了 OAuth 2.0 / OIDC 的协议，从而可以很方便的集成，比起公众号关注即登录，要简单很多。\n<a name=EbyPt></a></p>\n<h2>PC 端扫码登录/开放平台登录</h2>\n<p>这就是所谓的普通扫码登录，要注意它和前两种方式有一个很大的区别，那就是不再依赖公众平台。它使用的是微信开放平台，要接入的话，有另一套独立的申请和认证流程。不过，好在一旦接入，它和手机微信登录一样，也是遵循 OAuth 2.0/OIDC 标准的，因此对接非常简单，基本上只需要对标准的 OIDC 库做一些 URL 配置即可。\n<a name=o3Mxg></a></p>\n<h1>总结</h1>\n<p>梳理了微信的 3 种登录接入方式，其中，公众号关注即登录最复杂，因为它是基于对微信的能力所做的一种灵活运用，微信官方文档并没有直接提及该登录方式。而另外两种登录方式分别应用于手机 Web 和 PC Web，虽然都是基于 OAuth 2.0/OIDC 标准，因此对接相对简单，但是要注意它们分别依赖公众平台和开放平台，彼此独立。<br />从费用上讲，你可以这样认为：如果只做手机 Web，那么一年需要 300 块的认证费用，花在公众平台上；如果只做 PC Web，那么一年也是需要 300 块的认证费用，花在开放平台上。但如果既想在手机 Web 上接入微信登录，同时又在 PC 端上接入，那么一般来说就需要一年 600 元的认证费用，同时认证公众平台和开放平台。如果想在手机 Web 和 PC Web 上都接入微信登录，但只想认证一个平台，即每年 300 元，那么可以不接入开放平台，而仅仅只接入公众平台，这时在 PC Web 上的微信登录就得另辟奚径，比如通过公众号的带参二维码来实现，这就需要更大的开发成本。不过通过借助<a href=\"https://github.com/Jeff-Tian/keycloak-services-social-weixin\">https://github.com/Jeff-Tian/keycloak-services-social-weixin</a> 或者 Authing.cn，就不需要开发了，而只需要将微信消息转发到你部署的 Keycloak 或者 authing.cn 服务器即可。<br />当然，通过实现自定义的微信登录，带来的不仅仅每年节省区区 300 元的成本，而是可以将粉丝和网站用户实现自动化的一一对应，这方面的好处远比 300 元要大得多。</p>","pages":[],"site":{"siteMetadata":{"title":"Jeff Tian","author":"@zizhujy","description":"A wild full stack developer","palette":"yellow","header":{"title":"Jeff Tian","tagline":"A wild developer","logo_img":"https://images.ctfassets.net/qixg1o8tujmf/7z1ua3nTOC5B7DwwzAki8I/4e1a05f8db770c285a492eeb1eaa398f/imageedit_3_2509022194.png","background_img":"https://images.ctfassets.net/qixg1o8tujmf/7m0jrKYaDBwEvlc5lo8nt6/6d50a5050d9cdc0d4d2047e35feac292/10648733_696750647079056_2800539603462658695_o.jpg","has_nav":true,"nav_links":[{"label":"Home","url":"/","style":"link","type":"action"},{"label":"About","url":"/about","style":"link","type":"action"},{"label":"关于","url":"https://ggyy.pa-pa.me/about","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"},{"label":"Contact","url":"/contact","style":"link","type":"action"},{"label":"Support Me","url":"/support-me","style":"link","type":"action"},{"label":"叽叽歪歪","url":"https://ggyy.pa-pa.me/","style":"link","icon_class":"lorem-ipsum","new_window":true,"type":"action"}],"has_social":true,"social_links":[{"label":"Twitter","url":"https://twitter.com/zizhujy","style":"icon","icon_class":"fa-twitter","new_window":true,"type":"action"},{"label":"Instagram","url":"https://www.instagram.com/jefftian5","style":"icon","icon_class":"fa-instagram","new_window":true,"type":"action"},{"label":"GitHub","url":"https://github.com/jeff-tian","style":"icon","icon_class":"fa-github","new_window":true,"type":"action"},{"label":"LinkedIn","url":"https://www.linkedin.com/jeff~tian","style":"icon","icon_class":"fa-linkedin","new_window":true,"type":"action"},{"label":"DEV","url":"https://dev.to/jefftian","style":"icon","icon_class":"fa-dev","new_window":true,"type":"action"},{"label":"知乎","url":"https://www.zhihu.com/people/jefftian","style":"icon","icon_class":"fa-zhihu","new_window":true,"type":"action"}],"type":"header"},"footer":{"content":"&copy; All rights reserved.","links":[{"label":"Made with Stackbit.","url":"https://www.stackbit.com","style":"link","new_window":true,"type":"action"},{"label":"紫竹叽歪","url":"https://zizhujy.apphb.com","style":"link","icon_class":"http://zizhujy.apphb.com/Content/Images/logo.png","new_window":true,"type":"action"}],"type":"footer"}},"pathPrefix":"","data":{"data":{"author":{"name":"Jeff Tian","avatar":"https://res.cloudinary.com/practicaldev/image/fetch/s--a5qDZLv3--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/318420/3bfd2d99-430c-4049-8dd5-e2adc961e1e0.png"},"social":{"devto":{"username":"jefftian"},"twitter":{"username":"zizhujy"},"github":{"username":"Jeff-Tian"}}}}},"menus":{}}},"staticQueryHashes":[],"slicesMap":{}}