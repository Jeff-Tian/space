---
stackbit_url_path: >-
  posts/将小数转化为分数的算法
title: '将小数转化为分数的算法'
date: '2014-01-21 04:53:33.176653'
excerpt: >-
  
comments_count: 0
positive_reactions_count: 0
tags: 
  - Math.pow()
  - javascript
  - 函数涂鸦板
  - 小数
  - 循环
  - 无理数
  - 有理数
  - 求和公式
  - 等比数列
  - 级别
canonical_url: >-
template: post
---
<h2><font color="#9b00d3">问题：</font></h2>  <p>对于一个分数，使用除法就能够得到其小数表示。如：</p>  <p>2/3 = 0.66666<u>6</u>…</p>  <p>一般计算器都支持将分数转化成小数的计算模式。但是反过来，拿到一个小数，怎么得到其分数的表示形式呢？似乎没有像除法这样直接的算法，而且一般的计算器和计算程序都没有将分数转化成小数的模式。</p>  <p>比如，拿到一个小数：0.571428<u>571428</u>…，怎么知道它等于4/7？</p>  <h2><font color="#9b00d3">分析：</font></h2>  <p>小数可分为以下几种：</p>  <ul>   <li><strong>有限小数</strong>，如0.5678， </li>    <li><strong>无限循环小数</strong>，如刚才的例子：0.571428<u>571428</u>… </li>    <li><strong>无限不循环小数</strong>，如：3.141592654…（<i>π</i>） </li> </ul>  <p>对于第一种，有限小数，转化成分数很简单，比如：</p>  <p>0.5678 （共4位小数，把它乘以10的4次方，再除以10的4次方）</p>  <p>= 5678 / 10000 （约分到最简——找出分子分母的最大公约数，同除之）</p>  <p>= 2839 / 5000</p>  <p>对于第二种，无限循环小数，先找到循环节，然后将这个小数按照这些循环节拆成小限小数，而这个小数本身是这些无限个有限小数的和。比如：</p>  <p>0.571428<u>571428</u>… </p>  <p>（循环节是571428）</p>  <p>= 0.571428 + 0.000000571428 + 0.000000000000571428 + …</p>  <p>（再进行一些数学计算，会简化出一个模式来）</p>  <p>= 571428 * 10<sup>-6</sup> + 571428 * 10<sup>-12</sup> + 571428 * 10<sup>-18</sup> + …</p>  <p>= 571428 * (10<sup>-6</sup> + (10<sup>-6</sup>)<sup>2</sup> + (10<sup>-6</sup>)<sup>3</sup> + …)</p>  <p>注意到无限小数就是一个以循环节为整数的数乘以一个无限等比数列（公比是10<sup>-6</sup>，公比小于1。这个数列好像叫做级数？）的和，而这个级数和，正好可以算出一个精确的分数值（首项 / (1 - 首项)）。将它们相乘，再约分，即能得到最终我们想要的分数值。接上面的等式：</p>  <p>= 571428 * (10<sup>-6</sup> / (1 - 10<sup>-6</sup>))</p>  <p>= 571428 * (1 / 999999)</p>  <p>= 571428 / 999999</p>  <p>= 4 / 7</p>  <p>对于第三种，无限不循环小数，没有办法转化成一个分数。事实上，有限小数和无限循环小数都是有理数，而这个无限不循环小数得无理数。有理数可以写成分数形式，而无理数是不可以的。它们是属于两个不同的世界。</p>  <h2><font color="#9b00d3">总结：</font></h2>  <p>有理数小数可以转化成分数形式，而无理数小数则不行。</p>  <p>对于<strong>有限小数</strong>，转化成分数的方法是：</p>  <ol>   <li>数出其小数位数（有效小数位数）n</li>    <li>以10为底，计算10的n次方作为因子</li>    <li>对小数乘以这个因子作为分子，将因子作为分母</li>    <li>约分化简</li>    <li>完成</li> </ol>  <p>对于<strong>无限循环小数</strong> ，转化成分数的方法是：</p>  <ol>   <li>找出循环节，将它作为一个整数m，并作为分子</li>    <li>数出这个循环节的位数n</li>    <li>以10为底，计算10的n次方作为因子</li>    <li>将这个因子减去1，作为分母</li>    <li>约分化简</li>    <li>完成</li> </ol>  <p>对于<strong>无限不循环小数</strong>，无法转化成分数。不过这里留一个问题：是否有可能找到一种方法，将其转化成精确的无理数表示形式？比如：</p>  <ul>   <li>3.141592654… –&gt; <i>π</i></li>    <li>1.414213562… –&gt; 2的平方根</li>    <li>等等</li> </ul>  <h2><font color="#9b00d3">实际用途：</font></h2>  <p>在《<a href="http://zizhujy.com/blog/post/2012/02/21/%E5%AF%B9JavaScript%E7%9A%84Mathpow()%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BF%AE%E6%AD%A3.aspx">对JavaScript的Math.pow()函数的一个修正</a>》中提到，JavaScript的Math.pow()不能够计算诸如(-27)^(1/3)等负数的奇次方根。</p>  <p>该文给出的修正方案解决了这个问题，但是使用该方案仍然不能够求出(-27)^(2/3)（实际得到结果 NaN，我们期待得到结果 9）。</p>  <p>要解决这个新的问题，便需要使用小数转化成分数的方法（前文中的方案只是对小数求倒数，看它是否是1/n，若是并且当n是奇数时，进行一下特殊处理以计算出期待的结果；若n是偶数，则计算不出结果或结果是 NaN 是合理的，因为负数没有偶数次方根）。</p>  <p>具体原因和具体解决方案，后面的博文继续介绍。大概情况是，当在JavaScript中求 Math.pow(-27, 2/3)时，传给Math.pow()函数的2/3这个参数，在到达函数体时已经被存储成了小数，在这个函数体里，需要尝试将这个小数转换成分数，若转换成功，则计算出结果，比如9。若转换不成功，则说明这个小数是无理数，那么给出结果 NaN 是合理的（一个数的无理数次方，没有定义是比较正常的吧）。</p>  <p>当然，JavaScript只存储小数的有限数位，所以，对于这个理想的转换方法，在JavaScript中还需要进行一些奇怪的处理：只要一个小数看上去像是一个无限循环小数，那么就将其当成真的是无限循环小数，然后应用总结中的算法，将其转换成分数。</p>  <p>有了这些之后，<a href="http://zizhujy.com/zh-CN/FunctionGrapher" target="_blank">函数涂鸦板</a>便能正确画出类似<a href="http://zizhujy.com/zh-CN/FunctionGrapher?fns=base64%252FWyJ5PVxcbGVmdCh4XjItMVxccmlnaHQpXntcXGZyYWN7Mn17M319Il0%253D" target="_blank">这种函数的图形</a>了：</p>  <p><a href="http://zizhujy.com/zh-CN/FunctionGrapher?fns=base64%252FWyJ5PVxcbGVmdCh4XjItMVxccmlnaHQpXntcXGZyYWN7Mn17M319Il0%253D" target="_blank">y=(x2-1)2/3</a><sup></sup></p>  <p>目前<a href="http://zizhujy.com/zh-CN/FunctionGrapher" target="_blank">函数涂鸦板</a>画出的它的图形在（-1 &lt; x &lt; 1）的范围里不正确，原因就是因为JavaScript的 Math.pow() 函数的缺陷。</p>  <p><a href="http://zizhujy.com/zh-CN/FunctionGrapher?fns=base64%252FWyJ5PVxcbGVmdCh4XjItMVxccmlnaHQpXntcXGZyYWN7Mn17M319Il0%253D" target="_blank"><img title="$y=\left(x^2-1\right)^{\frac{2}{3}}$ 的不正确的图形" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="$y=\left(x^2-1\right)^{\frac{2}{3}}$ 的不正确的图形" src="http://zizhujy.com/blog/image.axd?picture=image_247.png" width="620" height="572" /></a></p>  <p>这个修正即将上线，<a href="http://zizhujy.com/zh-CN/FunctionGrapher?fns=base64%252FWyJ5PVxcbGVmdCh4XjItMVxccmlnaHQpXntcXGZyYWN7Mn17M319Il0%253D" target="_blank">正确的图形</a>马上就要出来了！</p>  <p><a href="http://zizhujy.com/zh-CN/FunctionGrapher?fns=base64%252FWyJ5PVxcbGVmdCh4XjItMVxccmlnaHQpXntcXGZyYWN7Mn17M319Il0%253D" target="_blank"><img title="$y=\left(x^2-1\right)^{\frac{2}{3}}$ 的正确的图形" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="$y=\left(x^2-1\right)^{\frac{2}{3}}$ 的正确的图形" src="http://zizhujy.com/blog/image.axd?picture=image_461.png" width="620" height="545" /></a></p>  <h2><font color="#9b00d3">附（等比数列求和算法）：</font></h2>  <p>【定理1】<strong>数列 {q, q<sup>2</sup>, q<sup>3</sup>, …, q<sup>n</sup>} 的和为 S = (q + q<sup>(n+1)</sup>) / (1 - q)。</strong></p>  <p>【证明】</p>  <p>（1）S = q + q<sup>2</sup> + … + q<sup>n</sup></p>  <p>q * S = q * (q + q<sup>2</sup> + … + q<sup>n</sup>)，即</p>  <p>（2）q * S = q<sup>2</sup> + q<sup>3</sup> + … + q<sup>(n+1)</sup></p>  <p>（1）式与（2）式两边同时相减</p>  <p>S – q * S = (q + q<sup>2</sup> + … + q<sup>n</sup>) – (q<sup>2</sup> + q<sup>3</sup> + … + q<sup>(n+1)</sup>)</p>  <p>即：</p>  <p>(1 - q) * S = q + <strike>(q<sup>2</sup> – q<sup>2</sup>)</strike> + <strike>(q<sup>3</sup> – q<sup>3</sup>)</strike> + … <strike>(q<sup>n</sup> – q<sup>n</sup>)</strike> + q<sup>(n+1)</sup></p>  <p>(1 – q) * S = q + q<sup>(n+1)</sup></p>  <p>所以：</p>  <p>S = (q + q<sup>(n+1)</sup>) / (1 - q)</p>  <p>【证毕】</p>  <p>【定理2】<strong>级数 {q, q<sup>2</sup>, …, q<sup>n</sup>, …} （0 &lt; q &lt; 1）的和为 S = q / (1-q)。</strong></p>  <p>【证明】</p>  <p>【证法1】对【定理1】对n—&gt;无穷大取极限。</p>  <p>【证法2】如法炮制【定理1】的证明过程：</p>  <p>（1）S = q + q<sup>2</sup> + … + q<sup>n</sup> + …</p>  <p>q * S = q * (q + q<sup>2</sup> + … + q<sup>n</sup> + …)，即</p>  <p>（2）q * S = q<sup>2</sup> + q<sup>3</sup> + … + q<sup>(n+1)</sup> + …</p>  <p>（1）式与（2）式两边同时相减</p>  <p>S – q * S = (q + q<sup>2</sup> + … + q<sup>n</sup> + …) – (q<sup>2</sup> + q<sup>3</sup> + … + q<sup>(n+1)</sup> + …)</p>  <p>即：</p>  <p>(1 - q) * S = q + <strike>(q<sup>2</sup> – q<sup>2</sup>)</strike> + <strike>(q<sup>3</sup> – q<sup>3</sup>)</strike> + … <strike>(q<sup>n</sup> – q<sup>n</sup>)</strike> + …</p>  <p>(1 – q) * S = q</p>  <p>所以：</p>  <p>S = q / (1 - q)</p>  <p>【证毕】</p>